<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Match-LSTM和Pointer Net]]></title>
    <url>%2Fmatch-LSTM-Pointer-Network%2F</url>
    <content type="text"><![CDATA[Match-LSTM简介Match-LSTM是由(Wang &amp; Jiang,2016)发表在NAACL的论文提出，用于解决NLI(Natural Language Inference，文本蕴含)问题。 premise：前提，代表上下文 hypothesis：假设，代表一个陈述性的结论 文本蕴含问题：给定一个premise（前提），根据这个premise去判断相应的hypothesis（假说）正确与否，如果从这个premise中能够推断出这个hypothesis，那么就判断为entailment（蕴含），否则就是contradiction（矛盾）。 Word-by-Word AttentionMatch-LSTM是在Rocktaschel et al. (2015)提出的word-by-word attention的基础上进行了改进，先解释一下Rocktaschel et al. (2015)提出的基本模型 用LSTM处理premise和hypothesis，(用premise的最后一个输出初始化hypothesis的LSTM)，得到它们的隐层输出。 其中， $h_j^s(1 \le j \le M )$是premise的输入序列经过LSTM之后得到的隐层输出。 $h_{k}^{t}(1\leq k\leq N)$是hypothesis的隐层输出向量。 word-by-word attention的意思是为每个hypothesis中的词引入一个 $a_k$ ,用于表示hypothesis，并称这个 $a_k$ 向量为attention向量，具体公式如下： 这里的attention权重$a_{kj}$表示hypothesis中第k个词和premise中第j个词之间的关系。 $h_j^s$ 是premise的隐层输出，$h_k^t$ 是hypothesis的隐层输出，$h_{k-1}^a$ 是将输入一个RNN之后得到的隐层状态。 最后利用$h_N^a$和$h_N^t$来预测label：y，即判断premise和hypothesis之间的关系。 流程 用两个LSTM处理premise和hypothesis序列。得到两个隐状态$h^s$和$h^t$(s对应前提，t对应假设)。 用下面的公式计算注意力向量$a_k$,这里计算得到的$e$经过归一化和加权求和得到假设$h^t$对前提$h^s$在每个时刻的注意力向量$a_k$ 上式中$h^m$的计算，用下面的公式计算，其中输入$m_k$是$[a_k,h_k^t]$的拼接。作者把这个结构称为mLSTM，把最后时刻的$h^m$作为输出以预测label。 ​ 与Word-to-Word Attention区别 两者的主要区别就是计算$e_{kj}$的不同。 这里用$h^m$代替了$h^a$。 之前的$h^m$是利用RNN得到的,$h^a$是用mLSTM得到的。 为了得到premise跟hypothesis之间的matching关系，用LSTM对它们进行建模，作者认为LSTM能够将premise和hypothesis之间重要的match关系进行保留，忽略不重要的match关系。具体公式如下: 最后利用$h_N^m$来预测。 Pointer Net简介Pointer Network是Vinyals et al.(2015)在NIPS发表的论文中提出的，是为了实现从输入序列中找到相应的tokens来作为输出，其他的阅读理解任务中，可能只需要用输入序列构建一个词典，再从这个候选词典中找到概率最大的一个词作为答案，然而SQuAD数据集的输出答案的长度是变化的，因而无法采用构建词典的方式，而pointer net是利用attention作为pointer，从输入序列中选择一个位置，并将这个位置所指向的词作为输出。对pointer net有兴趣的话，可以参看这个链接进行学习:Pointer net。AS-Reader、AoA-Reader和R-Net等模型都用了PtrNet作为输出层的结构。 模型结构 论文中提出了两个模型，且都包含以下三个部分： 用LSTM对question和passage进行预处理。 用match-LSTM对question和passage进行match。 利用Pointer Net从passage中选择tokens作为答案。 两个模型的区别在于在于第三部分，由于pointer net没有限定所指向的位置必须是连续的，所以第一个模型sequence model直接将答案在passage中出现的位置序号作为答案序列$a=\left( a_{1} ,a_{2},… \right) $，第二个模型只预测答案的起始位置跟终止位置，即$a=\left(a_{s} ,a_{e} \right)$。 LSTM Preprocessing Layer用单向LSTM对passage和question进行预处理。 Match-LSTM Layer这里将question当做premise，将passage当做hypothesis，用标准的word-by-word attention得到attention向量，具体公式如下： 其中， $\vec{h}_{i-1}^r \in R^l$是经过单向m-LSTM得到的隐层输出。 $\vec{\alpha_{i,j}}$表示passage中的第i个词和question中的第j个词之间的匹配关系。然后用$\overline{\alpha}$对question的隐层输出进行加权，并将其跟passage的隐层输出进行拼接，得到一个新的向量，并输入到m-LSTM中，得到$\bar{H^r}$，具体公式如下： 再从另一个方向进行相同的处理,将两者进行合并，得到最后的输出向量$H^{r} $ Answer Pointer LayerThe Sequence Model 由于这个模型是生成答案的位置序列$a=(a_{1} ,a_{2},…)$，每个元素表示的是这个词在passage中位置，其取值范围在1到P+1之间，当出现了P+1时，则答案生成终止。因此在$H^{r}$的最后中加入了一列0向量，用来表示终止词，得到$\bar{H} ^{r} $。 这里再次用到了attention方法去得到向量$\beta_k \in R^{(P+1)}$,$\beta_{k,j}$表示选择passage中的第j个词作为答案序列的第k个词的概率，$\beta_{k,(P+1)}$表示在第k个位置停止答案生成的概率。公式如下： 其中，$h_k^a$也是经过一个LSTM的输出。 模型生成答案的概率公式如下： 损失函数如下： The Boundary Model因为boundary model只需要生成答案的起始和终止位置，因此不用在最后加入一个零向量来表示答案生成结束。生成答案序列的概率模型如下： 其余部分与上个模型相同。]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>阅读理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务型多轮对话系统概述]]></title>
    <url>%2Ftask-oriented-dialog-system%2F</url>
    <content type="text"><![CDATA[主要模块任务型机器人核心模块主要包括三个模块： 自然语言理解模块（NLU） 对话管理模块 自然语言生成模块（NLG） 自然语言理解模块该模块一般包含以下三个模块： 领域识别：即识别该语句是不是属于这个任务场景，一般有多个机器人集成时，如闲聊机器人，问答机器人等，领域识别应当在进入任务型机器人之前做判断与分发 意图识别：即识别用户意图，细分该任务型场景下的子场景、 语义槽填充：用于对话管理模块的输入 举例假设Text=“人民币对美元的汇率是多少”；经过自然语言理解模块会解析为 act ( slot1 = value1, slot2 = value2 ……) 的形式，即意图，槽位，槽位信息三元组形式，即 Text会解析为“查询（槽位1=人民币，槽位2=美元)”这样的形式。 方法基于规则理解方法【优点】 不需要大量训练数据 【缺点】 容易出错 调整规则费时费力，难以维护 统计方法（对齐）基于词对齐数据的自然语言理解通常被看做一个序列标注问题。主要有以下两类方法： 基于生成式模型 随机有限状态机（FST） 统计机器翻译（SMT） 动态贝叶斯网络（DBN） 基于判别式模型 CRF SVM MEMM 深度学习 BiLSTM+CRF CNN：用于序列标注 Seq2Seq 对话管理模块自然语言理解模块的三元组输出将作为对话管理系统的输入。它主要包括两部分： 状态追踪模块 对话策略模块 【状态追踪模块】 该模块在对话的每一轮次对用户的目标进行预估，管理每个回合的输入和对话历史，输出当前对话状态。 【对话策略模块】 该模块的主要功能是根据前面的对话状态决策采取的最优动作（如：提供结果，询问特定限制条件，澄清或确认需求等）从而最有效的辅助用户完成信息或服务获取的任务。该模块基于用户输入的语义表达和当前对话状态输出下一步的系统行为和更新的对话状态。 举例text=“人民币对美元的汇率是多少”。“查询（槽位1=人民币，槽位2=美元)”这样的形式将作为对话管理模块的输入，这时候状态追踪模块就要根据前几轮的信息，结合该输入判断该轮的查询状态，确定查询的槽位，以及与数据库的交互。如得到想要查询的确实是人民币对美元的汇率信息。这时候，根据现有的对话策略判断当前的槽位状态，最后给出对话管理模块的输出，如查询结果(源货币=人民币，目标货币=美元，汇率=1:0.16) 自然语言生成模块该模块主要任务是将对话策略输出的语义表达生成流畅可读的自然语言句子，反馈给用户。]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>多轮对话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装python3]]></title>
    <url>%2Fcentos-install-python%2F</url>
    <content type="text"><![CDATA[下载安装包 sudo wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz 解压 sudo tar -xvJf Python-3.6.2.tar.xz 进入到解压后的Python-3.6.2文件夹 编译安装 sudo ./configure --prefix=xxxxmake &amp;&amp; make install 【注】prefix后是Python-3.6.2的解压路径的父目录 添加软连接到执行目录/usr/bin ln -s xxx/bin/python3 /usr/bin/python3ln -s xxx/bin/pip3 /usr/bin/pip3 【注】xxx代表python的安装路径，即步骤四的prefix后的路径]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无Root权限中Ubuntu安装Python]]></title>
    <url>%2Fno-root-install-python%2F</url>
    <content type="text"><![CDATA[下载Python wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz 解压 tar -xvf Python-3.6.3.tar.zx 进入到解压后的文件夹 cd Python-3.6.3 ./configure --prefix=&#39;Your Install Director&#39; make &amp;&amp; make install 添加路径,编辑~/.bashrc vim ~/.bashrc 在文件最后添加 export PATH=/Your Install Path:$PATH，如export PATH=/usr/local/bin/:$PATH 创建别名，编辑~/.bashrc vim ~/.bashrc 在文件最后添加 alias python='Your python path'alias pip='Your pip path' ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Docker CE for Windows后VirtualBox无法启动问题解决]]></title>
    <url>%2Fdocker-virtualbox-problem%2F</url>
    <content type="text"><![CDATA[原因在Windows上运行Docker需要借助虚拟机来运行一个简化的Linux系统，Docker CE for Windows使用的是Windows系统自带的Hyper-V（从Win8开始）虚拟机组件。 因此在安装Docker CE for Windows时，会打开Hyper-V组件（默认是关闭的），会和Virtual Box冲突。 解决方案关闭Hyper-V组件控制面板-程序和功能-启用或关闭Windows功能，去掉Hpyer-V功能。重启。 打开Virtualbox依然报错 这是因为vboxdrv服务没有安装或成功启动，在Virtualbox安装目录下的drivers\vobxdrv文件夹下，右击VBoxDrv.inf，选择安装，然后重启。 如果还是失败，则直接重新安装即可。 安装老版Docker Toolbox老版Docker Toolbox使用的时Virtualbox虚拟机。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10下Docker简明教程]]></title>
    <url>%2Fwindows-docker%2F</url>
    <content type="text"><![CDATA[概述Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 内部结构 Docker使用C/S架构模式，Docker客户端会与Docker守护进程通信。Docker守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。 Docker分为三种部件： Docker镜像-Docker Images Docker容器-Docker Containers Docker仓库-Docker Registeries Docker镜像Docker运行容器前需要本地存在对应的镜像。Docker镜像可以用来创建Docker容器，一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序。 Docker镜像是只可读的，一个镜像可以创建多个容器。 通俗说，Images是已经打包好的环境文件，我们运行的时候把Images加载运行在本地容器中，你在这个容器中可以进行一些修改重新打包成新镜像上传。 分层存储因为镜像包含操作系统完整的root文件系统，其体积往往是巨大的，因此Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。 分层存储的特征使得镜像并非像一个ISO类似的打包文件，而是由一组文件系统组成。 Docker容器Docker利用容器来开发、运行应用。容器是镜像创建的实例，可以被开始、启动、停止、删除。每个容器都是相互隔离的。 Docker仓库仓库是集中存放镜像文件的场所。每个仓库中包含了多个镜像，每个镜像有不同的标签。 最大的公开仓库是DockerHub)，因为墙的原因，可以使用DaoCloud、阿里云)加速下载。 安装 Win10版本Docker安装以下版本Docker Community Edition 17.12.0-ce Win10之前版本安装Docker ToolBox，官方文档 安装之前，需要开启Windows10的Hpyer-V。 控制面板-程序-启用或关闭Windows功能 本文以Docker Community Edition为例，开启Hpyer-V后直接安装Docker Community Edition即可。 安装成功后，运行cmd,执行docker version，安装成功则显示下图 设置Docker任务栏鲸鱼图标右键-Settings打开设置界面 Shared Drivers：可以将主机（即Windows）中的驱动器共享到Docker Container中 Advanced：用于配置运行Docker Daemon的虚拟机环境的CPU和内存和镜像路径 Network：配置Docker的网络环境 Proxies：代理的配置 Docker Daemon：使用JSON格式的设置，对Docker Daemon进行设置，类似于在Linux中利用conf文件对Docker设置。 修改CPU数目及内存点击Advanced，如下图修改参数即可 修改代理Docker Hub速度较慢，修改为阿里云镜像。 登陆容器Hub服务，找到以下链接 点击Daemon设置镜像，直接在Registry mirrors中填写阿里云的镜像地址，点击Apply重启应用即可。 更改镜像默认存储路径打开Docker的Settings，点击Advanced，在Images and volumes VHD location选择新的路径。重启后即可更新设置。 常用命令查看Docker版本docker version 查看本机已安装镜像docker images 查看所有容器docker ps -a 拉取镜像docker pull Name:Tag 【例】 docker pull sameersbn/redmine:latest 删除单个容器docker rm Name/ID 删除所有的容器docker rm docker ps -a -q 停止、启动、杀死一个容器docker stop Name/IDdocker start Name/IDdocker kill Name/ID 参考 【Docker】windows10 docker 使用 Docker on Windows初体验 Docker for Windows使用简介 Docker的Windows容器初体验]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10下Docker搭建深度学习框架]]></title>
    <url>%2Fdocker-deeplearning%2F</url>
    <content type="text"><![CDATA[概述DeepoDeepo是一个几乎包含所有流行深度学习框架的Docker映像，拥有一个完整的可复制的深度学习研究环境。它涵盖了 theano tensorflow sonnet pytorch keras lasagne mxnet cntk chainer caffe torch 安装直接从Docker Hub下载Deepo镜像。Github地址 CPU版本 docker pull ufoym/deepo:cpu GPU版本 docker pull ufoym/deepo 运行打开powershell执行以下命令，以bash方式运行该容器。 docker run -it ufoym/deepo:cpu bash DL-docker包含的框架及系统依赖 Ubuntu 14.04 CUDA 7.5 (GPU version only) cuDNN v4 (GPU version only) Tensorflow Caffe Theano Keras Lasagne Torch (includes nn, cutorch, cunn and cuDNN bindings) iPython/Jupyter Notebook (including iTorch kernel) Numpy, SciPy, Pandas, Scikit Learn, Matplotlib A few common libraries used for deep learning 安装 cpu版本 docker pull floydhub/dl-docker:cpu 运行docker run -it -p 8888:8888 -p 6006:6006 -v /sharedfolder:/root/sharedfolder floydhub/dl-docker:cpu bash 运行以上命令后，会连接到bash，执行jupyter notebook。 然后在Windows的浏览器中输入localhost:8888，会连接到该容器的Jupyter notebook]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常见问题解决方法]]></title>
    <url>%2Fhexo-solve%2F</url>
    <content type="text"><![CDATA[fatal: HttpRequestException encountered. 将_config.yml中的repository: https://github.com:username/username.github.io.git 改成repository: git@github.com:username/username.github.io.git]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Jupyter Notebook]]></title>
    <url>%2Fwindows-jupyter-notebook%2F</url>
    <content type="text"><![CDATA[简介文学编程文学编程(Literate Programming)是由Donald Knuth提出的编程方法。传统的结构化编程，人要按照计算机的逻辑顺序来编写代码，而文学编程则可以让人们按照自己的逻辑来开发程序。 Jupyter NotebookJupyter Notebook是一个交互式笔记本，支持运行40多种编程语言。它的本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和markdown。 Jupyter Notebook优点： 适合数据分析 支持多语言 分享便捷 远程运行 交互式展示 ##安装 安装Anaconda即自带，不需要安装 启动点击Jupyter Notebook即可启动，或在cmd中输入jupyter notebook 默认地址为http:localhost:8888 使用更改Jupyter Notebook工作空间最新版Ipython和Jupyter配置文件是分开的，需要分别配置文件。 打开cmd输入命令jupyter notebook --generate-config 【注】-config之前没有空格 打开该目录下的文件，改文件夹路径 【注】若存在编码问题，可改成f://file//jupyter_notebook 启动Jupyter Notebook 新建Notebook点击new创建新的Notebook 界面 菜单栏各项功能概述 File Save and Checkpoint 保存并记录点，类似于不同版本 Revert to Checkpoint返回到某一记录点 View Toggle Header是否显示头部信息，包括文件名和上次保存时间 Toggle ToolBar是否显示工具栏 Kernel Change kernel更换内核环境 Notebook文档由一系列单元(cell),主要有两种形式的单元： 代码状态单元：编写代码的区域，使用Shift+Enter运行代码，结果显示在本单元下方。代码单元左边有In[1]：类似的序列标记，方便人们查看代码的执行次序。 Markdown状态单元：编写文本的区域，使用Shift+Enter显示格式化的文本。 模式 编辑模式：编辑文本和代码。选中单元按Enter进入编辑模式，单元左侧显示绿色竖线 命令模式：执行输入的命令。按Esc进入命令模式，单元左侧显示蓝色竖线 快捷键命令模式 查看快捷键：H 执行当前单元，并自动跳到下一个单元：Shift+Enter 执行当前单元，不自动跳到下一个单元：Ctrl+Enter 进入编辑模式：Enter 进入命令模式：Esc 删除当前单元：双击D 变为代码状态：Y 变为Markdown状态：M 在下方插入新单元：B 剪切选中单元：X 复制选中单元：C 粘贴到下方单元：V 选中上方单元：J 选中下方单元：K 恢复删除的最后一个单元：Z 保存当前Notebook：Ctrl+S 编辑模式 代码缩进或补全：Tab 代码提示：Shift+Tab 注释：Ctrl+/ Magic命令Magic命令以%或%%开头 %：行命令 %%：单元命令。必须出现在单元第一行。 以下为常用Magic命令 %lsmagic：列举所有Magic命令 %magic：查看Magic命令说明 %timeit：代码运行时间 %matplotlib inline：显示matplotlib包生成的图形 使用技巧运行Python文件运行以下命令 %run xxx.py 【注】xxx.py是当前工作空间下的一个python文件 导入代码运行以下命令 %load xxx.py 【注】xxx.py是当前工作空间下的一个python文件 重置单元格序号重置单元格In[x]序号 点击Kernel-Restart即可。 使用Seaborn绘图需要使用%matplotlib inline命令。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下安装Anaconda]]></title>
    <url>%2Fubuntu-ancaconda%2F</url>
    <content type="text"><![CDATA[Anaconda安装下载使用Python3.6版本的Anaconda 5.1，点击下载 安装 进入到下载后的文件目录，执行 bash Anaconda3-5.1.0-Linux-x86_64.sh 根据提示输入回车 查看注册信息，一直回车到输入yes 输入安装目录路径，默认回车即可 是否加入环境变量，输入yes 安装成功后，新打开一个终端输入以下命令查看版本号 anaconda -V 使用Jupyter Notebook输入以下命令则能够使用Jupyter Notebook ipython notebook]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】Python中字典常用方法]]></title>
    <url>%2Fpython-dict%2F</url>
    <content type="text"><![CDATA[字典常用操作定义空字典dic=&#123;&#125; 键值对的添加dic['name']='zhangsan' 字典遍历通过items()方法返回的元组列表进行序列解包 for key,value in dic.items(): print('&#123;&#125;:&#123;&#125;'.format(key,value)) #print('%s:%s' %(key,value)) 字典排序字典按键排序第一类dic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;print(key,dic[key] for key in sorted(dic.keys)) 第二类dic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;#升序排序dic=dict(sorted(dic.items(),key=lambda x:x[0]))#降序排序dic=dict(sorted(dic.itmes(),key=lambda x:x[0],reverse=True)) sorted(iterable,key,reverse) iterable参数代表可以迭代的对象，例如可以是dict.items()，dict.keys() key参数是一个函数，用来选取参与比较的元素 reverse参数用来指定是升序还是降序 dic=dict(sorted(dic.items(),key=lambda x:x[0])) dic.items()将dic转换为可迭代对象，迭代对象的元素为该字典元素，将其转换为元组 key参数对应的lambda表达式即选取元组中的第一个元素作为比较参数，即键。 lambda x:yx表示输出参数，y表示lambda函数的返回值. sorted()函数返回值是list类型。 字典按值排序并输出Top K个元素dic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;#升序排序dic=dict(sorted(dic.items(),key=lambda x:x[1]))#降序排序dic=dict(sorted(dic.itmes(),key=lambda x:x[1],reverse=True))#输出Top K个cnt=0k=10for key,value in dic.items(): cnt+=1 if cnt&gt;k: break print('&#123;&#125;:&#123;&#125;'.format(key,value)) 字典对象写入Json文件import jsondic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;#中文字符需要设置ensure_ascii属性为False，否则输出为ASII码data=json.dumps(dic,ensure_ascii=False)with open('xxx.json','w',encoding='utf-8') as f: f.write(data)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[武大植物分布]]></title>
    <url>%2Fwhu-plants%2F</url>
    <content type="text"><![CDATA[文理学部李达塑像 樟树 蝴蝶花：4月，鸢尾科 鸢尾 吉祥草：百合科，秋花 南天竹：小檗科 锦绣杜鹃：杜鹃科 麦冬：百合科，6月开花 池衫 羊蹄：蓼科，酸模属 车前 蛇莓：蔷薇科，果不能吃 扬子毛茛 何首乌：蓼科 鸡矢藤：蓼科 海仙花 紫丁香 厚萼凌霄：位于亭子，6月开花 紫荆：苏木亚科，早春 工学部世纪广场 二球悬铃木 樟树 棕榈 复羽叶栾树 洋玉兰：常绿乔木，椭圆形革质叶 玉兰（白玉兰）：落叶乔木，先叶开花 结香：瑞香科，早春开花，先叶开花，花香久闻头疼 苏铁（铁树）：裸子植物，苏铁科 鹅观草：位于世纪广场草丛，下同 棒头草 雀麦 菵草 看麦娘 瓶尔小草：蕨类，此类是野生，不属于武大常规品种 绶草（盘龙参）：兰科，此类是野生，不属于武大常规品种 医学部广场 雪松 桂花（木犀） 樟树 池衫 细叶结缕草：位于广场草地，下同 狗牙根 早熟禾：早春开花 救荒野豌豆：荚果，比下类野豌豆果长 四籽野豌豆：荚果， 匍茎通泉草：玄参科，通泉草属，二唇形花 直立婆婆纳：玄参科 垂丝海棠：，蔷薇科苹果亚科苹果属，不位于广场，下同 贴梗海棠：灌木状，木瓜属，结果 槐树：豆科 喜树：珙桐科 信部星湖园 孝顺竹：丛生，禾本科 君迁子（黑枣）： 旱柳：星湖周围，下同 垂柳 榔榆：榆科，秋花秋果 朴树：榔榆旁边 木瓜：蔷薇科，树皮类似迷彩服 臭椿：苦木科 侧柏：柏科 柏木 武大牌坊入口区 金叶女贞 大叶黄杨 樟树 人文馆 桂花 圆柏 海桐 含笑 大叶黄杨 龙爪槐 桃花：距离人文馆稍远处，下同 梅花 山茶 紫薇 情人坡 池衫 山茶 垂丝海棠 贴梗海棠 湖北海棠 木瓜 茶港教工宿舍区小游园 枇杷 桂树 西区教工宿舍小游园 广玉兰 桂树 雪松 棕榈 小叶女贞 大叶黄杨 紫藤 中心湖区 秤锤树 杜仲 榔榆 朴树 小叶栎 皂荚 毛竹 紫叶李 绣球荚蒾 红继木 鸡爪槭 红枫 蝴蝶花 麦冬 酢浆草 珞珈山枫园路 水杉 枫树 棕榈 桂树 石楠 柑橘 鸡爪槭 紫叶李 老图书馆王世杰塑像 银杏 黑松 刺柏 黄连木 石榴 海桐 王星拱塑像 女贞 棕榈 海桐 法国冬青 西侧入口 石榴 南天竹 桂树 石榴 桑树 落木石楠 朴树 东侧入口 石楠 英国梧桐 龙柏 棕榈 侧柏 广玉兰 大楼前与老斋舍接邻草地 大叶黄杨 油茶 石榴 侧柏 棕榈 柑橘 黑松 红檵木 狗牙根 老斋舍顶从东到西的种植槽 龙柏 椤木石楠 竹 木槿 紫藤 圆柏 刺柏 行政楼行政楼内左右两侧的绿化圃 龙柏 吉祥草 行政楼东侧 对节白蜡 樱花基于《珞珈山原色植物图谱》 240号红花高盆樱：2月底至三月初开花，位于梅园校医院 241号尾叶樱桃：3-4月开花，位于行政楼旁，即绿樱，橘黄色果 242号大岛樱：3-4月开花，鲲鹏广场后的花园有几株 243号东京樱花：4月开花，奥场周围，樱花大道，黑果 244号垂枝樱花：3月底至四月初开花，晚樱，位于枫园14舍，岔路口通往枫园食堂。枫园三舍南侧路边、樱园南坡绿地（即情人坡） 245号日本晚樱：4月开花，教五周围，樱花大道和梅操之间情人坡，鲲鹏广场 信部星湖东侧： 山樱花：又称福岛樱或青肤樱，4月初开花，花期15-20天，位于校医院前、教四前、樱园入口路旁、樱园南坡绿地（下沉花园） 绿线学府路 樟树：行道树 金叶女贞：位于花坛 大叶黄杨：位于花坛 科技路 广玉兰：生科院到教四楼行道树 银杏：生科院到教四楼行道树 大叶黄杨 英国梧桐：教四到樱园路行道树 综述用途分类行道树 银杏 雪松 池衫 水杉 三角枫 枫树 梅树 桂树 女贞 樟树 广玉兰 英国梧桐 垂柳 石楠 樱树 园景树 樱树 圆柏 龙柏 重阳木 拐枣 榉树 榔榆 朴树 三角枫 雪松 杜英 水杉 乌桕 复羽叶栾树 梧桐 国槐 石楠 白玉兰 棕榈 黄连木 花灌类 红枫 紫薇 卫矛 紫叶桃 紫叶李 海桐 金丝桃 八角金盘 南天竹 竹叶椒 杜鹃 云南黄馨 月季 火棘 枸骨 绿篱类 马甲子 栀子 十大功劳 金心黄杨 雀舌黄杨 紫叶小檗 法国冬青 花坛花境类 月季 杜鹃 葱兰 一串红 一串蓝 火棘 重瓣棣棠 石蒜 大花马齿苋 夜来香 柳叶马鞭草 矮亚菊 山茶 夹竹桃 结香 木槿 中华绣线菊 凤尾鸡冠花 金盏菊 雏菊 金鸡菊 玉簪 萱草 美人蕉 锦带花 金钟花 观赏特性观形树 樟树 桂花 银杏 池衫 水杉 马尾松 雪松 侧柏 龙柏 广玉兰 英国梧桐 石楠 椤木石楠 红檵木 垂柳 朴树 大叶黄杨 三角枫 鸡爪槭 女贞 白花泡棢 榔榆 日本冷杉 黑松 金钱松 杉木 日本柳杉 落羽杉 日本花柏 罗汉松 鹅掌楸 粗榧 润楠 合欢 黄杨 雀舌黄杨 交让木 旱柳 胡桃 化香 卫矛 珊瑚朴 榆树 榉树 乌桕 重阳木 南酸枣 黄连木 盐肤木 中华槭 金钟花 白蜡树 十大功劳 紫薇 毛泡桐 七叶树 观花树春 含笑 白玉兰 桃 湖北海棠 李 梅 樱 麻叶绣线菊 中华绣线菊 重瓣棣棠 紫荆 瑞香 连翘 金钟花 探春花 云南黄馨 毛泡桐 白花泡桐 夏 广玉兰 金樱子 小果蔷薇 山合欢 合欢 绣球 山茱萸 荚蒾 红檵木 栾树 栀子 金丝桃 六月雪 春夏 紫藤 锦鸡儿 忍冬 锦带花 芜花 石楠 夏秋 白兰 糯米条 六道木 木槿 木芙蓉 多花勾儿茶 夹竹桃 牡荆 石榴 锦葵 秋 决明 冬春 腊梅 油茶 四季 月季 杜鹃 桂花 观叶树木春 山麻秆 石楠 秋 金钱松 落羽杉 水杉 池衫 银杏 鹅掌楸 榔榆 朴树 榆树 榉树 美国地锦 三角枫 鸡爪槭 中华槭 英国梧桐 重阳木 七叶树 四季 紫叶桃 紫叶李 特殊叶形 紫荆 八角枫 八角金盘 黄杨 雀舌黄杨 锦熟黄杨 旱柳 垂柳 海桐 爬山虎 美国地锦 大叶黄杨 夹竹桃 苏铁 杂集 秤锤树：位于未名湖畔东南角 大叶黄杨：位于梅园花坛 鹅掌楸：花期4-5月，枫园五舍、工学部网球场、珞珈广场 含笑：花期4-6月，位于标本馆前、校医院前花坛 红花酢浆草：校园花坛广布 红花石蒜：位于樱花大道至标本馆一带 海桐：花期4-5月，人文馆周边 合欢：珞珈山庄背面山坡、鲲鹏广场 花木兰：学校行道树 金丝桃：花期7-8月，梅园花坛 金银花：又名忍冬，花期4-6月，路旁、山坡灌丛、疏林中 鸡冠花：花期8-10月，花坛栽培 郁李：位于樱园 鸢尾：梅园花坛 棕榈：茶港教工生活区行道树 水杉：茶港教工生活区行道树 马尾松：南三区教工宿舍区 石榴：南三区教工宿舍区 女贞：狮子山、行政楼 枫树：枫园、奥场、珞珈广场 枫香树：枫园 桑树：信部、樱顶 樱花大道旁8棵银杏是20世纪30年代珞珈山建校初期栽植 罗汉松：育才路 绿樱：行政楼前 美人梅：梅园，梅和紫叶李杂交 阿拉伯婆婆纳： 柞树：武大附小花坛旁 南酸枣：武大梅园，名木]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】Python的switch-case实现]]></title>
    <url>%2Fpython-switch%2F</url>
    <content type="text"><![CDATA[前言在Python中，并没有实现switch-case语句，通过if-elif实现会显得麻烦，因此通过以下方式实现该语句功能。 实现方式通过字典实现以如下情景为例，将百分制分数转换为五分制分数。如100%转换为5，80%转换为4等。 def foo(score): return &#123; '100%':5, '80%':4, '60%':3, '40%':2, '20%':1, '0%':0 &#125;.get(score)print(foo('100%')) #输出5print(foo('80%')) #输出4 通过匿名函数实现def foo(score,x): return&#123; '100%':lambda x:x+5, '80%':lambda x:x+4, '60%':lambda x:x+3, '40%':lambda x:x+2, '20%':lambda x:x+1, '0%':lambda x:x+0, &#125;[score](x) print(foo('100%',0)) #输出5print(foo('80%',0)) #输出4]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下pip更换源地址]]></title>
    <url>%2Fwindows-pip%2F</url>
    <content type="text"><![CDATA[打开cmd，输入 echo %APPDATA% 进入到显示的路径中 进入该路径，新建pip文件夹，然后在该文件夹下新建pip.ini 编辑pip.ini，输入以下内容，即把源地址改为阿里云地址。 [global]timeout = 6000index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seaborn库的使用]]></title>
    <url>%2Fseaborn%2F</url>
    <content type="text"><![CDATA[CountPlot%matplotlib inlineimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as snstrain_data=pd.read_csv('./data/train.csv')sns.countplot(x='Score',data=train_data) sns.countplot(x=&#39;Score&#39;,data=train_data) 【注】 属性x为x轴名称，值必须为数据集中的列名。属性x或y中任一一组没有值，则默认count 属性data为数据集，值可以为pandas的dataframe类型。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汽车口碑分析】3.爬取汽车评论数据]]></title>
    <url>%2Fautomobile-analysis-3%2F</url>
    <content type="text"><![CDATA[环境配置 Ubuntu 16.04 Python 3.5 技术框架 Scrapy 需求目标本项目为汽车口碑分析，第一步需要爬取对于不同车型的评论数据。 选择58车的车型分类爬取评论数据。 爬取流程 先获取每个车型的链接，以下图中红框内的车型为例 打开链接后，抓取下图红框中的总评分，写入文件中。 写入总评分后，通过拼接链接进入该车型的用户评论页面。 通过第一步中获取的链接拼接上list_s1_p1.html，组成用户评论页面的链接。 【注】此为第一页的链接，若还有下一页，下述步骤会提及处理方法。 抓取评论页面中的各种数据，如id，评分，评论等。 若该评论页面还有下一页，则继续抓取下一页中的评论数据。 【方法】 判断页面中是否有下一页元素，若有则回调解析评论页面的方法。 将爬取的数据保存到文件中。 详细步骤创建新工程先创建工程目录 cd /home/t/dataset/mkdir carSpider 创建新工程 scrapy startproject carSpider 编辑items.py文件# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# http://doc.scrapy.org/en/latest/topics/items.htmlimport scrapyclass CarspiderItem(scrapy.Item): file=scrapy.Field() #文件名 car=scrapy.Field() #车型 score=scrapy.Field() #总评分 u_id=scrapy.Field() #用户ID u_score=scrapy.Field() #用户评分 u_merit=scrapy.Field() #用户评论优点 u_demerit=scrapy.Field() #用户评论缺点 u_summary=scrapy.Field() #用户评论综述 u_flower=scrapy.Field() #用户评论鲜花数 u_brick=scrapy.Field() #用户评论板砖数 编写carSpider.py文件import scrapyfrom carSpider.items import CarspiderItembaseDir = '/home/t/dataset/carRemark/'startUrl='http://www.58che.com/brand.html'class CarSpider(scrapy.Spider): name='spider' #爬虫名 def __init__(self): self.start_urls=[startUrl] #第一层解析方法 def parse(self,response): #定位到车型元素 subclasses=response.css('body &gt; div.fltop &gt; div.marcenter &gt; div &gt; div &gt; div.r &gt; ul &gt; li &gt; dl &gt; dt &gt; a') for subclass in subclasses: subclass_name=subclass.xpath('text()').extract_first() #获取车型名称文本 subclass_link=subclass.xpath('@href').extract_first() #获取车型链接 yield scrapy.Request(url=subclass_link,callback=self.parse_car_subclass,meta=&#123;'file':subclass_name&#125;) #回调下一层解析方法，并把车型名称传递给该方法作为文件名 #第二层解析方法 def parse_car_subclass(self,response): infos=response.css('#line1 &gt; div.cars_line2.l &gt; div.dianpings &gt; div.d_div1.clearfix &gt; font') #定位到总评分元素 for info in infos: score=info.xpath('text()').extract_first() #获取总评分元素文本 file=response.meta['file'] #获取上个Request传递来的meta['file'] self.writeScore(file,score) #将总评分写入文件中 link=response.url+'list_s1_p1.html' #拼接用户评论第一页链接 yield scrapy.Request(url=link,callback=self.parse_remark,meta=&#123;'file':file&#125;) #回调下一层解析方法，把车型名称传递给该方法作为文件名 #第三层解析方法 def parse_remark(self,response): #定位到用户评论元素 infos=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; dl') for info in infos: uid=info.xpath('dd[1]/strong/a/text()')[0].extract() #获取用户ID score=info.xpath('dd[1]/div/div/@style')[0].extract() #获取用户评分星级 score=self.getScore(score) #将用户评分星级转化为5分制评分 try: #先获取是否有‘优点’元素，若有则定位‘优点’元素的下一个兄弟节点，即‘优点评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l redc00")]')[0] if node is not None: merit=node.xpath('following-sibling::*[1]/text()')[0].extract() else: merit='' except: merit='' try: #先获取是否有‘缺点’元素，若有则定位‘缺点’元素的下一个兄弟节点，即‘缺点评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l hei666")]')[0] if node is not None: demerit=node.xpath('following-sibling::*[1]/text()')[0].extract() else: demerit='' except: demerit='' try: #先获取是否有‘综述’元素，若有则定位‘综述’元素的下一个兄弟节点，即‘综述评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l")]')[0] if node is not None: summary=node.xpath('following-sibling::*[1]/text()')[0].extract() else: summary='' except: summary='' flower=info.xpath('dd[2]/div[contains(@class,"apply")]/a[3]/span/text()')[0].extract() #获取鲜花数 brick=info.xpath('dd[2]/div[contains(@class,"apply")]/a[4]/span/text()')[0].extract() #获取板砖数 #创建Item item=CarspiderItem() item['file']=response.meta['file'] item['u_id']=uid item['u_score']=score item['u_merit']=merit item['u_demerit']=demerit item['u_summary']=summary item['u_flower']=flower item['u_brick']=brick #生成Item yield item #获取`下一页`元素，若有则回调`parse_remark`第三层解析方法，即继续获取下一页用户评论数据 #定位`下一页`元素 next_pages=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; div &gt; a.next') for next_page in next_pages: #若有`下一页`元素，则拼接`下一页`元素链接，并回调第三层解析方法，用来获取下一页用户评论数据 if next_page is not None: next_page_link=next_page.xpath('@href')[0].extract() next_page_link='http://www.58che.com'+next_page_link file=response.meta['file'] yield scrapy.Request(url=next_page_link, callback=self.parse_remark, meta=&#123;'file': file&#125;) #将总评分写入文件 def writeScore(self,file,score): with open('/home/t/dataset/carRemark/'+file+'.json','a+') as f: f.write(score+'\n') #将用户评分星级转为5分制分数，类似switch功能 def getScore(self,text): text=text.split(':')[1] #分割文本，原文本格式形如`width:100%`，分割并截取`:`后的文本 return &#123; '100%':5, '80%':4, '60%':3, '40%':2, '20%':1, '0%':0 &#125;.get(text) 【解析】 #定位到用户评论元素 infos=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; dl') 此句代码定位的元素如下图所示，定位到的是评论页面每条评论的元素整体。 for info in infos: uid=info.xpath('dd[1]/strong/a/text()')[0].extract() #获取用户ID score=info.xpath('dd[1]/div/div/@style')[0].extract() #获取用户评分星级 score=self.getScore(score) #将用户评分星级转化为5分制评分 uid定位到的元素如下图所示， score定位到的元素如下图所示，获取score元素的style属性，值形如width:80%，需要通过getScore()方法转换为五分制分数。 try: #先获取是否有‘优点’元素，若有则定位‘优点’元素的下一个兄弟节点，即‘优点评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l redc00")]')[0] if node is not None: merit=node.xpath('following-sibling::*[1]/text()')[0].extract() else: merit=''except: merit='' 先定位是否有优点元素，如下图红框所示，若有该元素，则获取优点元素的下一个兄弟节点内容，如下图蓝框所示，若无则为空。 #获取`下一页`元素，若有则回调`parse_remark`第三层解析方法，即继续获取下一页用户评论数据#定位`下一页`元素next_pages=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; div &gt; a.next') for next_page in next_pages: #若有`下一页`元素，则拼接`下一页`元素链接，并回调第三层解析方法，用来获取下一页用户评论数据 if next_page is not None: next_page_link=next_page.xpath('@href')[0].extract() next_page_link='http://www.58che.com'+next_page_link file=response.meta['file'] yield scrapy.Request(url=next_page_link, callback=self.parse_remark, meta=&#123;'file': file&#125;) 解析完上述内容，判断用户评论页面是否有分页，定位是否有下一页元素，如下图红框所示，若有则获取该元素链接，如下图橙框所示。 获取之后，回调parse_remark方法解析下一页的评论页面。 编辑pipelines.py文件# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: http://doc.scrapy.org/en/latest/topics/item-pipeline.htmlimport jsonimport codecsbaseDir = '/home/t/dataset/carRemark/'class CarspiderPipeline(object): def process_item(self, item, spider): print(item['file']) with codecs.open(baseDir+item['file']+'.json','a+',encoding='utf-8') as f: line=json.dumps(dict(item),ensure_ascii=False)+'\n' f.write(line) return item 编辑settings.py文件# -*- coding: utf-8 -*-# Scrapy settings for carSpider project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## http://doc.scrapy.org/en/latest/topics/settings.html# http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html# http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.htmlBOT_NAME = 'carSpider'SPIDER_MODULES = ['carSpider.spiders']NEWSPIDER_MODULE = 'carSpider.spiders'# Crawl responsibly by identifying yourself (and your website) on the user-agent#USER_AGENT = 'carSpider (+http://www.yourdomain.com)'# Obey robots.txt rulesROBOTSTXT_OBEY = False# Configure maximum concurrent requests performed by Scrapy (default: 16)#CONCURRENT_REQUESTS = 32# Configure a delay for requests for the same website (default: 0)# See http://scrapy.readthedocs.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docs#DOWNLOAD_DELAY = 3# The download delay setting will honor only one of:#CONCURRENT_REQUESTS_PER_DOMAIN = 16#CONCURRENT_REQUESTS_PER_IP = 16# Disable cookies (enabled by default)#COOKIES_ENABLED = False# Disable Telnet Console (enabled by default)#TELNETCONSOLE_ENABLED = False# Override the default request headers:#DEFAULT_REQUEST_HEADERS = &#123;# 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',# 'Accept-Language': 'en',#&#125;# Enable or disable spider middlewares# See http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.html#SPIDER_MIDDLEWARES = &#123;# 'carSpider.middlewares.CarspiderSpiderMiddleware': 543,#&#125;# Enable or disable downloader middlewares# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html#DOWNLOADER_MIDDLEWARES = &#123;# 'carSpider.middlewares.MyCustomDownloaderMiddleware': 543,#&#125;# Enable or disable extensions# See http://scrapy.readthedocs.org/en/latest/topics/extensions.html#EXTENSIONS = &#123;# 'scrapy.extensions.telnet.TelnetConsole': None,#&#125;# Configure item pipelines# See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; 'carSpider.pipelines.CarspiderPipeline': 300,&#125;# Enable and configure the AutoThrottle extension (disabled by default)# See http://doc.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True# The initial download delay#AUTOTHROTTLE_START_DELAY = 5# The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60# The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False# Enable and configure HTTP caching (disabled by default)# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settingsHTTPCACHE_ENABLED = False#HTTPCACHE_EXPIRATION_SECS = 0#HTTPCACHE_DIR = 'httpcache'#HTTPCACHE_IGNORE_HTTP_CODES = []#HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' 【解析】 ROBOTSTXT_OBEY = False 将原来的True改为False。 ITEM_PIPELINES = &#123; 'carSpider.pipelines.CarspiderPipeline': 300,&#125; 将原来的注释去掉，即注册pipelines，否则无法使用该pipelines。 运行爬虫在项目根目录下新建文件entrypoint.py from scrapy.cmdline import executeexecute(['scrapy','crawl','spider']) 项目源码Github地址]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>汽车口碑分析</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】四——Pycharm运行Python版Spark程序]]></title>
    <url>%2Fspark-pycharm%2F</url>
    <content type="text"><![CDATA[前言此前搭建成功分布式Spark环境，此文介绍使用Pycharm运行Python语言的Spark程序。 操作步骤安装Pycharm 点击下载。 过程与安装Intellij IDEA类似，在此不在赘述。 进入到安装目录下执行 ./bin pycharm-sh 配置运行环境 创建新项目 新建一个Python文件，这里命名为main.py from pyspark import SparkContext,SparkConfconf=SparkConf().setAppName("sparkDemo").setMaster("local")sc=SparkContext(conf=conf)logFile='/data/input/README.txt' logData=sc.textFile(logFile).cache()numAs = logData.filter(lambda s: 'a' in s).count()numBs = logData.filter(lambda s: 'b' in s).count()print("Lines with a: %i, lines with b: %i" % (numAs, numBs)) logFile=&#39;/data/input/README.txt&#39; 此路径是之前运行Hadoop例程在HDFS中创建的/data/input文件夹以及上传到此文件夹的README.txt文件。 将Spark中的pyspark模块添加到Python环境变量中去 sudo vim /etc/profile 添加以下代码 export PYTHONPATH=$SPARK_HOME/libexec/python:$SPARK_HOME/libexec/python/build:$PYTHONPATH 更新配置 source /etc/profile 将/usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip解压。 tar -zxvf /usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip 将解压后的文件夹复制到/usr/spark-2.2.1-bin-without-hadoop/Python文件夹下。 sudo mv /usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j /usr/spark-2.2.1-bin-without-hadoop/Python 【注】 /usr/spark-2.2.1-bin-without-hadoop是spark安装目录。 py4j-0.10-4-src.zip根据版本号不同，文件名称也有差异 点击Run-Edit Configurations 点击左上角绿色+，选择Python 填写配置 Name：任起一个名字即可 Script path：执行的Python文件的路径。可以点右侧的下图中红框选择文件路径。 Environment variables：添加PYTHONPATH和SPARK_HOME变量。 PYTHONPATH：spark安装目录/python SPARK_HOME：spark安装目录 点击File-Settings-Project-Project Structure 点击右侧Add Content Root 添加/usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip和/usr/spark-2.2.1-bin-without-hadoop/Python/lib/pyspark.zip 运行即可 【注】若from pyspark import SparkContext,SparkConf下还有红线，则添加以下代码即可 import syssys.path.insert(1,'/usr/spark-2.2.1-bin-without-hadoop/python')]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】三——基于VirtualBox的Spark完全分布式环境]]></title>
    <url>%2Fvirtualbox-spark%2F</url>
    <content type="text"><![CDATA[前言Spark的搭建依赖于Hadoop，因此本文基于之前分布式Hadoop环境，JDK、Hadoop等已安装好， 系统环境 虚拟机：VirtualBox Linux：Ubuntu 16.04 LTS HAdoop 2.7.5 IDE：Intellij IDEA JDK 1.8.0_151 Scala-2.12.4 Spark-2.2.1 操作步骤安装Scala 下载Scala-2.12.4 解压到当前目录 tar -zxvf scala-2.12.4.tgz 将解压后的文件夹移动到/usr下 sudo mv scala-2.12.4/ /usr/ 配置环境变量 sudo vim /etc/profile 添加如下代码，路径根据情况自己修改 export SCALA_HOME=/usr/scala-2.12.4export PATH=$SCALA_HOME/bin:$PATH 更新环境变量配置 source /etc/profile 验证是否安装成功 scala -version 安装Spark 下载Spark，由于Spark基于Hadoop，且之前已经安装好Hadoop，所以下载没有绑定Hadoop的版本，所以选择spark-2.2.1-bin-without-hadoop.tgz 解压到当前目录 tar -zxvf spark-2.2.1-bin-without-hadoop.tgz 将解压后的文件夹移动到/usr/local/ sudo mv spark-2.2.1-bin-without-hadoop/ /usr/ 配置环境变量 sudo vim /etc/profile 添加以下代码 export SPARK_HOME=/usr/spark-2.2.1-bin-without-hadoopexport PATH=$PATH:$SPARK_HOME/binexport PATH=$PATH:$SPARK_HOME/sbin 更新环境变量配置 source /etc/profile Spark配置【注】此处以master主机为例，其他从机作相应更改 配置spark-env.shcd /usr/spark-2.2.1-bin-without-hadoop/conf/sudo cp spark-env.sh.template spark-env.shsudo vim spark-env.sh 添加以下代码 export SPARK_HOME=/usr/spark-2.2.1-bin-without-hadoopexport SPARK_DIST_CLASSPATH=$(/usr/hadoop-2.7.5/bin/hadoop classpath)export JAVA_HOME=/usr/jdk1.8.0_151export SCALA_HOME=/usr/scala-2.12.4export HADOOP_HOME=/usr/hadoop-2.7.5export HADOOP_CONF_DIR=/usr/hadoop-2.7.5/etc/hadoopexport SPARK_MASTER_IP=masterexport SPARK_MASTER_HOST=masterexport SPARK_LOCAL_IP=masterexport SPARK_WORKER_MEMEORY=1gexport SPARK_EXECUTOR_MEMEORY=1gexport SPARK_DRIVER_MEMORY=1gexport SPARK_WORKER_CORES=1 【注】 SPARK_LOCAL_IP为本地地址，从机需要更改为自己的IP 配置slavessudo cp slaves.template slavessudo vim slaves 添加所有从机的主机名 node1node2 启动集群因为Spark基于Hadoop，所以需要先启动Hadoop。 start-all.sh 再启动Spark，进入到Spark安装目录下的sbin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/sbin 执行sbin文件夹下的start-all.sh，若直接执行start-all.sh，启动的是Hadoop ./start-all.sh 查看集群查看进程jps 主机上显示以下进程 从机显示以下进程 通过Web查看状态在主机master上打开浏览器，访问http://localhost:8080 运行pyspark进入到spark安装目录下的bin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/bin/ 运行pyspark ./pyspark 运行spark-shell进入到spark安装目录下的bin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/bin/ 运行spark-shell ./sparkshell 以上，证明spark配置成功。 关闭集群同样进入到Spark安装目录下的sbin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/sbin./stop-all.sh]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】二——基于Hadoop的MapReduce程序]]></title>
    <url>%2Fhadoop-wordcount%2F</url>
    <content type="text"><![CDATA[此前配置好分布式Hadoop环境，此篇主要讲解通过Intellij IDEA编写分布式MapReduce程序以及利用Hadoop实现词频统计 系统环境 虚拟机：VirtualBox Linux：Ubuntu 16.04 LTS Hadoop 2.7.5 IDE：Intellij IDEA JDK 1.8.0_151 安装Intellij及破解 安装Intellij IDEA 破解Intellij IDEA 创建Hadoop工程创建新工程 打开Intellij IDEA，创建一个新工程 选择Java项目，并添加JDK路径 添加依赖包点击File-Project Structure 打开后点击左侧Modules，然后点击Dependencies 点击右侧+，选择JARs or directories，将下图所有依赖包的目录导入 【注】/usr/hadoop-2.7.5是Hadoop安装目录 编写代码新建一个类名为WordCount，代码如下 import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import java.io.IOException;import java.util.Iterator;import java.util.StringTokenizer;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one); &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125; &#125; 配置编译环境点击Run-Edit Configuration 点击左上角+，然后点击Application Name，即该运行配置的名字，这里命名为RunHadoop Main Class，即需要运行的主类，这里使用的默认包，所以填写WordCount Program arguments，即运行时需要输入的参数，此处填写参数为hdfs://master:9000/data/input/README.txt hdfs://master:9000/output/ 此处，第一个参数为输入文件路径，第二个参数为输出文件路径。 master:9000为分布式Hadoop环境中core-site.xml配置文件中fs.default.name的值 /data/input/README.txt为分布式Hadoop环境中利用 hdfs dfs -mkdir -p /data/inputhdfs dfs -put README.txt /data/input 创建并上传到HDFS系统中的文件路径。 【注】若hdfs://master:9000/output已经存在，需要手动删除 hdfs dfs -rm -r /output 查看运行结果web界面查看通过http://localhost:50070查看各个结点运行状况]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>文本分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】一——基于VirtualBox的Hadoop完全分布式环境搭建]]></title>
    <url>%2Fvirtualbox-haddop%2F</url>
    <content type="text"><![CDATA[系统架构 虚拟机环境：VirtualBox Linux系统：Ubuntu 16.04 LTS 工具包 JDK1.8 Hadoop 2.7.5 拓扑结构：如下 操作步骤【注】本步骤以Master为例，其他虚拟机可以使用克隆功能复制，然后更改 安装常用软件安装vimsudo apt-get install vim 安装工具包设置共享文件夹 安装VirtualBox增强功能包,Ubuntu系统直接点击设备-&gt;安装增强功能 剩余步骤看教程 安装JDK 下载JDK-8u151 剩余步骤看教程 创建用户组创建用户组每个主机都需要加入到同一用户组。此处创建名为hadoop用户组 sudo addgroup hadoop 查看当前用户who 当前用户为t 添加当前用户到用户组sudo adduser t hadoop #sudo adduser user group 查看归属用户组groups t #group user 安装Hadoop下载Hadoop点击链接下载 解压Hadoop将文件复制到/Downloads/文件夹下进行解压 cd Downloads/tar -zxvf hadoop-2.7.5.tar.gz 将解压后的文件夹移动到/usr/文件夹 sudo mv hadoop-2.7.5/ /usr/ 配置文件需要配置的文件都在解压后的hadoop-2.7.5即usr/hadoop-2.7.5/文件夹中的/etc/hadoop/文件夹中 配置hadoop-env.shcd /usr/hadoop-2.7.5/etc/hadoop/sudo vim hadoop-env.sh 添加java安装路径 配置core-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/t/hadoop/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 【说明】 &lt;name&gt;fs.default.name&lt;/name&gt; 此参数设置NameNode的URI，此处设master主机为NameNode &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; 此参数设置Hadoop的一个临时目录，用来存放每次运行的作业jpb的信息。 此处设置/home/t/hadoop/tmp为临时目录，因没有此目录，因此需要先创建 sudo mkdir /home/t/hadoop/tmp 【附】 其他部分参数，如需要更多参数，请自查 参数 默认值 说明 fs.default.name file:/// NameNode的URI hadoop.tmp.dir 临时目录位置 hadoop.native.lib true 是否使用hadoop的本地库 hadoop.http.filter.initializers 空 设置Filter初始器 配置hdfs-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/home/t/hadoop/tmp/dfs/name&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/home/t/hadoop/tmp/dfs/data&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 【说明】 &lt;name&gt;dfs.name.dir&lt;/name&gt; dfs.name.dir存储永久性的元数据的目录列表。这个目录会创建在master主机上。 &lt;name&gt;dfs.data.dir&lt;/name&gt; dfs.data.dir存放数据块的目录列表，这个目录在node1和node2上创建 &lt;name&gt;dfs.replication&lt;/name&gt; dfs.replication设置文件副本数,此处有两个从机，设置副本数为2 配置mapred-site.xml先创建mapred-site.xml，进入到~/etc/hadoop/文件夹下 cp mapred-site.xml.template mapred-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置slaves把其他从机的主机名添加，有几个就添加几个，多添加会无法运行 配置环境变量sudo vim /etc/profile 将环境变量添加即可 export HADOOP_HOME=/usr/hadoop-2.7.5export PATH=$PATH:$HADOOP_HOME/sbinexport PATH=$PATH:$HADOOP_HOME/bin 更新生效 source /etc/profile 运行是否配置环境变量成功 hadoop version 【注】此步骤完成之后，可以克隆两个虚拟机分别命名为node1,node2 更改网络配置虚拟机设置【注】所有虚拟机都需要进行此步操作 点击控制-&gt;设置-&gt;网络，连接方式选择桥接网卡，然后重启虚拟机 修改Hostnamesudo vim /etc/hostname 【注】其他虚拟机修改其Hostname为相应的名称 以master为例，直接改为 修改hosts文件sudo vim /etc/hosts 增加以下内容，所有虚拟机都要增加以下内容 10.10.11.191 master10.10.11.192 node110.10.11.193 node2 其中127.0.0.1 oldhostname删掉 更改IP地址、网关【注】此处以master主机为例，其他主机根据上述拓扑图做相应更改 1.更改IP 利用ifconfig命令查看网卡名称，然后更改设置，本虚拟机网卡为enp0s3 sudo ifconfig enp0s3 10.10.11.191/24 【注】此种更改IP的方法，系统重启后需要重新配置 2.更改网关 sudo route add default gw 10.10.11.1 关闭防火墙sudo ufw disablesudo apt-get remove iptables 【注】此步骤后即可利用VirtualBox克隆功能复制出其他从机 连接测试使用ping命令测试是否能够连接 ping hostname 配置SSH安装sshsudo apt-get install ssh 查看已安装的sshdpkg --list|grep ssh 如果缺少openssh-server，需要安装 sudo apt-get install openssh-server 配置ssh下述步骤在不同的主机上进行，请注意区分 master机操作 生成master机的一对公钥和私钥 ssh-keygen -t rsa -P '' 进入.ssh目录查看公钥和私钥，id_rsa和id_rsa.pub cd .sshls 将公钥加入到已认证的key中 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 登录本机 ssh localhost 如果出现The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.，输入yes即可。 其他从机操作 将master主机上的id_rsa.pub复制到node1从机上。同理node2进行类似操作 scp ~/.ssh/id_rsa.pub t@node1:~/ 然后再在从机执行 cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 若遇到/home/t/.ssh/node1_rsa.pub: No such file or directory，则手动通过共享文件夹复制到其他从机相应位置。 若从机cd .ssh遇到No such file or directory，则手工创建.ssh文件夹。 在/home/t图形化界面按Ctrl+H显示隐藏文件夹， 若已经存在.ssh文件夹，则删除suso rm -r /home/t/.ssh。这里的/home/t是用户目录，t是用户名，其他用户名则需要做相应更改。 若没有.ssh文件夹，则创建sudo mkdir /home/t/.ssh 更改权限sudo chmod a+w /home/t/.ssh 通过共享文件夹把master中的id_rsa.pub复制到/home/t/中 将master主机上的密钥加入到认证中 cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 在master主机上验证能否正常登陆 ssh node1 出现以下则表示登陆成功 启动集群格式化namenode在主机master运行 hadoop namenode -format 若出现has been successfully formatted和Exiting with status 0表示格式化成功 若出现hadoop:Cannot create directory /home/t/hadoop/name/current错误即文件夹权限不足 sudo chmod -R a+w /home/t/hadoop/name/current 启动集群start-all.sh 启动完毕后，执行命令 jps 若master主机看到四个开启的进程代表启动成功 若从机上看到启动进程 【问题解释】为什么没有jobtracker和tasktracker 停止集群stop-all.sh 查看运行状态查看Namenode状况通过Web界面查看NameNode运行状况，默认为http://localhost:50070 查看ResourceManager状况http://localhost:8088 运行测试程序向hadoop集群系统提交第一个mapreduce任务，统计词频 进入本地hadoop目录.此处是/usr/hadoop-2.7.5 cd /usr/hadoop-2.7.5 在虚拟分布式文件系统上创建一个目录/data/input hdfs dfs -mkdir -p /data/input 将当前目录下的README.txt复制到虚拟分布式文件系统中 hdfs dfs -put README.txt /data/input 查看虚拟分布式文件系统中是否有复制上去的文件 hdfs dfs -ls /data/input 向Hadoop提交单词统计任务 hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.5.jar wordcount /data/input /data/output/result 查看结果 hdfs dfs -cat /data/output/result/part-r-00000]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题之NextD]]></title>
    <url>%2Fhexo-next%2F</url>
    <content type="text"><![CDATA[简介本次更改的主题为NextD，一款基于NexT而修改的主题。 ##集成Gitment评论系统 点击https://github.com/settings/applications/new注册 填写内容 Application name 随便填写 Homepage URL 填写你的个人博客域名如https://tianwenyu.github.io。 【注】前面的https://也要完整填写 Application description 随便填写 Authorization callback URL 同Homepage URL 在github的个人主页的issue页面可以看到网站评论 ##开启本地搜索功能 安装Local Search 安装hexo-generator-searchdb，在站点根目录下执行以下命令 npm install hexo-generator-searchdb --save 开启CNZZ统计功能 打开网址，注册个人帐号 登陆后，点击个人中心 点击U-Web,之后点击立即使用 添加站点 填写网站域名即可 将网站id填写到./themes/nextd/_config.yml中的cnzz_siteid。]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows中CMD命令之Tree生成目录]]></title>
    <url>%2Fcmd-tree%2F</url>
    <content type="text"><![CDATA[作用以图形显示驱动器或路径的文件夹结构 格式tree [path] [/f] [/a]#/f 显示每个文件中文件的名称#/a 使用ASCII字符，而不使用扩展字符 样例tree C:\Users\Administrator\.android /f &gt;F:\path\android-tree.txt]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java多态性]]></title>
    <url>%2Fjava-polymorphism%2F</url>
    <content type="text"><![CDATA[实例分析class A&#123; public String show(D obj)&#123; return ("A and D"); &#125; public String show(A obj)&#123; return ("A and A"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; return ("B and B"); &#125; public String show(A obj)&#123; return ("B and A"); &#125;&#125;public class C extends B&#123; &#125;public class D extends B&#123; &#125;public class Test&#123; public static void main(String[] args)&#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125; 运行结果： 解析①②③比较好理解，一般不会出错。④⑤就有点糊涂了，为什么输出的不是”B and B”呢？ 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。） 在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 上面程序中的A,B,C,D存在如下关系： 分析4： ​ a2.show(b)，a2是一个引用变量，类型为A，则this为a2，b是B的一个实例，于是它到类A里面找show(B obj)方法，没有找到，于是到A的super(超类)找，而A没有超类，因此转到第三优先级this.show((super)O)，this仍然是a2，这里O为B，(super)O即(super)B即A，因此它到类A里面找show(A obj)的方法，类A有这个方法，但是由于a2引用的是类B的一个对象，B覆盖了A的show(A obj)方法，因此最终锁定到类B的show(A obj)，输出为”B and A”。 分析5： ​ a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。 分析8： ​ b.show(c)，b是一个引用变量，类型为B，则this为b，c是C的一个实例，于是它到类B找show(C obj)方法，没有找到，转而到B的超类A里面找，A里面也没有，因此也转到第三优先级this.show((super)O)，this为b，O为C，(super)O即(super)C即B，因此它到B里面找show(B obj)方法，找到了，由于b引用的是类B的一个对象，因此直接锁定到类B的show(B obj)，输出为”B and B”。 ​ 按照同样的方法我也可以确认其他的答案。 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)； ​ 这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“ 被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话： 它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Github Pages+Hexo搭建个人博客]]></title>
    <url>%2Fgitpage-hexo%2F</url>
    <content type="text"><![CDATA[技术简介Github PagesGitHub Pages 本来用于介绍托管在Github上的项目，由于它的空间免费稳定，因此适合用来搭建博客。 每个帐号只能有一个仓库来存放个人主页，且仓库的名字必须是username/username.github.io。你可以通过http://username.github.io来访问你的个人主页 个人主页的网站内容是在master分支下 HexoHexo是一个快速、简洁高效的博客框架，具有如下特点： 生成静态网页 支持Markdown 一键部署博客到Github Pages 丰富插件 七牛云使用七牛云作为图床。 认证后的七牛云存储提供10G的免费空间以及每月10G的流量 MPic用于方便上传图片到七牛云的一款工具 点击下载 配置环境Git安装Git进入网站https://git-scm.com/下载安装即可 Node.JS安装Node.JS进入网站https://nodejs.org/en/，下载安装即可 Hexo安装Hexo在任意位置右键点击Git Bash Here 使用npm安装hexo，可以先切换npm源，加速安装过程 npm config set registry https://registry.npm.taobao.orgnpm install -g hexo 【注】若安装不成功，可以使用npm install hexo --save再次安装 出现以下图示表示安装完成。 【注】若提示This package is no longer maintained，耐心等待安装即可。 配置Hexo创建hexo文件夹在某一文件夹下如F:\hexo\blog，右键Git Bash Here，使用以下命令创建建立网站需要的文件 hexo init 安装依赖包npm install 生成静态文件hexo generate #生成静态文件，会在当前目录下生成一个新的名为public的文件夹 启动Hexohexo server -p 5000 #使用hexo server 默认端口4000，会无法访问localhost:4000，因此改为5000端口 常用hexo命令hexo help #查看帮助hexo -v #查看本地环境hexo init #初始化一个目录hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo gernerate #生成网页，可以在public目录查看整个网站的文件hexo server #本地预览 Ctrl+C关闭hexo deploy #或hexo d 部署到远端如github、herokuhexo clean #清除缓存 建议每次执行命令前先清理缓存，每次部署前先删除 .deploy文件夹 #常用缩写hexo n #hexo newhexo g #hexo generatehexo s #hexo serverhexo d #hexo deploy #常用组合hexo d -g #生成部署hexo s -g #生成预览 操作流程Github Pages创建页面仓库创建一个仓库，需要和帐号对应，格式yourname.github.io，创建仓库 生成SSH密钥任意地方右键Git Bash Here,执行以下命令 ssh-keygen -t rsa -C "你的邮箱地址" 出现Enter file in which to save the key (.....)直接回车选择默认位置 出现Enter passphrase(empty for no passphrase)直接两次回车不设密码以及确认 在Github上添加SSH密钥打开id_rsa.pub，复制内容。 进入https://github.com/settings/ssh。 点击New SSH key 填写后点击Add SSH key Hexo目录结构 deploy #需要部署的文件 node_modules #Hexo插件 public #生成的静态网页文件 scaffolds #模板 source #博客正文和其他源文件 drafs #草稿 posts#文章 themes #主题 config.yml #配置文件 部署原理 上述步骤中在Github上创建的那个仓库username.github.io，可以通过该链接访问 Hexo -g 会生成一个静态网站，第一次会生成一个public目录，这个静态文件可以直接访问 需要将Hexo生成的静态网站，提交(git commit)到github上 过程需要在_config.yml中修改 deploy: type: git repository: http://github.com/tianwenyu/tianwenyu.github.io.git branch: master 【注】 repository:后面的tianwenyu/tainwenyu.github.io.git要与自己创建的仓库名保持一致 .yml文件对格式要求严格，type: repository: branch: 前面两个空格，冒号后面一个空格 安装依赖包 npm install hexo-deployer-git --save 配置好之后执行 hexo geneartehexo deploy 【注】以上命令执行的环境必须在执行hexo init创建的文件夹下执行 执行完以上命令，会出现页面输入你的github用户名和密码，验证后就可以上传成功 访问tianwenyu.github.io，成功打开页面即部署成功。 配置选择的主题为indigo，具体问题可以看链接。 安装主题安装前确认你的Hexo版本在3.0以上，以及Node版本为6.x以上，在Hexo根目录，执行以下命令 git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 安装依赖 安装Less npm install hexo-renderer-less --save 安装Feed npm install hexo-generator-feed --save 安装Json-content npm install hexo-generator-json-content --save 安装QRCode npm install hexo-helper-qrcode --save 启用主题编辑站点配置文件hexo/_config.yml 搜索theme，修改为theme: indigo 基本配置修改以下内容 title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url indigo主题配置编辑主题配置文件hexo/themes/_config.yml 详情见indigo主题配置 新建文章hexo new &quot;postname&quot; 该命令会自动在hexo/source/_post文件夹下创建一个名为postname的markdown文件，会自动在文件开头添加 ---title: 你的题目tags: 你的标签category: 你的分类--- 填写tags,category，新建标签页面和分类页面后即可以显示相应的标签和分类 新建标签页面hexo new page tags 该命令会自动在hexo/source文件夹下创建tags文件夹并在该文件夹下创建index.md文件。 修改index.md文件，添加以下两项 layout: tagscomments: false 新建分类页面hexo new page categories 该命令会自动在hexo/source文件夹下创建categories文件夹并在该文件夹下创建index.md文件 修改index.md文件，添加以下两项： layout: categoriescomments: false Mpic 点击设置账号 将七牛云对应信息填入 空间名称：七牛存储文件的空间名，这里选择tpic SecretKey&amp;AccessKey：点击个人面板-密钥管理 域名：点击对象存储，在空间概览页面 ​]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之Indigo主题配置]]></title>
    <url>%2Fhexo-indigo%2F</url>
    <content type="text"><![CDATA[正文宽度加宽/themes/indigo/source/css/_partial/variable.less 把@contentWidth: 960px改成@contentWidth: 90% 同时config文件中修改cdn:false Header高度调整 themes/indigo/source/css/_partial/header.less` 修改content-header下的 .content-header &#123; //min-height: 210px; margin-left: -240px; //padding: 104px 16px 48px 256px; padding: 50px 16px 5px 256px; color: @textPrimaryColor; background: @primaryColor; text-shadow: 0 1px 1px rgba(0, 0, 0, .2); 把min-height注释掉 修改padding:50px 16px 5px 256px; 根据https://github.com/OhYee/hexo-theme-indigo/tree/OhYee更改 同时调整themes/indigo/source/css/_partial/article.less .post-card &#123; //margin-top: -150px; margin-top: 0px; min-height: 100px; padding: 35px; background: #fff; border-radius: 4px; box-shadow: 0 10px 30px rgba(0, 0, 0, .2); .post-meta &#123; margin-top: 8px; &#125;&#125; 修改margin-top: 0px 更改主题若是想要更改其他版本主题，如本主题其他人修改的主题，可以直接放到/themes文件夹下，重命名。再在./config.yml里更改主题。]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【评论文本分类】1.爬取评论数据]]></title>
    <url>%2Ftext-classification%2F</url>
    <content type="text"><![CDATA[环境配置 Ubuntu 16.04 Python 3.5 技术框架 Scrapy Selenium PhantomJS 需求目标对网址http://liuyan.cjn.cn/index.html进行数据爬取 本文爬虫有三层爬取，爬取结构层次如图所示， 主页面 列表页面，需要利用selenium+phantomJS模拟点击加载更多按钮 详情页面 把主页面中的红框中的各区（功能区）、政府部门、法检及其他单位等作为一级类保存，然后依次爬取一级类中各个分类 进入到列表页面，因为此页面是动态加载，并且是简介列表，因此需要加载完所有列表进入到详情页面。 进入到详情页面，爬取相应内容。 设计方案动态爬取数据一般有两种方法 分析包，构造Request 通过模拟浏览器行为加载页面 通过尝试，第一种方法对于此网站不适合，采用第二种方法。 采用Scrapy+Selenium+PhantomJS来进行动态网页的爬取。 SeleniumSelenium是一个自动化测试工具，本文用到的是其Webdriver，用其来操作浏览器，可以操作多种主流浏览器，如Chrome，Firefox等，下文中的PhantomJS是一种无界面的浏览器。 PhantomJSPhantomJS是一个无界面浏览器，提供JavaScript接口。通过这个工具，可以进行页面的加载、解析、操作等。 爬取方案 先爬取主页面各个主类（如各区（功能区）、政府部门等）下的子类链接，如（江岸区、江夏区等） 按照先前爬取的子类链接依次打开跳转到列表界面，然后利用Selenium+PhantomJS模拟浏览器动态加载完全部列表，解析出所有列表的链接，跳转到详情页面 进入到详情页面，解析所要提取的内容 详细步骤安装Scrapysudo pip3 install scrapy 安装PhantomJS 安装PhantomJS sudo apt-get install phantomjs apt-get会安装不完整，需要安装以下 sudo apt-get install nodejssudo apt-get install nodejs-legacysudo apt-get install npmsudo npm -g install phantomjs-prebuilt 安装Seleniumsudo pip3 install selenium 使用Scrapy 创建新工程 scrapy startproject xxxx 编辑items.py文件 from scrapy import Itemfrom scrapy import Field class MessageboardspiderItem(Item): # define the fields for your item here like: dir_name=Field() url=Field() title=Field() domain=Field() type=Field() content=Field()​ 3. 编写Spider 流程： - 先通过scrapy爬取`主页面`上的所有子分类链接， - 然后依次利用`PhantomJS`模拟点击`列表页面`的`加载更多`按钮，动态加载所有列表项，然后保存网页源码，抽取出其中的列表项的链接，进入`详情页面` 此两过程的代码都在`parse(self,response)`方法中 - 通过`parse_detailed_remark(self,response)`方法，解析出需要的内容 【注】目前版本爬取`主页面`上不同的主类需要手动改动`baseDir`与`self.start_urls` ```python import os import stat import scrapy import time from selenium import webdriver from scrapy.selector import Selector from scrapy.http import HtmlResponse from messageBoardSpider.items import MessageboardspiderItem baseDir = '/home/t/dataset/msgBoard/department/' #爬取不同主分类，需要手动改动 baseUrl='http://liuyan.cjn.cn' global subclass_name global brower class DistrictSpider(scrapy.Spider): name='spider' def __init__(self): global brower self.start_urls=['http://liuyan.cjn.cn/forum/list?fid=4'] #爬取不同主分类，需要手动改动 brower=webdriver.PhantomJS() #创建PhantomJS浏览器 def parse(self,response): global brower global subclass_name subclasses=response.xpath('/html/body/div[7]/ul/li/b/a') #解析出所有子分类 for subclass in subclasses: #逐条解析子分类 subclass_name=subclass.xpath('text()').extract() #解析 #make district directory self.mkdirs(baseDir+subclass_name[0]) #extrat new link link=subclass.xpath('@href').extract() #解析出子类的链接 #joint link link=str(baseUrl+link[0].split('..')[1]) #拼接链接 brower.get(link) #利用PhantomJS打开链接 #进行动态解析，直到没有'加载更多'按钮之后停止 while True: try: more=brower.find_element_by_id('show_more') #找到'加载更多'按钮 time.sleep(0.5) more.click() time.sleep(0.5) except: with open(baseDir+subclass_name[0]+'/web_page.txt','w',encoding='utf-8') as f: f.write(brower.page_source) print('ending') break #对加载完后的源码进行解析，解析出列表标题 items=brower.find_elements_by_xpath('//*[@id="list_content"]/li/h2/b/a') for item in items: #解析出列表标题链接 title_link=item.get_attribute('href') print(title_link+'.........') yield scrapy.Request(url=title_link,callback=self.parse_detailed_remark) #解析详情页面 def parse_detailed_remark(self,response): global subclass_name item=MessageboardspiderItem() item['dir_name']=subclass_name[0] item['url']=response.url item['title']=response.xpath('/html/body/div[6]/h2/b/text()').extract() item['domain']=response.xpath('/html/body/div[6]/h3/em[1]/a/text()').extract() item['type']=response.xpath('/html/body/div[6]/h3/em[2]/a/text()').extract() item['content']=response.xpath('//*[@id="zoom"]/text()').extract() yield item def mkdirs(self,path): if not os.path.exists(path): os.makedirs(path) os.chmod(path,stat.S_IRWXU|stat.S_IRWXG|stat.S_IRWXO) 编辑pipelines.py文件 import jsonimport codecsbaseDir = '/home/t/dataset/msgBoard/department/'class DistrictPipeline(object): def process_item(self, item, spider): with codecs.open(baseDir+item['dir_name']+'/data.json','a+',encoding='utf-8') as f: self.file=f line=json.dumps(dict(item),ensure_ascii=False)+'\n' self.file.write(line) return item 编辑settings.py文件 编辑pipelines的设置，把如下内容的注释去掉即可 #ITEM_PIPELINES = &#123;# 'messageBoardSpider.pipelines.DistrictPipeline': 300,#&#125; 运行爬虫 在项目根目录下新建一个main.py文件，运行爬虫执行该文件即可。 from scrapy.cmdline import executeexecute(['scrapy','crawl','spider']) 【注】execute([&#39;scrapy&#39;,&#39;crawl&#39;,&#39;spider&#39;]) 其中spider是爬虫名，按需更改即可。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualbox 下LVS-NAT模式集群部署]]></title>
    <url>%2Flinux-lvs%2F</url>
    <content type="text"><![CDATA[系统架构 虚拟机环境：VirtualBox Linux系统：CentOS 7 模型：LVS-NAT 调度算法：RR 【注】所有连接方式都采用桥接方式 主机 IP 角色 Client 192.168.33.145 客户机，用来访问网页 VS 192.168.33.150 VIP，Virtual Ip对外提供的IP VS 192.168.33.149 DIP，Director IP RS1 192.168.33.148 Real Server IP，安装Nginx RS2 192.168.33.147 Real Server IP，安装Nginx 客户机配置桥接IP设置 打开网络与共享中心 点击更改适配器设置 选择客户机（即物理机）网卡 4.打开属性，设置IPV4地址 虚拟机环境配置1.网卡模式设置【注】所有Virtual Box虚拟机网络设置都要设置为桥接方式 打开控制-&gt;设置-&gt;网络 连接方式选择桥接网卡，高级-&gt;混杂模式选全部允许 2.sudo命令配置【注】以一台虚拟机为例，其余虚拟机与此类似 切换到root用户 su -1 添加/etc/sudoers文件写权限 chmod u+w /etc/sudoers1 编辑/etc/sudoers vim /etc/sudoers1 找到root ALL=(ALL) ALL在下面添加21751096_1 ALL=(ALL) ALL，并保存退出 4.撤销/etc/sudoers文件的写权限 bash chmod u-w /etc/sudoers Director配置1.安装ipvsadmsudo yum install -y ipvsadm1 2.建立一个虚拟IP地址进行广播sudo ifconfig enp0s3:0 192.168.33.150/24 3.将该虚拟机地址添加到路由表sudo route add -host 192.168.33.150 dev enp0s31 4.使用ipvsadm安装LVS服务sudo ipvsadm -At 192.168.33.150:80 -s rr1 5.增加真实服务器sudo ipvsadm -at 192.168.33.150:80 -r 192.168.33.148 -gsudo ipvsadm -at 192.168.33.150:80 -r 192.168.33.147 -g12 6.设置DirectorIPsudo ifconfig enp0s3 192.168.33.149/241 7.查看ifconfig设置sudo ifconfig1 所有设置如图 Real Server配置1.安装nginx服务【注】需要在21751096_2和21751096_3两台RealServer上安装nginx服务，以其中一台为例 使用yum安装nginx,需要安装nginx的库 cd /etc/yum.repos.d/nginx.reposudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm12 编辑nginx.repo文件 sudo vim /etc/yum.repos.d/nginx.reponame=nginx repobaseurl=http://nginx.org/packages/centos/7/x86_64/gpgcheck=0enabled=1123456 使用yum安装nginx sudo yum install nginx1 安装完成后启动nginx服务 sudo service nginx start1 修改index.html首页区分两个nginx服务器 sudo vim /usr/share/nginx/html/index.html1 修改内容如下 查看是否启动服务 curl -i localhost1 2.IP设置 切换到root账户 su -1 设置虚拟IP ifconfig lo:0 192.168.33.150/361 添加到路由表 route add -host 192.168.33.150 dev lo:01 设置IPV4转发 bash echo &quot;1&quot; &gt;/proc/sys/net/ipv4/ip_forward 设置RS1的IP ifconfig enp0s3 192.168.33.148/241 查看ifconfig设置 ifconfig1 全部设置如图所示 运行测试在浏览器中输入192.168.33.150 第一次显示Real Sever 1的页面 刷新后显示Real Server 2的页面]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 yum安装nginx-1.12.0]]></title>
    <url>%2Fcentos-nginx%2F</url>
    <content type="text"><![CDATA[CentOS 7 中的 yum 没法直接使用 yum install nginx 这个指令去安装nginx，因为nginx这个服务不是yum库中自带的。图1是官方提供的大致安装步骤，图2是官网提供的多个版本的nginx安装包，下面是我给合自己的系统环境总结的安装方法，供大家参考： 在/etc/yum.repos.d/文件夹下执行 sudo rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm 按图1中的要求vi nginx.repo这个文件，将图中[nginx]字段中的内容复制进去，保存退出！ [root@lnboxue ~]# vi /etc/yum.repos.d/nginx.repo[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/x86_64/gpgcheck=0enabled=1 这里需要注意的是：要将$releasever替换为7，将$basearch替换成x86_64。可以通过下面这条指令获取你自己系统的$releasever和$basearch。 [root@lnboxue ~]# rpm -qa | grep centos-releasecentos-release-7-3.1611.el7.centos.x86_64 yum安装nginx，参见图3和图4。 [root@lnboxue ~]# yum install nginx 可以使用两种方法启动nginx服务 [root@lnboxue ~]# service nginx start 或 [root@lnboxue ~]# systemctl start nginx 查看nginx服务是否已经启动 [root@lnboxue ~]# netstat -ntl 查看nginx版本 [root@lnboxue ~]# nginx -vnginx version: nginx/1.12.0 本地测试nginx服务 [root@lnboxue ~]# curl -i localhostHTTP/1.1 200 OKServer: nginx/1.12.0Date: Tue, 04 Jul 2017 05:27:07 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Wed, 12 Apr 2017 15:23:46 GMT……………………&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer tonginx.org.&lt;br/&gt;Commercial support is available atnginx.com.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 看到以上信息，说明你的nginx服务已安装成功！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 添加新用户并授权Root权限]]></title>
    <url>%2Fcentos-root%2F</url>
    <content type="text"><![CDATA[切换到root用户su - 添加新用户useradd xxx 查看是否在/home下创建用户ls /home 删除用户userdel -rf xxx 为新创建的用户添加密码passwd xxx【注】xxx为用户名 查看新建用户信息tail -3 /etc/passwd 切换用户su - xxx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习评估方法——P值校验]]></title>
    <url>%2Fml-pvalue%2F</url>
    <content type="text"><![CDATA[目标假设在α=0.05的情况下，根据舆情监测项目需求，查看召回率和准确率的置信区间，均值。 过程1.输入数据，三列分别是precision,recall,f1-score，每一列分别计算，以此为例，一共四十行。即样本容量为402.计算标准差STDEV(A2:A41)计算出的标准差放在A43单元格3.计算置信区间3.1公式-&gt;插入函数-&gt;CONFIDENCE.NORMALCONFIDENCE.NORMAL(0.05,A43,40)【解释】 Alpha=0.05即说明置信区间的显著性水平，置信水平是指总体参数值落在样本统计值某一区内的概率，一般用1-α表示，即在这个区间内的可能性为1-0.05=0.95，即有95％的可能认为落在这个区间。 Standard_dev=A43即上一步骤算出的标准差,上一步的标准差存储在A43单元格 Size=40即样本容量为40 4.计算平均值AVERAGE(A2:A41)5.理论解释6.操作动态图]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汽车口碑分析】2.Ubuntu 16.04下MongoDB安装、设置与使用]]></title>
    <url>%2Fautomobile-analysis-2%2F</url>
    <content type="text"><![CDATA[安装MongoDB sudo apt-get install mongo 通过pgrep mongo -l查看进程是否已经启动 运行mongo进入数据库 MongoDB设置 关闭/启动服务 sudo servie mongodb stop #停止服务sudo service mongodb start #启动服务sudo service mongodb restart #重启服务sudo service mongod status #查看状态1234 允许开机启动，默认当重启服务器后，mongodb服务会停止，需要设置开机启动mongodb服务。 sudo systemctl enable mongodb 使用MongoDB 默认mongodb只能在本机连接，在服务器外部是不能链接mongodb的。需要修改配置文件sudo vim /etc/mongodb.conf修改完成后，保存文件，重启mongosudo service mongodb restart]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>汽车口碑分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汽车口碑分析】1.Ubuntu 16.04 LTS下安装Scrapy]]></title>
    <url>%2Fautomobile-analysis-1%2F</url>
    <content type="text"><![CDATA[安装pip3sudo apt-get install python3-pip 安装Scrapy依赖库 sudo apt-get install python-devsudo apt-get install libevent-devsudo apt-get install libssl-dev123 安装Scrapy sudo pip3 install scarpy]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>汽车口碑分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】判断字符串是否为空]]></title>
    <url>%2Fpython-string-null%2F</url>
    <content type="text"><![CDATA[str=''if str.strip()=='': print('str is null')if not str.strip(): print('str is null')str='hello'if str.strip(): print('str is not null')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】set与list]]></title>
    <url>%2Fpython-set-list%2F</url>
    <content type="text"><![CDATA[利用set去除list重复元素set是一个无序不重复元素集，基本功能包括关系测试和消除重复元素。若需要消除重复元素，如下 a=[5,2,5,1,4,3,3]a=list(set(a))12 提取两个list中出现过的非重复元素line1=['a','b','a']line2=['a','c']line=line1+line2line=list(set(line))1234 两个set的并集set1=set(['a','b'])set2=set(['a','c'])set(list(set1)+list(set2))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij Idea 码云教程]]></title>
    <url>%2Fintellij-mayun%2F</url>
    <content type="text"><![CDATA[1.点击导航栏 VCS -&gt; Import into Version Control -&gt; 托管项目到码云 2.输入码云帐号密码，点击login。 3.勾选private，点击托管按钮。 4.点击OK。 5.在项目上右键 -&gt;Git -&gt;Commit Directory 6.填写Commit Message（养成良好编码习惯），点击Commit按钮 如果没有定义Git的用户名，点击Commit会弹出此弹窗，输入 name和email 点击 Set and Commit即可。 8.项目右键 -&gt; Git -&gt; Repository -&gt; Push 9.点击Push。 10.登录码云查看。到此，项目上传码云成功！~ 注意：（private勾选后项目并未成为私有项目，需要到码云网页上进行私有设置）]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
        <tag>码云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Git 2.15.0安装、配置]]></title>
    <url>%2Fwindows-git%2F</url>
    <content type="text"><![CDATA[安装下载链接:http://git-scm.com/download 安装 配置 用户名和邮箱地址的作用：用户名和邮箱地址是本地Git客户端的一个变量，不随Git库而改变。每次Commit都会用用户名和邮箱地址记录。 git config --global user.name "xxxx"git config --global user.email "xxxx"]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij idea使用教程]]></title>
    <url>%2Fintellij-tutorial%2F</url>
    <content type="text"><![CDATA[快捷键设置 如 Gif 所示，在没有对 Ctrl + D 快捷键进行修改前，此快捷键将是用来复制并黏贴所选的内容的，但是黏贴的位置是补充在原来的位置后，我个人不喜欢这种风格，我喜欢复制所选的行数完整内容，所以进行了修改，修改后的效果如上图 Gif 演示。 如Gif 所示，默认 Ctrl + 空格 快捷键是基础代码提示、补充快捷键，但是由于我们中文系统基本这个快捷键都被输入法占用了，所以我们发现不管怎么按都是没有提示代码效果的，原因就是在此。我个人建议修改此快捷键为 Ctrl + 逗号。 Ctrl 快捷键 介绍 Ctrl+, 代码补全，自定义 Ctrl+F 当前文件文本查找 Ctrl+R 当前文件文本替换 Ctrl+Y 删除光标所在行或选中行 Ctrl+D 复制光标所在行 Ctrl+U 前往光标所在方法的父类方法或接口 Ctrl+E 显示最近打开的文件记录列表 Ctrl+J 插入自定义动态代码模板 Ctrl+P 方法参数提示 Ctrl+W 递进式选择代码块。 Ctrl+Q 光标所在的变量、类名、方法名上显示文档内容 Ctrl+N 根据输入的类名查找类文件 Alt 快捷键 介绍 Alt+Enter 快速修复 Alt+Insert 代码自动生成，如set/get方法，构造函数 Alt+前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt+后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt+1 显示/隐藏 导航栏 Shift 快捷键 介绍 Shift+F6 重命名文件/文件夹 Shift+Tab 取消缩进 Shift+End 使光标到当前行尾位置 Shift+Home 使光标到当前行首位置 Shift+滚轮滚动 当前文件的横向滚动 Shift+Enter 开始新的一行 Ctrl+Alt 快捷键 介绍 Ctrl+Alt+L 格式化代码，可以对当前文件和整个包目录使用 Ctrl+Alt+O 优化导入的类 Ctrl+Alt+I 光标所在行代码缩进 Ctrl+Alt+S 打开系统设置 Ctrl+Shift 快捷键 介绍 Ctrl+Shift+F 查找整个项目 Ctril+Shift+R 在整个项目范围内替换 Ctrl+Shift+J 自动将下一行合并到当前行末尾 Ctrl+Shift+Z 取消撤销 Ctrl+Shift+W 递进式取消选择代码快 Ctrl+Shift+T 对当前类生成单元测试类 Ctrl+Shift+C 复制当前文件磁盘路径到剪切板 Ctrl+Shift+B 跳转到类型声明处 Ctrl+Shift+/ 代码块注释 Ctrl+Shift+Space 智能代码提示 Ctrl+Shift+Enter 自动结束代码，行末自动添加分号` Ctrl+Shift+Backspace 退回到上次修改的地方 Ctrl+Shift+Alt 快捷键 介绍 Ctrl+Shift+Alt+S 打开当前项目设置 其他 快捷键 介绍 F2 跳转到下一个高亮错误或警告位置 F4 编辑源 Shift连按两次 弹出Search Everywhere 常用设置 如Gif 所示，我们可以勾选此设置后，增加 Ctrl + 鼠标滚轮 快捷键来控制代码字体大小显示。Editor-&gt;General-&gt;Change font size(Zoom) with Ctrl+Mouse Wheel 可以勾选此设置后，增加 Ctrl + 鼠标滚轮 快捷键来控制图片的大小显示。Editor-&gt;Images-&gt;Zoom image with mouse wheel(Ctrl+Mouse Wheel) 显示方法线Eidtor-&gt;General-&gt;Apperance-&gt;Show method separators 如Gif 所示，即使我们项目没有使用版本控制功能，IntelliJ IDEA 也给我们提供了本地文件历史记录。除了简单的记录之外，我们还可以给当前版本加标签。 如Gif 所示，IntelliJ IDEA 自带模拟请求工具 Rest Client，在开发时用来模拟请求是非常好用的。 如Gif 所示，IntelliJ IDEA 的自定义 TODO 功能非常好用，强烈建议平时开发要经常使用上。 如图箭头所示，在 Debug 状态下，如果我们要批量删除断点，可以点击图上箭头所示的按钮，然后选中要删除的断点按断点上面的减号进行删除。 如图所示，不管是用 IntelliJ IDEA 打开新文件，或是在安装本地插件，在弹出的窗口中，图 1 按钮支持快速定位到系统桌面目录，图 2 按钮支持快速定位到当前项目目录。 如图所示，默认 IntelliJ IDEA 对于 Java 代码的单行注释是把注释的斜杠放在行数的最开头，我个人觉得这样的单行注释非常丑，整个代码风格很难看，所以一般会设置为单行注释的两个斜杠跟随在代码的头部。Editor-&gt;Code Style-&gt;Java-&gt;Code Generation-&gt;Line comment at fisrt勾掉 如图 Gif 所示，对于横向太长的代码我们可以进行软分行查看。软分行引起的分行效果是 IntelliJ IDEA 设置的，本质代码是没有真的分行的。 如图箭头所示，该设置可以增加 Ctrl + E 弹出层显示的记录文件个数。 默认 IntelliJ IDEA 是没有开启自动帮你生成 serialVersionUID 的，需要我们自行设置。如图第一张，需要先勾选：Serializable class without serialVersionUID如图第二张，在已经继承了 Serializable 接口的类名上，把光标放在类名上（必须这样做），按 Alt + Enter，即可提示帮你生成 serialVersionUID 功能。 如图 gif 演示的：Load/Unload Modules 是 2017.2 引入的新特性，对于多模块的项目开发 Unload 部分少用到的模块可以减少计算机 CPU 和内存的消耗。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm设置]]></title>
    <url>%2Fpycharm-config%2F</url>
    <content type="text"><![CDATA[使用Tab缩进Editor-&gt;Code Style-&gt;Python-&gt;Tabs and Indents勾选Use tab character和Smart tabs 取消自动更新Appearance&amp;Behavior-&gt;System Settings-&gt;Updates勾掉Automatically check updates for和Use secure connection]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中安装Intellij Idea]]></title>
    <url>%2Fubuntu-intellij%2F</url>
    <content type="text"><![CDATA[下载Intellij Idea 解压到/opt下sudo tar -zxvf ideaIU-2017.2.5.tar.gz -C /opt 进入IDEA文件夹的bin目录cd /opt/idea-IU-172.4343.14/bin 启动IDEA./idea.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 17.10安装sklearn]]></title>
    <url>%2Fubuntu-sklearn%2F</url>
    <content type="text"><![CDATA[安装支持库 sudo pip3 install numpy scipy matplotlib pandas 安装sklearn sudo pip3 install scikit-learn ​]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox中Ubuntu 17.10 安装JDK8]]></title>
    <url>%2Fubuntu-jdk8%2F</url>
    <content type="text"><![CDATA[下载JDK8http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 因为是在虚拟机中运行Ubuntu，所以JDK8文件是下载在Windows系统中，需要设置共享文件夹，把文件复制到Downloads文件夹下。 解压文件cd Downloads/tar -zxvf jdk-8u151-linux-x64.gz 将解压的文件夹jdk1.8.0_151移动到/usr/sudo mv jdk1.8.0_151/ /usr/ 配置系统环境变量，编辑/etc/profile文件，在文件的末尾添加以下内容sudo vim /etc/profile export JAVA_HOME=/usr/jdk1.8.0_151 #jdk主目录export JRE_HOME=$JAVA_HOME/jre #jre目录export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib #CLASSPATH目录export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin #将jdk的可执行文件目录添加到系统环境目录中1234 更新配置source /etc/profile 查看是否安装成功java -version]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下pip3的安装、升级、卸载]]></title>
    <url>%2Fubuntu-pip3%2F</url>
    <content type="text"><![CDATA[安装sudo apt-get install python3-pip 升级sudo pip3 install --upgrade pip 卸载sudo apt-get remove python3-pip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Could not get lock /var/lib/dpkg/lock - open 解决方法]]></title>
    <url>%2Flinux-lock%2F</url>
    <content type="text"><![CDATA[出现此问题的原因是另外一个线程使用apt-get下载，结束现场呢个即可。1.搜索所有的线程ps -A | grep apt-get得到如图所示结果 结束线程数字就是线程号，结束线程即可sudo kill 1358]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij Idea 2017 设置Eclipse快捷键风格]]></title>
    <url>%2Fintellij-eclipse-shortcut%2F</url>
    <content type="text"><![CDATA[Intellij Idea 可以设置Eclipse风格快捷键。File--&gt;Settings--&gt;Keymap选择Eclipse]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox中Linux设置共享文件夹]]></title>
    <url>%2Flinux-share-dir%2F</url>
    <content type="text"><![CDATA[安装Virtual Box增强功能包，若已安装，跳过该步骤。 在物理机设置一个共享文件夹，如F:/share/linux 点击VirtualBox状态栏上设备——共享文件夹 添加共享文件夹，这里共享文件夹名称为share，后面步骤会用到，选择固定分配和自动挂载。 进入Linux，打开终端，创建挂载点目录，这里为/mnt/shared sudo mkdir /mnt/shared 挂载共享文件夹，这里的share就是上面步骤4中的共享文件夹名称share sudo mount -t vboxsf share /mnt/shared 设置自动挂载，可以在/etc/fstab中添加一项 sudo vim /etc/fstabshare /mnt/shared vboxsf rw,gid=110,uid=1100,auto 0 0 卸载挂载点命令 sudo umount -f /mnt/shared 共享文件可以在/mnt/shared中查看]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持备份/还原win10系统的分区工具DiskGenius v4.9.3专业版下载+序列号注册文件激活教程]]></title>
    <url>%2Fwin10-diskgenius%2F</url>
    <content type="text"><![CDATA[关于DiskGenius这款分区软件，相信大家都使用的炉火纯青了，今天之所以给大家重新介绍分享，是因为之前给大家分享的DiskGenius版本都是网上现成的绿色版本，而今天给大家分享的版本是官方原版，并且是目前官方提供的最新版本DiskGenius v4.9.3，大家都知道，默认情况下在官网下载的DiskGenius在不购买输入序列号的情况下是免费版本，有功能限制，但今天亦是美网络小编要给大家分享的是如何将DiskGenius免费版本升级成专业版，还有一点，使用DiskGenius v4.9.3专业版还可以备份还原win10系统的分区，何不尝试一下？！ DiskGenius v4.9.3官网下载 64位下载地址：http://download.eassos.cn/DG493409_x64.zip 32位下载地址：http://download.eassos.cn/DG493409_x86.zip DiskGenius v4.9.3官方免费版升级专业版 从官网下载的DiskGenius是一个压缩包，解压缩后可以直接点击DiskGenius.exe运行打开。 不过，如果直接运行的话，得到的只是一个免费版本，要想使用功能齐全的专业版，我们需要进行以下一个步骤： 首先下载Options.ini文件：http://pan.baidu.com/s/1kTq12Kn 密码: r9jz 下载完成后，直接将该文件复制到刚刚解压缩的DiskGenius目录里，替换掉原先的Options.ini文件即可。 tips：Options.ini是存放注册激活信息的文件。 替换后，再次打开DiskGenius的时候就显示成专业版本啦。 如何使用DiskGenius v4.9.3备份/还原win10系统的分区 以备份为例，打开DiskGenius后，选中一个分区，比如系统所在分区C盘，右键点击该分区，然后选择”备份分区到镜像文件”，然后根据提示进行操作就可以了，很简单的。 如果要还原分区的话，同样的步骤，右键点击该分区，选择”从镜像文件还原分区”，不过需要注意的是，如果是还原系统分区的话，需要在PE下才能进行。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>DiskGenius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows上自动设置java环境变量的脚本]]></title>
    <url>%2Fwindows-java-script%2F</url>
    <content type="text"><![CDATA[代码这里默认设置了java jdk的安装路径为C:\Program Files\Java\jdk1.7.0_71，如果你的jdk安装路径不在此，可在执行此命令的时候，会有提示输入jdk安装路径，输入即可。 首先粘贴命令如下： 下载地址 @echo off:: TODO:设置java环境变量:: Author: Gwtcolor 02::设置java的安装路径，可方便切换不同的版本set input=set /p "input=请输入java的jdk路径（或回车默认路径为C:\Program Files\Java\jdk1.7.0_71）:"if defined input (echo jdk已设置) else (set input=C:\Program Files\Java\jdk1.7.0_71)echo jdk路径为%input%set javaPath=%input%::如果有的话，先删除JAVA_HOMEwmic ENVIRONMENT where "name='JAVA_HOME'" delete::如果有的话，先删除ClASS_PATH wmic ENVIRONMENT where "name='CLASS_PATH'" delete::创建JAVA_HOMEwmic ENVIRONMENT create name="JAVA_HOME",username="&lt;system&gt;",VariableValue="%javaPath%"::创建CLASS_PATHwmic ENVIRONMENT create name="CLASS_PATH",username="&lt;system&gt;",VariableValue=".;%%JAVA_HOME%%\lib\tools.jar;%%JAVA_HOME%%\lib\dt.jar;"::在环境变量path中，剔除掉变量java_home中的字符，回显剩下的字符串call set xx=%Path%;%JAVA_HOME%\jre\bin;%JAVA_HOME%\bin::echo %xx%::将返回显的字符重新赋值到path中wmic ENVIRONMENT where "name='Path' and username='&lt;system&gt;'" set VariableValue="%xx%"pause 解释下面就解释下命令 @echo off 是关闭回显的，不会显示命令信息 on打开会显示命令信息 color 02是设置输出文本颜色的，这里是控制命令台输出绿颜色 set /p “input=请输入命令信息” 是用来接收控制台输入的文本信息的 if else 是用来做判断 if defined input 是用来判断用户是否输入信息，回车的话，则表示未定义input的值 echo “输出信息” 是用来显示信息的 set javaPath=%input% 是用来吧变量input的值赋值给javaPath变量的 wmic 是提供了批处理的命令，可以方便的操作环境变量值 删除某一环境变量 就使用 wmic ENVIRONMENT where “name=’JAVA_HOME’” delete命令 创建某一环境变量 使用 wmic ENVIRONMENT create name=”JAVA_HOME”,username=”“,VariableValue=”%javaPath%”命令 修改某一环境变量 使用 wmic ENVIRONMENT where “name=’Path’ and username=’‘“ set VariableValue=”value” 注意事项 在上述批处理脚本命令中，要严格注意空格和大小写等的输入，不然执行不成功的 要以管理员方式运行命令，不然提示拒绝执行命令的提示]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++没有插件管理器(Plugin Manager)的原因以及解决方法]]></title>
    <url>%2Fnotepad-plugin-error%2F</url>
    <content type="text"><![CDATA[今天想下几个notepad++的插件玩玩，结果发现根本就没有插件管理器。 后来上官网发现了这样一句话Note that the most of plugins (including Plugin Manager) are not yet available in x64 于是重新安装了一个32位的版本]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++中代码格式化插件NppAStyle]]></title>
    <url>%2Fnotepad-nppastyle%2F</url>
    <content type="text"><![CDATA[工具/原料 Windows7 Notepad++ NppAStyle(Notepad++的一个插件) 方法/步骤 直接在插件扩展中安装 下载Notepad++并安装NppExec插件。 插件—&gt;Plugin Manager—&gt;show Plugin Manager—&gt;安装NppAStyle插件。 自己下载dll插件 或者直接下载NppAStyle插件。登录NppAStyle网站下载，网址： http://sourceforge.net/projects/nppastyle/files/ 我们选择下载NppAStyle_bin_0.10.02.14.zip这个文件。 ​ 解压 下载后我们打开这个压缩文件，发现有两个文件夹ansi和unicode(ansi是标准编码，支持语言少；unicode是通用编码，支持更多的语言)。 打开unicode文件夹，将里面的NppAStyle.dll解压出来，将NppAStyle.dll放置到Notepad++安装目录下的plugins文件夹下。 ​ 重启Notepad++看NppAStyle是否安装成功，看到如图所示的信息就说明安装成功。 ​ 配置NppAStyle。 点击菜单栏中的”插件”—&gt;”NppAStyle”—&gt;”options”，在代码风格中选择java。 ​ 点击菜单栏中的”插件”—&gt;”NppAStyle”—&gt;”Format code”（或者按快捷键Alt+f），欣赏格式化后的代码风格。 ​ ​ 体验不同的代码风格并选择自己中意的某种代码风格。 重复第4步骤，例如将代码风格选中ANSI，按下快捷键Alt+f，欣赏格式化后的代码风格，并与第5步骤中格式化后的代码风格相比较。 ​ ​ 特别要注意：目前NppAStyle插件只支持格式化C、C++、C#、Java这四种编程语言的代码。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 17.03 安装Chrome浏览器]]></title>
    <url>%2Fubuntu-chrome%2F</url>
    <content type="text"><![CDATA[1.移动到下载文件存放目录cd Downloads2.下载chrome文件2.1 32位使用如下命令wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb2.2 64位使用如下命令wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb3.安装chromesudo dpkg -i google-chrome*;sudo apt-get install -f]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 17.03安装搜狗拼音]]></title>
    <url>%2Fubuntu-sogou%2F</url>
    <content type="text"><![CDATA[添加fcitx 的键盘输入法系统，因为搜狗是基于fctix 安装搜狗输入法 设置系统参数 添加fcitx 添加源sudo add-apt-repository ppa:fcitx-team/nightly 更新系统sudo apt-get update 安装fcitxsudo apt-get install fcitx 安装fcitx的配置工具sudo apt-get install fcitx-config-gtk 安装fcitx的table-all软件包sudo apt-get install fcitx-table-all 安装im-switch切换工具sudo apt-get install im-switch 查看fictx是否安装完成 安装搜狗输入法 选择操作系统版本下载 安装搜狗输入法2.1 移动到文件夹位置cd xxxsudo dpkg -i xxx.deb【注】会出现错误，可不用理会 设置语言选项 System Settings--&gt;Language Support,将键盘输入法系统由默认的iBus设置为fcitx 上述步骤之后重启一次 搜索Fxitx Configruation,将搜狗输入法设为默认3.1 在Input Method界面点击加号，3.2 把only show current language勾选掉，搜索sogou3.3 使用Ctrl+Space切换]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 安装截图工具 Shutter]]></title>
    <url>%2Fubuntu-shutter%2F</url>
    <content type="text"><![CDATA[一、安装截图工具 Shutter 添加安装包软件源 sudo add-apt-repository ppa:shutter/ppa 更新源并安装 shutter sudo apt-get updatesudo apt-get install shutter 搜索 shutter 可看到已安装成功 二、设置 Shutter 快捷键 打开系统设置 打开 Keyboard 键盘设置 添加成功的状态 单击右侧 Disabled，然后快速按下 Ctrl+Alt+A 如下图 Ctrl+Alt+A 测试OK。 ps: 里面的快捷键命令用：shutter -s 或者shutter –select 截取当前活动窗口：shutter -a （a表示active） 截取拖拉区域：shutter -s （s是select之意），拖拉出矩形区域后按Enter。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 Ubuntu双系统双硬盘 硬盘安装]]></title>
    <url>%2Fwin10-ubuntu%2F</url>
    <content type="text"><![CDATA[准备工作 ubuntu-17.04-desktop-amd64.iso EasyBCD 2.3 一个单独的分区（磁盘管理器中删除卷，但是不格式化，具体操作过程类似下述开辟临时分区）【注】使用Win+X选择打开磁盘管理器 安装过程开辟一个临时分区 打开磁盘管理器,找一个分区，右键点击压缩卷。【注】不要选择要安装Linux系统分区分出一个临时分区，否则后面合并的时候会从基本磁盘转变为动态磁盘。后续处理会变得麻烦。 输入压缩空间，与系统镜像文件相同就可以。会得到一个未分配分区。 右键点击新建卷，格式化为FAT32格式。 最后安装完成系统后，可以在创建的临时分区上右键点击删除卷，会得到一个未分配的分区空间，再在想要合并的分区上右键点击扩展卷。 安装EasyBCD 2.3 添加新条目--&gt;NeoGrub 点击安装 点击配置 在打开的menu.lst文件中输入以下内容 title Installroot (hdM,N) kernel (hdM,N)/vmlinuz.efi boot=casper iso-scan/filename=/linux.iso ro quiet splash locale=zh_CN.UTF-8 initrd (hdM,N)/initrd.lztitle rebootreboottitle halthalt12345678 【注】 hdM是指第几块硬盘，我的是第二块硬盘所以是hd1，从0开始N是指存放的第几个分区 linux.iso是指你要安装的Linux系统镜像，要与实际镜像文件相同。\3. 若在安装过程启动的过程中卡住。把quiet splash改成nomodeset 复制镜像文件到临时分区 将镜像文件命名为linux.iso 复制到临时分区根目录下，解压缩出casper中的initrd.lz和vmlinuz.efi文件。【注】若casper文件夹中的vmlinuz.efi文件没有efi后缀，重命名文件加上后缀即可。 重启电脑 选择NeoGrub【注】若不能选择NeoGrub，进行如下更改。打开EasyBCD，编辑引导菜单--&gt;等待用户选择 选择Install【注】若出现找不到文件的错误，返回到上一级目录，按e进行修改，修改(hdM,N)修改N的数值，以便找到文件。 安装系统 Ctrl+Alt+T打开终端，卸载镜像sudo umount -l /isodevice 点击安装Ubuntu按钮，进行安装【注】建议拔掉网线，关闭Wifi，会加速安装速度。 分区操作，选择Something else 选择空余的free space双硬盘需要按以下格式分区，不然安装后会卡在启动界面。 挂载点 分区类型 文件系统类型 / 逻辑分区 Ext4 /boot 逻辑分区 Ext4 /home 逻辑分区 Ext4 swap 逻辑分区 Swap area 【注】双硬盘双系统都应该是逻辑分区\5. 安装完成 删除Linux系统目前的方法不太安全，进入Win10磁盘管理器，直接将Linux系统的分区删除卷,会得到一个未分配分区，然后新建简单卷。此种方法会重新开机找不到引导项，需要进入pe系统，修复引导项即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10利用DiskGenius重建分区表]]></title>
    <url>%2Fwin10-diskgenius-partition%2F</url>
    <content type="text"><![CDATA[安装DiskGenius 工具--&gt;搜索已丢失的分区界面如下： 开始搜索后，如果找到一个分区，会提示你忽略还是保留。【注】搜索到的第一个结果一般是系统盘C盘，这个结果需要忽略，否则后面无法找到其他分区。后面搜索到的分区需要确认其中是否为你原来分区中保存的文件之后才选择保留。 搜索完成后，点击硬盘--&gt;保存分区表.win10系统保存为GUID格式。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>DiskGenius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox Ubuntu 16.04安装Tensorflow]]></title>
    <url>%2Ftensorflow-ubuntu-install%2F</url>
    <content type="text"><![CDATA[1.安装python-pip和python-devsudo apt-get install python-pip python-dev2.安装Tensroflow sudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl 【注】如果有错误，可以尝试使用上述命令重新安装 3.安装完成。出现以下界面表示安装完成。 测试 $ python&gt;&gt;&gt;import tensorflow as tf&gt;&gt;&gt;hello=tf.constant('hello')&gt;&gt;&gt;sess=tf.Session()&gt;&gt;&gt;print(sess.run(hello))hello&gt;&gt;&gt;a=tf.constant(10)&gt;&gt;&gt;b=tf.constant(32)&gt;&gt;&gt;print(sess.run(a+b))4212345678910 5.安装IDE安装的IDE为Komodo Edit链接：http://komodoide.com/download/edit-linux64/#解压缩后界面如下：安装步骤： 进入到该文件解压缩的文件夹中 运行./install.sh,界面如下：]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全的将动态磁盘转为基本磁盘]]></title>
    <url>%2Fhdware-dynamic2basic%2F</url>
    <content type="text"><![CDATA[前言手里有一块拆机硬盘，想着格式化几个分区，空间就大了，然后不知怎的就识别不了了，在windows磁盘管理显示为动态磁盘，用diskgenius打开，可以看到磁盘里的文件，但是如果想拷贝出来就得花钱，可是我又不想花钱，而且我还不想拷贝出来，有没有什么办法使硬盘恢复正常呢，百度了一通，答案大同小异，其中有个什么傲什么的软件，安装后提示该硬盘是MBR分区表，不支持，shit,纠结了好久，感觉还是不能放弃啊，咱身为一个技术人员一块硬盘都搞不定以后还怎么生（装）存（逼），终于自己摸索出来了一条新路子。由于直接将动态磁盘转为基本磁盘会丢失所有数据，这里我们还是先了解下硬盘为什么会变为动态磁盘。硬盘之所以能被系统识别，是因为每一个分区都有一份分区表，这份分区表保存在注册表里，就像是一块地图，系统根据这个地图到达每一个硬盘分区，如果这份地图丢失，那么这几个分区就变成未知的新大陆了，当然还有其他原因，不过误删分区引起的分区表丢失是最容易遇到的，这里我就针对此问题抛出我的解决方案。相信你也猜到了，那就是恢复分区表。 恢复丢失的分区表这里利用diskgenius磁盘分区软件，百度搜一大堆，这里就不给下载地址了，免安装的直接运行 我是用一个移动硬盘盒，将硬盘插进去，作为一个移动硬盘插到电脑上，当然你也可以用光驱硬盘驱动器，道理一样。 右键选中移动硬盘的根节点，注意，不是单独的分区，也不是动态磁盘根节点，是移动硬盘根节点。点菜单栏第二个 1.硬盘—&gt;重建主引导记录（MBR）2.弹出一个框，直接点确定，会搜索丢失的分区3.最后会发现左侧分区树发生了变化，动态磁盘已经变成逻辑磁盘了4.然后点击保存分区表，会问保存为MBR还是GUID格式，这个看你自己了，应该是都可以，我选了GUID,然后提示会将分区表保存在硬盘上，会影响磁盘结构啥的，不用管，点确定。然后在我的电脑里可以看到，移动硬盘的分区一个接一个都显示出来了,数据都在，完好无损。 如果上面执行第一步时没有可选菜单，先将磁盘转为不同于当前模式的磁盘，比如当前是MBR转为GUID，或者GUID转为MBR，只要跟当前格式不一样就行。然后进行上面操作 总结套路为：搜索分区，一路都点保留按钮，完毕后点击左上角的保存按钮，退出即可。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat `#`不是内部或外部命令，也不是可运行的程序或批处理文件]]></title>
    <url>%2Ftomcat-error%2F</url>
    <content type="text"><![CDATA[打开tomcat根目录/bin/catalina.bat 查找# Configure JAVA 9 specific start-up parameters 修改为rem Configure JAVA 9 specific start-up parameters]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij部署Tomcat问题]]></title>
    <url>%2Fintellij-tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat部署中war与war exploded区别 war模式：即发布模式，将Web工程以war包的形式上传到服务器。 war exploded模式：将Web工程以当前文件夹的位置关系上传到服务器。 【注】 此模式直接把文件夹、jsp页面等相关文件移动到Tomcat部署文件夹里进行加载部署。因此此模式支持热部署。 使用热部署，需要对其他选项进行设置]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装Python 3.6.1]]></title>
    <url>%2Flinux-install-python%2F</url>
    <content type="text"><![CDATA[准备编译环境 sudo yum groupinstall 'Development Tools'sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel12 2.下载Python 3.6.1源码包 打开https://www.python.org/downloads/release/python-361/,下载XZ compressed source tarball 3.安装 3.1 创建安装文件的目录sudo mkdir /usr/local/python3 3.2 进入到下载的目录解压缩tar -Jxvf Python-3.6.1.tar.xz 3.3 配置./configure --prefix=/usr/local/python3 3.4 编译make 3.5安装sudo make install 4.安装后已自动做软链，无需再进行操作 5.pip做软链sudo ln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++编译、运行C/C++]]></title>
    <url>%2Fnotepad-c%2F</url>
    <content type="text"><![CDATA[安装MinGW编译器若安装过CodeBlocks，只需要将绝对路径MinGW/bin添加到环境变量path中。 若未安装任何编译器，先安装编译器，并将bin文件夹的绝对路径添加到环境变量path中。 安装NppExec插件之前文章Notepad++编译运行Java中有安装过程，在此不再重复 配置C/C++编译器 配置C编译器 打开Plugins-&gt;NppExec--&gt;Execute 在对话框中输入 cmd /c "gcc -o $(CURRENT_DIRECTORY)\$(NAME_PART) $(FULL_CURRENT_PATH) &amp;&amp; CLS &amp;&amp; pushd $(CURRENT_DIRECTORY) &amp;&amp; $(NAME_PART).exe" 点击Save保存，命名为Run C 将上述保存的命令添加到Macros中。 点击Plugins-&gt;NppExec-&gt;Advanced Options 在Associated script中选择Run C 点击Add/Modify添加到Menu Items中，勾选Place to the Macros submenu 点击Macros，此时已经有Run C，点击Macros-&gt;Modify Shortcut/Delete Macro 打开后点击Plugin Commands,为Run C设置快捷键 配置C++编译器步骤同上，第二步输入替换为 cmd /c "g++ -o $(CURRENT_DIRECTORY)\$(NAME_PART) $(FULL_CURRENT_PATH) &amp;&amp; CLS &amp;&amp; pushd $(CURRENT_DIRECTORY) &amp;&amp; $(NAME_PART).exe" 删除NppExec中的命令脚本点击Plugins-&gt;NppExec-&gt;Execute,点击Save... ​ 删除点击Delete]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NotePad++配置Python]]></title>
    <url>%2Fnotepad-python%2F</url>
    <content type="text"><![CDATA[1.安装python 建议更改安装路径到c:\python，可以方便notepad++调用。 安装时选项建议选择add path，可以自动配置 2.配置notepad++ run–&gt;run 填入命令cmd /k c:\python\python.exe &quot;$(FULL_CURRENT_PATH)&quot; &amp; ECHO. &amp; PAUSE &amp; EXIT]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++编译、运行Java]]></title>
    <url>%2Fnotepad-java%2F</url>
    <content type="text"><![CDATA[Plugins--&gt;Plugin Manager--&gt;Show Plugin Manager 安装NppExec Plugins--&gt;NppExec 输入以下参数 NPP_SAVE cd "$(CURRENT_DIRECTORY)" javac.exe "$(FILE_NAME)" java.exe "$(NAME_PART)" 1234 5.定义快捷键5.1 Plugins--&gt;NppExec--&gt;Advanced Options5.2 Associated script选择保存的脚本名5.3 点击Add/Modify5.4 勾选Place to the Macros submenu5.5点击OK 重启Notepad++ Run--&gt;Modify Shortcut/Delete Command--&gt;Plugin Command7.1找到自定的脚本名，更改快捷键]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python】两个txt文件通过某一字段关联]]></title>
    <url>%2Fpython-txt%2F</url>
    <content type="text"><![CDATA[背景将两个txt文件通过两者共有的某一项进行关联，类似于数据库中的不同表通过id相关联。txt1:#checkins(userID/venueID/time/offset)txt2:#pois(venueID/latitude/longtitude/words/country)通过共有项venueID，将txt1的数据以及txt2的数据关联起来，写入一个新的文件txt3。格式如userID/venueID/time/offset/latitude/longitude/words/country 思路将txt2文件的venueID作为字典的key，然后将latitude,longtitude,words,country写入一个列表里作为字典的值。 比对txt1中的venueID，相同则直接将txt1的此行写入txt3，同时将字典中的venueID对应的值——latitude,longtitude,words,country写入txt3 代码f1=open('f:\checkins.txt','r')f2=open('f:\pois.txt','r')fout=open('f:\dataset.txt','a+')dicc=dict()for line in f2: #将pois.txt截取出各个字段，写入字典中,key为venueID,value为[latitude,longitutde,words,country] line=line.strip().split('\t') values=[] latitude=line[1] longitutde=line[2] words=line[3] country=line[4] values.append(latitude) values.append(longitutde) values.append(words) values.append(country) dicc[line[0]]=values #venueID:[latitude,longitutde,words,country]#venueID_list=[]for line1 in f1: venueID=line1.split('\t')[1] if(dicc.get(venueID) != None): #if(venueID not in venueID_list): #去掉重复，不需要则注释掉 #venueID_list.append(venueID) fout.write(line1.strip('\n')+'\t'+dicc[venueID][0]+'\t'+dicc[venueID][1]+'\t'+dicc[venueID][2]+'\t'+dicc[venueID][3]) fout.write('\n')f1.close()f2.close()fout.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera解决无法播放视频问题]]></title>
    <url>%2Fcoursera-video%2F</url>
    <content type="text"><![CDATA[打开文件C:\Windows\System32\drivers\etc\hosts 添加内容52.84.246.72 d3c33hcgiwev3.cloudfront.net 打开cmd,输入ipconfig/flushdns。刷新dns即可]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS yum install Another app is currently holding the yum lock解决方法]]></title>
    <url>%2Fyum-lock%2F</url>
    <content type="text"><![CDATA[centos在yum install报错：Another app is currently holding the yum lock解决方法 Another app is currently holding the yum lock，这个意思很明显就是说，有另外一个应用在使用yum，被占用锁定了，所以咋办呢，直接结束掉,可以通过强制关掉yum进程： sudo rm -f /var/run/yum.pid]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础语法备忘]]></title>
    <url>%2FC-backup%2F</url>
    <content type="text"><![CDATA[常量整型常量（Integer）整形常量的表示形式 整型常量的表示形式 特点 举例 十进制 0-9的数字序列组成，数字前可带正负号 256,-128,0,+7 八进制 以0开头，后跟0-7的数字序列组成，0前可带正负号 021，-017 十六进制 以0x开头，后跟0-9,a-f的数字序列组成 0x12,-0x1F 整型常量的类型 长整形：l，如：-256L，1024l 无符号整形：u，如：30u，256U，不能表示成小于0的数，如-30u非法 无符号长整形：lu，30lu 实型常量（Float） 指数形式0.345e-5=0.00000345 实型常量的类型 实型常量隐含按双精度型（double） 单精度：f 长双精度(long double)：l 字符常量转义字符 字符 含义 \n 换行(new line) \r 回车（不换行）(carriage return) \0 空字符，代表ASCII码值为0的字符 \t 水平制表(horizontal tabulation) \b 退格(backspace) \&quot; 双引号(double quotation mark) \&#39; 单引号(single quotation mark) \\ 反斜线(backslash) \? 问号 变量局部变量 局部变量定义时不会自动初始化，若未赋初值，则取随机值 全局变量*全局变量定义时未赋初值则初始化为0 静态变量 静态变量会保持上一次的值 若未赋初值，则初始化为0 const类型修饰符 const常量只能在定义时赋初值，不能再程序中改变其值。 char类型与int类型的关系 char型可看作一种特殊的int型。 在C语言中，只要在ASCII码取值范围内，char型数据和int型数据可以相互转换，即char型数据可以参与任何int型数据的运算例：一个char型变量既可以以字符格式输出，也可以以整形格式输出，以整形格式输出即输出其ASCII码的十进制值。 char ch='a';printf("%c,%d\n",ch,ch);--&gt;a,971234 变量Tips char型数据在内存中只占1个字节int型与程序执行环境的字长有关。16位下占16位，即2个字节；32位下占32位，即4个字节。可以使用sizeof计算类型的字节数 对于实数，无论是小数表示形式还是指数表示形式，在计算机内部都是采用浮点数方式来存储。 * 运算符算术运算符 两个整数相除的结果仍为整数，舍去小数部分的值。 整数与实数原酸的结果为double型 求余运算限定参与运算的两个操作数为整数。余数的符号与被除数的符号相同。 常用的标准数学函数 函数名 功能 sqrt(x) 计算平方根 fabs(x) 计算绝对值 log(x) 计算lnX的值 log10(x) 计算lgX的值 exp(x) 计算e^x的值 pow(x,y) 计算x^y的值 赋值运算符 =左侧只能是变量名 位运算符 位运算符的操作对象只能是char和int类型 &amp;：按位与，一种对某位清零的手段，即两个操作数中任意一位为0，则结果置0 |:按位或，一种对某位置1的手段，即两个操作数中任意一位为1，则置1 ^：按位异或，两个操作数位不同，则置1 &lt;&lt;：左移位，每左移一位相当于乘2 &gt;&gt;：右移位，每右移一位相当于除2 类型转换赋值中的类型转换 C语言支持类型自动转换机制 表达式中的类型转换 表达式中若混有不同类型的常量及变量，则先要全部转换为同一类型，再进行运算。 类型提升(Type Promotion)：把所有操作数都转换成占内存字节数最大的操作数类型。 输入/输出printf() 格式转换符 格式转换符 用法 %d 带符号的十进制整数 %u 无符号的十进制整数 %o 无符号的八进制整数，不输出前导符0 %x 无符号的十六进制整数（小写），不输出前导符0x %c 输出一个字符 %s 输出字符串 %% 百分号% * 格式修饰符 格式修饰符 用法 英文字母l 输出long型数据 最小域宽m 指定输出项输出时所占的列数。若m为正整数，向右靠齐。若m为负整数，向左靠齐。 显示精度.n 对于浮点数，指定输出的浮点数的小数位数。对于字符串，指定输出截取的子串字符个数 scanf() 格式转换符 格式转换符 用法 %d 十进制整数 %o 八进制整数 %x 十六进制整数 %c 字符，空白字符（空格、回车、制表符）也作为有效输入 %s 字符串，遇到第一个空白字符输入结束 %f 实数 %% 百分号 * 格式修饰符 格式修饰符 用法 忽略输入修饰符* 表示对应的输入项在读入后不赋给相应的变量 域宽m 指定输入的数据的宽度，按此宽度截取所需数据 函数 宏是预处理阶段替换，函数是运行时调用。 数组 定义数组的大小必须使用整型常量或整型常量表达式。如int score[100]合法，而int score[n]非法 C语言的数组在内存中是按行存放的。 数组名代表数组的首地址 数组不能整体引用，每次只能引用数组的一个元素 不能用赋值表达式对数组元素进行整体赋值。如score={1,2,3,4,5};非法 数组的初始化 引用数组前，必须保证数组的元素被赋以确定的 二维数组，既可以按元素初始化，也可以按行初始化如：int matrix[3][2]={(1,2,3,4),{5,6,7,8}};//按行初始化int matrix[3][2]={1,2,3,4,5,6,7,8};//按元素初始化 当初始化列表中提供的初值个数少于数组元素个数时，自动给后面的元素赋值为0如 int matrix[1][2]=&#123;0&#125;;等价于int matrix[1][2]=&#123;0,0&#125;;123 当数组被声明为static(静态)类型或外部存储类型（即在所有函数外部定义时），则在不显式给出初值的情况下，数组元素将在程序编译阶段自动初始化为0。 向函数传递一维数组 可以用数组名作为函数参数 在接收一维数组的函数中，在声明一维数组的形参时，可以省略数组的长度如： void sort(int arr[10]);等价于void sort(int arr[]);123 向函数传递二维数组 在接收二维数组的函数中，在声明二维数组形参时，不能省略数组第二维的长度。如: void func(int arr[4][3]);void func(int arr[][3]);都合法，但void func(int arr[][]);非法12345 字符数组字符数组与字符串关系 字符串由若干有效字符及字符&#39;\0&#39;作为结束标志的一个字符序列。 字符串借助字符型一维数组存储。 最后一个&#39;\0&#39;占用一字节的存储单元，但是不计入字符串的实际长度。 每个字符串在内存中占用一串连续的存储空间，而且这段连续的存储空间有唯一的首地址。 如果一个字符串只是字符串常量，则这个字符串常量本身代表的是该字符串在内存中所占连续存储空间的首地址，是一个地址常量。 一维字符数组可存放一个字符串，二维字符数组可存放多个字符串。 字符串赋值给字符数组1.用char数据对数组初始化char str[6]={&#39;C&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;,&#39;\0&#39;};此种方式赋初值，必须人为的加入&#39;\0&#39; 2.用字符串常量对数组初始化char str[]=&quot;China&quot;;* 对于二维字符数组存放多个字符串，第二维的长度不能省略，应该按最长的字符串长度设定。char weekday[][10]={&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;}; 字符数组的输入/输出1.以c格式字符一个个单独输入/输出for(i=0;i&lt;10;i++)&#123; scanf("%c",&amp;str[i]);&#125;for(i=0;str[i]!='\0';i++)&#123; printf("%c",str[i]);&#125;123456 2.以s格式作为字符串整体输入/输出scanf("%s",str);printf("%s",str);12 【注】space、enter、tab作为以%s格式输入字符串的分隔符，因而不能被读入，遇到这些字符即结束输入。 3.用gets()或puts()输出/输出 gets()从键盘读入一个字符串（包括空格符） puts()输出一个字符串，当遇见第一个&#39;\0&#39;时输出结果，并自动输出一个换行符 字符串处理函数 需要#include 指针 指针：是一种特殊的数据类型，只存放地址型数据 直接寻址：按变量名来存取变量内容的访问方式 间接寻址：通过指针变量间接存取指向的变量的访问方式 指针Tips a=*p++;，其中++与*优先级相同，且是右结合的。相当于a=*(p++);,而++又位于变量p之后，即相当于 a=*p;p=p+1;12 a=(*p)++相当于 a=*p;*p=*p+1;12 字符指针字符指针与字符数组的区别1. 初始化含义不同 char str[10]=&quot;China&quot;;表示定义一个字符数组str,数组名str代表字符串&quot;China&quot;在内存中存放的首地址。 char *ptr=&quot;China&quot;;表示定义一个字符指针ptr，并在定义时用字符串&quot;China&quot;在内存中的首地址为指针变量ptr赋初值。 2. 赋值方法和含义不同。 指针赋值 char *ptr;ptr="China"; //正确12 字符串中的一个字符的地址赋给ptr，相当于用地址值对ptr赋初值。* 字符数组赋值 char str[10];str="China";//错误12 以上方法是错误的，数组名是数组元素的首地址，是一个常量值，无法被改变。将一个字符串赋值给字符数组必须使用strcpystrcpy(str,&quot;China&quot;); 3. 输入方式不同 字符数组输入 char str[10];scanf("%s",str);12 字符指针必须保证字符指针事先已经指向一个数组的首地址 char *ptr,str[10];ptr=str;scanf("%s",ptr);123 4.类型不同* 字符数组的数组名是一个地址常量，值不能改变* 字符指针是一个变量，值可以被改变 【注】由于数组名作函数形参与指针变量作函数形参的等价性。因此，在用数组名作函数形参的函数体内部可以对该声明为形参的数组名进行和指针一样的自增、自减运算。除此之外的数组名都是一个指针常量，不能进行自增、自减的运算。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中C编程编译与调试]]></title>
    <url>%2Flinux-C%2F</url>
    <content type="text"><![CDATA[gcc编译器gcc编译流程【Tips】* Linux的可执行文件没有Windows那么明显的.exe扩展名，只需向其分配x权限即可。sudo chmod u+x filename* gcc可以在编译的任何阶段结束，以便检查或使用该阶段的输出。 gcc支持编译的扩展名 扩展名 源文件 .c C语言源代码文件 .C .cc .cpp C++源代码文件 .h 头文件 .a 存档文件 .i 经过预处理的C源代码文件 .ii 经过预处理的C++源代码文件 .s 汇编语言源代码文件 .S 经过预编译的汇编语言源代码文件 .o 编译后的目标文件 gcc参数 参数 作用 -o 指定生成的输出文件 -s 将C代码转换为汇编代码 -c 仅执行编译操作，不进行链接操作 应用无参数编译gcc a.c将a.c预处理、汇编、编译、链接成可执行文件。未指定输出则默认a.out 指定输出的文件gcc a.c -o do指定a.c输出为do可执行文件gcc a.c -o /tmp/do指定输出为/tmp目录下的do文件 多源文件的编译 多个文件一起编译gcc a.c b.c -o do将a.c和b.c分别编译后链接成do文件 分别编译各个源文件，对编译后输出的目标文件链接 gcc -c a.c #将a.c编译成a.ogcc -c b.c #将b.c编译成b.ogcc -o a.o b.o -o do #将a.o 和 b.o 链接成do123 以上两个方法，第一个方法编译时需要重新编译所有文件，第二个只重新编译修改的文件，未修改的文件不用重新编译。 查看编译过程gcc -v a.c查看编译过程和显示调用的库。 C程序的编译编写C程序使用VIM编写简单的C程序。\1. 打开终端\2. 在用户家目录下新建一个c文件夹mkdir ~/c\3. 打开VIM。vim\4. 编写C程序 #include&lt;stdio.h&gt;int main()&#123; printf("hello"); return 0;&#125;12345 编写完成后，按Esc返回到普通模式，保存文件到家目录下的c文件夹，保存为a.c:wq ~/c/a.c 使用gcc编译 打开终端，进入上文创建的~/c文件夹。cd ~/c 使用gcc编译gcc a.c -o a 执行编译出的可执行文件./a 编译过程详解* 预处理：对预编译语句（如宏定义define）和文件包含进行处理。需要完成的工作室对预编译指令进行替换，把包含文件放置到需要编译的文件中。最终生成一个非常完整的C源文件。* 编译：对预处理后的文件编译，生成.s的汇编语言文件。* 汇编：处理汇编语言。调用汇编处理程序将汇编语言汇编成二进制代码。最终生成.o目标文件。* 链接：将多个汇编生成的目标文件以及引用的库文件进行模块链接生成一个完整的可执行文件。 gdb调试器gdb简介主要使用gdb进行下面5个方面的操作：* 启动程序：在启动程序时，可以设置程序运行环境。* 设置断点：这里的断点可以使行数、程序名称或条件表达式。* 查看信息：断点停止后，可以查看程序的运行信息和显示程序变量的值。* 分步运行：使程序一个个语句的执行。* 改变环境：可以在程序运行时改变程序的运行环境和程序变量。 在程序中加入调试信息为了使用gdb进行调试，需要在编译程序中加入供gdb使用的调试信息。使用-g参数gcc -g -o a.debug a.c编译a.c生成一个a.debug的可执行程序，其中加入了供调试所用的信息。 gdb的使用启动gdb在终端输入gdb 加载需要调试的程序file a.debug运行结果如下，证明已加载此文件。Reading symbols from /home/tian/a.debug ...done 在gdb中查看代码用gcc -g编译后的a.debug程序加入了断点。可以用list查看程序的源代码和断点。1.list 1，会显示第一个断点前的代码。以上文a.c为例，会显示以下:2.按Enter键会显示下一个断点前的代码。 加入断点break命令可以增加断点。如在上文的例程第3行增加一个断点。break 3 查看断点info break 运行程序 run运行程序 next在下一行停下 continue在下一个断点位置停下 step单步运行。 step与next类似，都可以实现单步运行。不同的是，在遇上函数调用时，step可以进入函数内部，next跳过函数的调用 变量的查看print 退出调试q gdb常用命令 backtrace：显示程序中的当前位置和表示如何到达当前位置的栈跟踪 cd：改变当前工作目录 clear：删除刚才停止处的断点 delete：删除一个断点 display：程序停止时显示变量和表达式 info files：显示被调试文件的信息 info func：显示所有的函数名称 info local:显示所有的局部信息变量 info var：显示所有的全局和静态变量名称 whatis：显示变量或函数类型]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim简明教程]]></title>
    <url>%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中sudo命令详解]]></title>
    <url>%2Fsudo%2F</url>
    <content type="text"><![CDATA[sudo命令详解su、su-和sudo区别Linux中许多操作需要具有root用户权限才能执行，因此提供了su、su-、sudo命令使得用户具有root权限。 su与su-区别su命令用于切换当前用户身份到其他用户身份，切换时需要被切换用户的密码格式：su [参数] username【注】如果只是su命令，不带有username，则默认切换到root用户，su-同上。su与su-区别： su切换到其他用户，但是不切换环境变量 su -完整的切换一个用户环境,退出需要使用exit命令 如果使用以上两个命令，建议使用su- su与sudo区别由于Linux是多人多任务系统，而某些操作需要root用户权限，但不可能每个用户都有权力知道root用户密码，因此root用户便于管理，即相当于权力下放，允许某些用户能够拥有root用户权限，因此产生sudo命令。 su与sudo区别： su需要被切换用户的密码，sudo只需要本用户密码 su所有用户只要知道root用户密码就可以切换，sudo只有root用户在/etc/sudoers文件中配置了才能够拥有root权限 sudo命令特性 能够限制用户在某台主机上运行某些命令，允许管理员集中管理 提供丰富日志，详细记录了用户行为 使用时间戳文件限制用户的使用时间，默认5分钟，超时需要重新登录。（值可以在编译时更改） sudo命令配置某用户能够执行sudo命令需要事先root用户授权，即在/etc/sudoers文件中配置。\1. 切换root用户。su -\2. 添加文件的写权限。chmod u+w /etc/sudoers\3. 编辑/etc/sudoers。vim /etc/sudoers找到root ALL=(ALL) ALL在下面添加xxx ALL=(ALL) ALL,其中xxx为用户名，保存退出。4.撤销文件的写权限。chmod u-w /etc/sudoers]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下yum命令出现Loaded plugins fastestmirror]]></title>
    <url>%2Fcentos-yum-fastestmirror%2F</url>
    <content type="text"><![CDATA[fastestmirror是yum的一个加速插件，这里是插件提示信息是插件不能用了。步骤： 1.修改插件的配置文件# vi /etc/yum/pluginconf.d/fastestmirror.conf【Tips】：用Tab可补全将enabled=1改为enabled=0 2.修改yum的配置文件# vi /etc/yum.conf将plugins=1改为plugins=0 【注】以上操作需要切换到root用户下，否则会出现vim e505:read only 和vim e212错误 3.reboot]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS在Virtual Box上的安装——安装增强包]]></title>
    <url>%2Fcentos-virtualbox%2F</url>
    <content type="text"><![CDATA[【注】执行命令时先进入root1.安装需要的环境sudo yum groupinstall "Development Tools"sudo yum install kernel-devel 【注】如果出现yum Loaded plugins:fastestmirror问题，请参考CentOS下yum命令出现Loaded plugins: fastestmirror2.重启系统sudo reboot 【注】若点击virtualbox中的设备中的安装增强功能，出现自动运行可直接点击。3.挂载并安装VBoxGuestAdditions.iso3.1点击virtualbox的设备中的安装增强功能 3.1.1若使用GNome，挂载VBoxGuestAdditions.iso后出现Run界面，直接点击运行即可，后续步骤无需执行。3.2新建目录sudo mkdir /home/vbtools 3.3挂载到CD/DVD虚拟光驱sudo mount -t auto /dev/cdrom /home/vbtools （这里的cdrom是cd的，有时是dvd1，具体有什么光驱需要到/dev下查看） 3.4转到目录查看挂载cd /home/vbtoolsls 如果列表中出现VBoxLinuxAdditions.run证明挂载成功 sudo sh ./VBoxLinuxAdditions.run 出现下图安装成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2Flinux-bash%2F</url>
    <content type="text"><![CDATA[提示符 $为一般账户，#为root账号快捷键 tab可作为（1）命令补齐（2）档名补齐（3）参数项补齐 ctrl+z暂停正在运行的程序 ctrl+c终止正在运行的程序 ctrl+r搜索输入过的命令 ctrl+s停止滚屏 ctrl+q恢复滚屏 命令通配符 * 匹配零个或多个 ? 匹配任意一个字符 [0-9] 匹配一个数字范围 [abc] 匹配离别里任何字符 [^abc]匹配列表外字符常用命令切换用户 su - 切换到root用户，并新建一个新环境 exit 退出当前用户 id 显示当前用户信息 passwd 修改当前用户密码查看命令history 列出输入过的命令作业管理 命令后加&amp;表示后台运行。如firefox &amp;代表后台打开一个火狐 jobs查看所有后台运行的程序 bg将程序放到后台运行 如：bg 1将任务号为1的任务放到后台运行 【注】若前台任务只有一个，可省略任务号参数 fg将后台程序放到前台运行 网络命令wget用于下载网络文件.格式:wget [参数] 下载地址| 参数 | 作用 | || —- | —————– | —- || -b | 后台下载 | || -O | 下载到指定目录 | || -t | 最大尝试次数 | || -c | 断点续传 | || -p | 下载页面内所有资源，包括图片、视频 | || -r | 递归下载 | | elinks用于实现一个纯文本界面的浏览器格式:elinks [参数] 网址 文件目录命令pwd(print working directory)显示当前的工作目录格式:pwd [参数]| 参数 | 作用 | || —- | —————– | —- || -p | 显示真实路径（即非快捷链接的地址） | | touch 创建空白文件 修改文件时间对于Linux中的文件有三种时间： 更改时间(mtime):内容修改时间（不包括权限的） 更改权限(ctme):更改权限与属性的时间 读取时间(atime):读取文件内容的时间 参数 作用 -a 修改“访问时间”(atime) -m 修改“更改时间”(mtime) -d 同时修改atime和mtime mkdir创建文件夹格式：mkdir [参数] 目录| 参数 | 作用 | || —- | ——————- | —- || -m | 默认的文件目录权限，如-m 755 | || -p | 连续创建多层目录（若文件夹已存在则忽略 | || -v | 显示创建的过程 | | cp复制文件或目录格式：cp [参数] 源文件 目标文件三种情况： 目标文件是一个目录，将源文件复制到该目录中 目标文件是一个文件，将源文件覆盖该文件 目标文件不存在，将会复制源文件并修改为目标文件的名称（重命名）| 参数 | 作用 | || —- | ——————– | —- || -p | 保留原始文件的属性 | || -d | 若对象为链接文件，则保留该链接文件的属性 | || -i | 若目标文件存在则询问是否覆盖 | || -a | 相当于上述-pdr参数 | |mv 移动文件 对文件或目录重命名格式：mv [参数] 源文件 [目标路径|目标文件名] 如果目标文件是到某一目录文件的路径，则源文件会移动到此目录下，且文件名不变。如，将目录/usr/men中所有的文件移动到当前目录（.表示）mv /usr/men/* . 如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。 如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。 当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。如将文件ex2改为new1mv ex2 new1 参数 作用 -b 若需覆盖文件，则覆盖前先备份 -f 若目标文件或目录与现有文件或目录重复，则直接覆盖现有的文件或目录 rm(remove)删除文件或目录 删除普通文件并提示确认信息rm 文件名 删除普通文件或目录文件rm -rf 文件名或目录名cd(change directory)切换工作路径格式：cd [目录]| 参数 | 作用 | || ——— | ———————————— | —- || - | 切换到上次的目录，如cd - | || ~ | 切换到家目录，直接cd也可以回到家目录 | || ~username | 切换到其他用户的家目录,如cd ~teak切换到teak用户的家目录 | || .. | 切换到上级目录，如cd .. | |ls查看目录中有哪些文件格式：ls [参数] [文件]| 参数 | 作用 | || ——- | ——————- | —- || -a | 查看全部文件（包括隐藏文件） | || -d | 仅显示目录名，而不显示目录下的内容列表 | || -l | 显示文件的详细信息 | || –color | 使用不同颜色高亮不同的文件类型 | |文本文件编辑命令cat(concatenate)查看纯文本文件（较短的）格式：cat [参数][文件]| 参数 | 作用 | || —- | —————– | —- || -n | 显示行号 | || -b | 显示行号（不包括空行） | || -A | 显示不可见的符号，如空格，tab键 | |more查看纯文本文件（较长的）,一般用more分屏显示| 快捷键 | 作用 | || ——- | ———– | —- || space | 显示下一屏 | || enter | 只显示文本的下一行内容 | || b | 显示上一屏 | || q | 退出more命令 | | 参数 作用 -d 显示提示语句与信息 less查看纯文本文件，与more类似，但是less可以向上向下翻页，more只能向下翻页 tail显示文件的末尾几行| 参数 | 作用 | || —- | ————————————– | —- || -f | 追踪显示文件更新。（一般用于查看日志，该命令不会退出，持续显示先加入的文本） | | 系统状态检测命令ifconfig(interfaceconfig)用于获取网卡配置与网络状态等信息。格式：ifconfig [网络设备] [参数] uname(Unix name)查看系统内核版本信息格式：uname [-a]如果想查看系统详细版本信息查看redhat-release文件# cat /etc/redhat-release who查看当前登入主机的用户情况格式：who [参数] last查看所有系统的登入记录格式:last [参数] uptime查看系统的负载情况watch -n l uptime 每秒刷新一次获得当前的系统负载情况，输出内容分别为系统当前时间、系统已运行时间、当前在线用户、平均负载值 free显示当前系统中内存的使用情况格式:free [-m/-g]以MB为单位或以GB为单位显示 查看硬件信息命令lspci查看PCI设备| 参数 | 作用 | || —- | ——— | —- || -v | 查看详细信息 | || -b | 以总线为中心的视图 | | lsusb查看USB设备| 参数 | 作用 | || —- | —— | —- || -v | 查看详细信息 | | lsmod查看加载的模块（驱动） ###归档解压命令 tar对文件压缩或解压格式：tar [参数] [文件名]| 参数 | 作用 | || —- | ———- | —- || -c | 创建压缩文件 | || -x | 解压缩文件 | || -t | 查看压缩包内的内容 | || -z | 用Gzip压缩或解压 | || -v | 显示压缩或解压的过程 | || -f | 目标文件名 | || -C | 制定解压到的目录 | | 【例】 将/etc目录内文件打包并通过gzip压缩 tar -czvf etc.tar.gz /etc 将etc.tar.gz文件解压到/root/etc目录中 mkdir /root/etctar -xzvf etc.tar.gz -C /root/etc zip压缩文件格式：zip 目标文件 源文件 unzip 解压缩zip文件 格式：unzip 文件 查找命令find查找指定目录下的文件。格式:find 查找位置 参数| 参数 | 作用 | || ———— | ——————- | —- || -name&lt;范本样式&gt; | 指定字符串作为查找文件或目录的范本样式 | || -perm&lt;权限数值&gt; | 查找符合指定的权限数值的文件或目录 | || -user&lt;拥有者名称&gt; | 查找符合指定的拥有者名称的文件或目录 | || -type&lt;文件类型&gt; | 查找符合指定的文件类型的文件 | |【例】 在/home目录下查找以.txt结尾的文件名 find /home -name *.txt 2.当前目录及子目录下查找所有以.txt和.pdf结尾的文件 find . -name *.txt -o -name *.pdf 3.根据文件类型搜索find . -type 类型参数| 参数 | 说明 | || —- | —- | —- || f | 普通文件 | || l | 符号链接 | || d | 目录 | || c | 字符设备 | || b | 块设备 | || s | 套接字 | | 4.找出/home下不是以.txt结尾的文件find /home ! -name *.txt 基于目录深度搜索 向下最大深度限制为3find . -maxdepth 3 -type f 搜索出深度距离当前目录至少2个子目录的所有文件find . -mindepth 2 -type f 6.根据文件时间搜索 搜索最近七天内被访问过的所有文件find . -type f -atime -7 搜索恰好在七天前被访问过的所有文件find . -type f -atime 7 搜索超过七天内被访问过的所有文件find . type f -atime +7 搜索访问时间超过10分钟的所有文件find . -type f -amin +10 7.根据文件大小搜索| 参数 | 说明 | || —- | ——– | —- || c | 字节 | || w | 字（2字节） | || b | 块（512字节） | || k | 千字节 | || M | 兆字节 | || G | G字节 | | 搜索大于10kb的文件find . -type f -size +10k 搜索小于10kb的文件find . -type f -size -10k 搜索10kb的文件find . type f -size 10k 8.删除匹配文件删除当前目录下所有的.txt文件find . -type f -name *.txt -delete 9.根据权限或所有者搜索 搜索当前目录下权限为777的文件find . -perm 777 搜索当前目录下权限不是644的php文件find . -name *.php ! -perm 644 搜索当前目录用户 tom 拥有的所有文件find . -user tom 搜索当前目录用户组sunk拥有的所有文件find . -group sunk 10.搜索所有长度为0的文件find . -empty]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux帮助说明]]></title>
    <url>%2Flinux-help%2F</url>
    <content type="text"><![CDATA[##指令的–help选项--help选项显示命令的大致用法 ##man命令man xxx man page常用键| 按键 | 说明 | || ———– | —————————————- | —- || 空格键 | 向下翻页 | || [page down] | 向下翻页 | || [page up] | 向上翻页 | || [home] | 去到第一页 | || [end] | 去到最后一页 | || /string | 向下搜索string这个字符串 | || ?string | 向上搜索string这个字符串 | || n,N | 利用/或?来搜寻字符串时，可以用n继续下一个搜寻（不论是/或?，用N反向搜寻 | || q | 退出此次man page | | 可以使用man man命令获得更详细的说明 可以使用man -f命令查找更多信息，如man -f man。【注】此命令只能查找完整名称的命令。 也可以使用man -k命令查找更多信息，如man -k man。【注】此命令可以查找关键词，即模糊查找。 man查询后的数字含义| 代号 | 含义 || —– | —————————————- || 1 | 用户在shell环境中可以操作的指令或可执行文件，即一般用户可用 || 2 | 系统核心可呼叫的函数与工具 || 3 | 一些常用的函数（function）与函数库（library），大部份分为c的函数库（lib从） || 4 | 装置文件的说明，通常在/dev下的文件 || 5 | 配置文件或某些文件的格式 || 6 | 游戏 || 7 | 惯例与协议，如Linux文件系统、网络协议、ASCII code等的说明 || 8 | 系统管理员可用的管理指令 || 9 | 跟kernel有关的文件 | man page 构成| 代号 | 说明 | || ———— | ————————- | —- || NAME | 简短的指令，数据说明 | || SYNOPSIS（大纲） | 简短的指令语法（syntax）简介 | || DESCRIPSION | 较为完整的说明 | || OPTIONS | 针对SYNOPSIS部分中，列举所有可用的选项说明 | || SEE ALSO | 可以参考的，跟这个指令或数据有关的其他说明 | |##info page与man page的区别：info page将文件数据拆成一个个的段落，每个段落用自己的页面来编写，并且在每个页面中还有类似网页的超链接跳到各个不同的页面中，每个独立的页面被称为一个节点(node)| 按键 | 说明 | || ———– | —————————- | —- || 空格键 | 向下翻页 | || [page down] | 向下翻页 | || [page up] | 向上翻页 | || [tab] | 在node之间移动，有node的地方，通常会以*显示 | || [enter] | 当光标在node上面时，进入该node | || b | 移动光标到该info画面中的第一个node处 | || e | 移动光标到该info画面中的最后一个node处 | || n | 前往下一个node处 | || p | 前往上一个node处 | || u | 向上移动一层 | || s(/) | 在info page中搜寻 | || h,? | 显示求助选单 | || q | 结束这次info page | |]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA破解 2017 IDEA license server 激活]]></title>
    <url>%2FIdea2017-license%2F</url>
    <content type="text"><![CDATA[【注】 &lt;font=’red’&gt;Idea 2017.3以后版本无法使用该网址激活，该网址支持2017.3以下版本，如2017.2.4等 进入ide主页面，help-register-license server,然后输入 http://idea.iteblog.com/key.php（注意：php要小写）即可~如下图，]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua的一种continue实现]]></title>
    <url>%2Flua-continue%2F</url>
    <content type="text"><![CDATA[Lua中没有continue，通过另一种方式实现了continue的功能for var=exp1,exp2 do while true do if condition expressions do break end other statements ... ... break endend]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua基础语法]]></title>
    <url>%2Flua%2F</url>
    <content type="text"><![CDATA[注释 单行注释两个减号，-- 多行注释--[[ 内容 --]] 数据类型 Lua是动态类型语言，变量不需要类型定义，只需为变量赋值 数据类型 描述 nil 只有值”nil”属于该类，表示一个无效值(在条件表达式里相当于false) boolean false 和 true number 双精度类型的实浮点数 string 由一对双引号&quot; &quot;或单引号&#39; &#39;表示 function 由C或Lua编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 nil nil类型表示一种没有任何有效值,它只有一个值”nil” 对于全局变量和table,nil的另外一个作用为删除，给全局变量或table表里的变量赋值nil,等于把它们删掉boolean Lua把false和nil看作“假”，其余为“真”number Lua默认只有一种number类型，即double(双精度)类型，默认类型可以修改luaconf.h里的定义。以下几种写法都是number类型&gt;print(type(2))&gt;print(type(2.2))&gt;print(type(0.2))&gt;print(type(2e+1))&gt;print(type(0.2e-1))&gt;print(type(7.8263692594256e-06))numbernumbernumbernumbernumbernumber string 由一对双引号&quot; &quot;或单引号&#39; &#39;表示 两个方括号[[ ]]表示一块字符串 &gt;html = [[&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.w3cschool.cc/"&gt;w3cschool菜鸟教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]print(html)&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.w3cschool.cc/"&gt;w3cschool菜鸟教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在对一个数字字符串上进行算术操作时，Lua会将数字字符串转成一个数字 &gt; print("2" + 6)8.0&gt; print("2" + "6")8.0&gt; print("2 + 6")2 + 6&gt; print("-2e2" * "6")-1200.0&gt; print("error" + 1)stdin:1: attempt to perform arithmetic on a string valuestack traceback: stdin:1: in main chunk [C]: in ?&gt; 字符串连接需要用..,需加上空格 &gt;print('a' .. 'b')ab&gt;print(157 .. 333)157333 使用#计算字符串的长度，放在字符串前面 &gt;len='www.w3cshool.cc'&gt;print(#len)16&gt;print(#'www.w3cschool.cc')16 table--创建一个空表local table1=&#123;&#125;--初始表local table2=&#123;'apple','pear','orange','grape'&#125; Lua中的table是一个”关联数组”,数组的索引可以数字或字符串【注】Lua中table 默认初始索引从1开始a=&#123;&#125;a['key']='value'key=10a[key]=22a[key]=a[key]+11for k,v in ipairs(a) do print(k .. ':' .. v)end结果key:value10:33 function 在Lua中，function被看作是”第一类值(First-Class Value)”,函数可以存在变量里 function factorial1(n) if n==0 then return 1 else return n*factorial1(n-1) endendprint(factorial1(5))factorial2=factorial1print(fatorial2(5))结果120120 userdatauserdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。 变量 变量在使用前，必须在代码中进行声明，即创建该变量。 Lua 变量有三种类型：全局变量、局部变量、表中的域 变量的默认值均为 nil。 标识符 一般用下划线加大写字母的标识符，为Lua的保留字。如：_VERSION 为保留用于Lua内部全局变量 区分大小写全局变量 默认是全局变量 全局变量无需声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，得到的结果为：nil print(b)&gt;nilb=10print(b)&gt;10 删除一个全局变量，将变量赋值为nil即可 b=nilprint(b)&gt;nil 局部变量使用local声明应该尽可能的使用局部变量，有两个好处： 避免命名冲突。 访问局部变量的速度比全局变量更快。赋值语句 Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。 a, b = 10, 2*x &lt;--&gt; a=10; b=2*x 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值： x, y = y, x -- swap 'x' for 'y'a[i], a[j] = a[j], a[i] -- swap 'a[i]' for 'a[j]' 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： 变量个数 &gt; 值的个数 按变量个数补足nil 变量个数 &lt; 值的个数 多余的值会被忽略 &gt;a, b, c = 0, 1&gt;print(a,b,c) 0 1 nil &gt;a, b = a+1, b+1, b+2 -- value of b+2 is ignored&gt;print(a,b) &gt;1 2 &gt;a, b, c = 0&gt;print(a,b,c) 0 nil nil 多值赋值经常用来交换变量，或将函数调用返回给变量：a,b=fun() f()返回两个值，第一个赋给a，第二个赋给b。 循环whilewhile(condition)do statementsend forLua中for语句有两大类: 数值for循环 泛型for循环 数值for循环for var=exp1,exp2,exp3 do statementsend var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次”执行体”。exp3是可选的，如果不指定，默认为1 for的三个表达式在循环开始前一次性求值，以后不再进行求值。泛型for循环用过一个迭代器遍历所有值--打印数组a 的所有值for i,v in ipairs(a) do print(v)end i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。 days=&#123;"Suanday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;for i,v in ipairs(days) do print(v)end结果SuandayMondayTuesdayWednesdayThursdayFridaySaturday repeat…untilLua 编程语言中 repeat…until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断。 repeat statementsuntil(contidion) 我们注意到循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。 函数函数作为参数 Lua 中我们可以将函数作为参数传递给函数myprint = function(param) print("这是打印函数 - ##",param,"##")endfunction add(num1,num2,functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result)endmyprint(10)-- myprint 函数作为参数传递add(2,5,myprint)结果这是打印函数 - ## 10 ##这是打印函数 - ## 7 ## 多返回值 Lua可以返回多个结果值，如string.find，返回匹配串“开始和结束的下标”（如果不存在匹配串返回nil） &gt;s,e=string.find('www.runoob.com','runoob')&gt;print(s,e)5 10 Lua函数中，在return后列出要返回的值得列表即可返回多值 function maximum(a) local mi=1 --最大值索引 local m=a[mi] --最大值 for i,val in ipairs(a) do if val &gt; m then mi=i m=val end end return m,miendprint(maximum(&#123;8,10,23,12,5&#125;))结果23 3 return f()这种形式，则返回“f()的返回值”： function foo0() endfunction foo1() return 'a' endfunction foo2() return 'a','b' endfunction foo(i) if i==0 then return foo0() elseif i==1 then return foo1() elseif i==2 then return foo2() endend&gt;print(foo(1))a&gt;print(foo(2))a b&gt;print(foo(0)) --(no result)&gt;print(foo(3)) --(no result) 可以使用圆括号( )强制使调用返回一个值 &gt;print((foo0()))nil&gt;print((foo1()))a&gt;print((foo2()))a 函数多值返回的特殊函数unpack，接受一个数组作为输入参数，返回数组的所有元素。unpack被用来实现范型调用机制，在C语言中可以使用函数指针调用可变的函数，可以声明参数可变的函数，但不能两者同时可变。在Lua中如果你想调用可变参数的可变函数只需要这样：f(unpack(a))unpack返回a所有的元素作为f()的参数 f=string.finda=&#123;'hello','ll'&#125;print(f(unpack(a)))--&gt;3 4 预定义的unpack函数是用C语言实现的，也可以用Lua实现function unpack(t,i) i= i or 1 if t[i] then return t[i],unpack(t,i+1) endend 可变参数 Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（…) 表示函数有可变的参数。 Lua将函数的参数放在一个叫arg的表中，#arg 表示传入参数的个数。function average(...) result = 0 local arg=&#123;...&#125; for i,v in ipairs(arg) do result = result + v end print('总共传入' .. #arg .. '个数') return result/#argendprint('平均值为',average(10,5,3,4,5,6))结果总共传入 6 个数平均值为 5.5 再论函数Lua中的函数是带有词法定界(lexical scoping)的第一类值(first-class value) 第一类值在Lua中函数和其他值（数值、字符串）一样，函数可以被存放在变量中，也可以存放在table中，可以作为函数的参数，还可以作为函数的返回值 词法定界嵌套的函数可以访问它外部函数中的变量 Lua中关于函数难以理解的地方时函数也可以是匿名的。函数名（如print）实际上是一个指向函数的变量，像具有其他类型值的变量一样a=&#123;p=print&#125;a.p('hello world') --&gt;hello worldprint=math.sin -- print now refers to the sin functiona.p(print(1)) --&gt;0.841470sin=a.p --sin now refers to the print functionsin(10,20) --&gt;10 20 闭包当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量，这种特征我们称作词法定界。虽然这看起来很清楚，事实并非如此，词法定界加上第一类函数在编程语言里是一个功能强大的概念，很少语言提供这种支持。下面看一个简单的例子，假定有一个学生姓名的列表和一个学生名和成绩对应的表；现在想根据学生的成绩从高到低对学生进行排序，可以这样做：names=&#123;'Peter','Paul','Mary'&#125;grades=&#123;Mary=10,Paul=7,Peter=8&#125;table.sort(names,function (n1,n2) return grades[n1]&gt;grades[n2]end) 假定创建一个函数实现此功能function sortByGrade(names,grades) table.sort(names,function(n1,n2) return grades[n1]&gt;grades[n2] end)end 例子中包含在sortbygrade函数内部的sort中的匿名函数可以访问sortbygrade的参数grades，在匿名函数内部grades不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者upvalue。（upvalue意思有些误导，然而在Lua中他的存在有历史的根源，还有他比起external local variable简短）。 function newCounter() local i = 0 return function() -- anonymous function i = i + 1 return i endend c1 = newCounter()print(c1()) --&gt; 1print(c1()) --&gt; 2 匿名函数使用upvalue i保存他的计数，当我们调用匿名函数的时候i已经超出了作用范围，因为创建i的函数newCounter已经返回了。然而Lua用闭包的思想正确处理了这种情况。简单的说，闭包是一个函数以及它的upvalues。如果我们再次调用newCounter，将创建一个新的局部变量i，因此我们得到了一个作用在新的变量i上的新闭包。c2 = newCounter()print(c2()) --&gt; 1print(c1()) --&gt; 3print(c2()) --&gt; 2 c1、c2是建立在同一个函数上，但作用在同一个局部变量的不同实例上的两个不同的闭包。技术上来讲，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明；尽管如此，在不会导致混淆的情况下我们继续使用术语函数代指闭包。闭包在上下文环境中提供很有用的功能，如前面我们见到的可以作为高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。这一机制使得我们可以在Lua的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中，比如在GUI环境中你需要创建一系列button，但用户按下button时回调函数被调用，可能不同的按钮被按下时需要处理的任务有点区别。具体来讲，一个十进制计算器需要10个相似的按钮，每个按钮对应一个数字，可以使用下面的函数创建他们：function digitButton (digit) return Button&#123; label = digit, action = function () add_to_display(digit) end &#125;end 这个例子中我们假定Button是一个用来创建新按钮的工具， label是按钮的标签，action是按钮被按下时调用的回调函数。（实际上是一个闭包，因为他访问upvalue digit）。digitButton完成任务返回后，局部变量digit超出范围，回调函数仍然可以被调用并且可以访问局部变量digit。闭包在完全不同的上下文中也是很有用途的。因为函数被存储在普通的变量内我们可以很方便的重定义或者预定义函数。通常当你需要原始函数有一个新的实现时可以重定义函数。例如你可以重定义sin使其接受一个度数而不是弧度作为参数：oldSin = math.sinmath.sin = function (x) return oldSin(x*math.pi/180)end 更清楚的方式do local oldSin = math.sin local k = math.pi/180 math.sin = function (x) return oldSin(x*k) endend 这样我们把原始版本放在一个局部变量内，访问sin的唯一方式是通过新版本的函数。利用同样的特征我们可以创建一个安全的环境（也称作沙箱，和java里的沙箱一样），当我们运行一段不信任的代码（比如我们运行网络服务器上获取的代码）时安全的环境是需要的，比如我们可以使用闭包重定义io库的open函数来限制程序打开的文件。do local oldOpen = io.open io.open = function (filename, mode) if access_OK(filename, mode) then return oldOpen(filename, mode) else return nil, "access denied" end endend 非全局函数Lua中函数可以作为全局变量也可以作为局部变量，我们已经看到一些例子： 函数作为table的域（大部分Lua标准库使用这种机制来实现的比如io.read、math.sin）。这种情况下，必须注意函数和表语法： 表和函数放在一起 Lib=&#123;&#125;Lib.foo=function (x,y) return x+y endLib.foo=function (x,y) return x-y end 使用表构造函数 Lib=&#123; foo = function (x,y) return x+y end, goo = function (x,y) return x-y end&#125; Lua提供另一种语法方式 Lib=&#123;&#125;function Lib.foo (x,y) return x+yendfunction Lib.goo (x,y) return x-yend 当我们将函数保存在一个局部变量内时，我们得到一个局部函数，也就是说局部函数像局部变量一样在一定范围内有效。这种定义在包中是非常有用的：因为Lua把chunk当作函数处理，在chunk内可以声明局部函数（仅仅在chunk内可见），词法定界保证了包内的其他函数可以调用此函数。下面是声明局部函数的两种方式：1.方式一local f=function() ...endlocal g=function() ... f() -- external loca 'f' is visible here ...end 2.方式二local funciton f() ...end 有一点需要注意的是在声明递归局部函数的方式：local fact=function (n) if n==0 then return 1 else return n*fact(n-1) -- buggy endend 上面这种方式导致Lua编译时遇到fact(n-1)并不知道他是局部函数fact，Lua会去查找是否有这样的全局函数fact。为了解决这个问题我们必须在定义函数以前先声明：local factfact=function (n) if n==0 then return 1 else return n*fact(n-1) endend 这样在fact内部fact(n-1)调用是一个局部函数调用，运行时fact就可以获取正确的值了。但是Lua扩展了他的语法使得可以在直接递归函数定义时使用两种方式都可以。在定义非直接递归局部函数时要先声明然后定义才可以：local f,g --forward declarationsfunction g() ... f() ...endfunction f() ... g() ...end 运算符关系运算符 ~= 不等于逻辑运算符Lua中false 和 nil 是假，其余为真，0也是true and 逻辑与 or 逻辑或 not 逻辑非 and优先级比or高 and 和 or 的运算结果不是true和false，而是和它的两个操作数有关。a and b --如果a为false，返回a，否则返回ba or b --如果a为true，则返回a，否则返回b &gt;print(4 and 5)5&gt;print(nil and 13)nil&gt;print(false and 13)false&gt;print(4 or 5)4&gt;print(false or 5)5 一个实用的技巧：如果x为false或nil，则给x赋值初始值v x = x or v&lt;==&gt;if not x then x=vend C语言中的三元运算符a?b:c在Lua中可以如此实现(a and b) or c not的结果只返回false或true 其他运算符 .. 连接两个字符串 # 返回字符串或table 的长度 字符串常用操作 函数 用途 string.upper(arg) 转为大写字母 string.lower(arg) 转为小写字母 string.gsub(mainString,findString,replaceString,num) 在字符串中替换，mainString为要替换的字符串,findString为被替换的字符,replaceString为要替换的字符,num为替换次数(可忽略，则全部替换) string.find(str,subStr,[init,end]) 在一个指定的目标字符串中搜索指定的内容，第三个参数为索引，返回具体位置,不存在返回nil string.reverse(arg) 字符串反转 string.format(…) 返回一个类似print的格式化字符串 string.char(arg)和string.byte(arg,[int]) char将整形数字转成字符并连接,byte将字符转为整数值（可以指定某个字符，默认第一个字符） string.len(arg) 计算长度 string.rep(string,n) 返回字符串的n个拷贝 table table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 table 是不固定大小的，你可以根据自己需要进行扩容。 Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。 table的构造--初始表myTable=&#123;&#125;--指定值myTable[1]='Lua'--移除引用myTable=nil --Lua垃圾回收会释放内存 当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。 -- 简单的 tablemytable = &#123;&#125;print("mytable 的类型是 ",type(mytable))mytable[1]= "Lua"mytable["wow"] = "修改前"print("mytable 索引为 1 的元素是 ", mytable[1])print("mytable 索引为 wow 的元素是 ", mytable["wow"])-- alternatetable和mytable的是指同一个 tablealternatetable = mytableprint("alternatetable 索引为 1 的元素是 ", alternatetable[1])print("mytable 索引为 wow 的元素是 ", alternatetable["wow"])alternatetable["wow"] = "修改后"print("mytable 索引为 wow 的元素是 ", mytable["wow"])-- 释放变量alternatetable = nilprint("alternatetable 是 ", alternatetable)-- mytable 仍然可以访问print("mytable 索引为 wow 的元素是 ", mytable["wow"])mytable = nilprint("mytable 是 ", mytable)结果mytable 的类型是 tablemytable 索引为 1 的元素是 Luamytable 索引为 wow 的元素是 修改前alternatetable 索引为 1 的元素是 Luamytable 索引为 wow 的元素是 修改前mytable 索引为 wow 的元素是 修改后alternatetable 是 nilmytable 索引为 wow 的元素是 修改后mytable 是 nil 构造函数可以使用任何表达式初始化 tab=&#123;sin(1),sin(2),sin(3),sin(4),sin(5)&#125; 在构造函数中域分隔符逗号（”,”）可以用分号（”;”）替代，通常我们使用分号用来分割不同类型的表元素。 tab=&#123;x=10, y=45; "one", "two", "three"&#125; 常用操作 函数 用途 table.concat(table,sep,start,end) concat是concatenate(连接)的缩写.table.concat()列出指定table从strat位置到end位置的所有元素，元素间以指定分隔符（sep）隔开 table.insert(table,pos,value) 在table的指定位置pos插入值为value的元素 table.remove(table,pos) 返回table位于pos未知的元素，其余元素前移 table.sort(table,comp) 对table升序排序 模块与包创建模块 模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。 Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。--定义一个名为module的模块module=&#123;&#125;--定义一个常量module.constant='这是一个常量'--定义一个函数function module.func1() io.write('这是一个公有函数')endlocal funtion func2() print('这是一个私有函数')endfunction module.func3() func2()endreturn module 由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用. require函数 require函数用来加载模块require(&#39;模块名&#39;) 也可以给加载的模块定义一个别名变量,如local m=require('module') C包 Lua和C是很容易结合的，使用C为Lua写包。 与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。 Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下: local path = "/usr/local/lua/lib/libluasocket.so"local f = loadlib(path, "luaopen_socket") loadlib函数加载指定的库并且连接到Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为Lua的一个函数，这样我们就可以直接在Lua中调用他。 如果加载动态库或者查找初始化函数时出错，loadlib将返回nil和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：local path = "/usr/local/lua/lib/libluasocket.so"-- 或者 path = "C:\\windows\\luasocket.dll"，这是 Window 平台下local f = assert(loadlib(path, "luaopen_socket"))f() -- 真正打开库 一般情况下我们期望二进制的发布库包含一个与前面代码段相似的stub文件，安装二进制库的时候可以随便放在某个目录，只需要修改stub文件对应二进制库的实际路径即可。将stub文件所在的目录加入到LUA_PATH，这样设定后就可以使用require函数加载C库了。 迭代器在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型： 无状态的迭代器 多状态的迭代器无状态迭代器无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是ipairs，他遍历数组的每一个元素。以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：function square(iteratorMaxCount,currentNumber) if currentNumber&lt;iteratorMaxCount then currentNumber=currentNumber+1 return currentNumber,currentNumber*currentNumber endendfor i,n in square,3,0 do print(i,n)end结果1 12 43 9 迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs和迭代函数都很简单，我们在Lua中可以这样实现：function iter (a, i) i = i + 1 local v = a[i] if v then return i, v endend function ipairs (a) return iter, a, 0end 当Lua调用ipairs(a)开始循环时，他获取三个值：迭代函数iter、状态常量a、控制变量初始值0；然后Lua调用iter(a,0)返回1,a[1]（除非a[1]=nil）；第二次迭代调用iter(a,1)返回2,a[2]……直到第一个nil元素。 多状态迭代器很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。以下实例我们创建了自己的迭代器：array=&#123;'Lua','Tutorial'&#125;function elementIterator(collection) local index=0 local count=#collection --闭包函数 return function() index=index+1 if index&lt;=count then --返回迭代器当前元素 return collection[index] end endendfor element in elementIterator(array) do print(element)end结果LuaTutorial pairs和ipairs异同 同：都能遍历集合(table,数组) 异： ipairs仅能遍历值,按照索引升序遍历，索引中断停止遍历。即不能返回nil，只能返回数字0.如果遇到nil则退出，只能遍历到集合中出现的第一个不是整数的key pairs能遍历集合的所有元素。即pairs可以遍历集合中所有的key，并除了迭代器本身以及遍历表本身还可以返回nil 例1local tabFiles=&#123; [1]='test2' [6]='test3' [4]='test1'&#125;for k,v in ipairs(tabFiles) do print(k,v)end--[[结果为1 test2，在key为2时断开--]] 例2local tabFiles=&#123; [2]='test2' [6]='test3' [4]='test1'&#125;for k,v in ipairs(tabFiles) do print(k,v)end--[[什么都没输出，因为控制变量初始值按升序遍历，当key为1时，value值为nil，便停止遍历，所以无结果输出--]] 例3local tabFiles = &#123; [2] = "test2", [6] = "test3", [4] = "test1"&#125;for k, v in pairs(tabFiles) do print(k, v)end--输出2 test2, 6 test3, 4 test1 例4local tabFiles=&#123; 'alpha', 'beta', [3]='no', ['two']='yes'&#125;for k,v in ipairs(tabFiles) do print(tabFiles[i])end--输出前三个，因为第四个key不是整数for i,v in pairs(tabFiles) do print(tabFiles[i])end--全部输出 协同程序(coroutine)什么是coroutine?coroutine与线程类似，拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。 coroutine与线程区别 一个具有多线程的可以同时运行几个线程，coroutine则需要彼此协作运行 在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。常用操作函数|描述|—|—|coroutine.create()|创建coroutine,返回coroutine|coroutine.resume()|重启coroutine|coroutine.yield()|挂起coroutine|coroutine.statues()|查看coroutine的状态，有三种：dead，suspend，running|coroutine.wrap()|创建corountine，返回一个函数，一旦调用这个函数，进入coroutine，和create功能重复|corountine.running()|返回正在运行的coroutine，一个coroutine是一个线程，当使用running时，返回一个coroutine的线程号|]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2Fmarkdown-tutorial%2F</url>
    <content type="text"><![CDATA[前言几年前就听说Markdown的便利，但是懒于去记忆语法，一直拖到现在才去尝试。我想，一个善于学习的人应该“拥抱变化”，人生也应该多去尝试，固守陈规是不可取的。 ##简易语法注：本文以马克飞象为例 1. 标题#，#的个数表示级数 2. 列表 创建无序列表，* 创建有序列表，直接使用 1.、2.、3 符号与文本之间用空格分开 多级列表用Tab键 3. 引用&gt;，可嵌套使用，可通过空行结束4. 分割线连续至少三个*，如***5. 目录[toc],注：前面须有空行6. 脚注[^脚注名]:脚注内容7. 斜体*内容*8.粗体**内容**9. 加粗的斜体***内容***10. 删除线~~内容~~ 11. 图片![图片名称](链接) 12. 链接[链接名](链接) [链接名][链接名]:链接 13. 代码块 Tab 行内代码一个反引号` 区块代码三个反引号` ,后面加上语言类型 14.表格通过管线图方式表示 ####15.样式Markdown本身只是一个书写工具，其样式是通过CSS改变，支持HTML标签。【例】 改变字体颜色&lt;font color=red&gt;字体颜色为红色&lt;/font&gt;用法总结1. 不显示html代码使用html类型的代码块,如`html内 容`2.自动链接使用&lt;&gt;包含住一段链接,如&lt;http://www.baidu.com&gt; 3.转义反引号内的反引号，也可用于转义其他字符最外层连续两个反引号,效果如图git archive master --format=zip ＞ `git describe master`.zip 4. 缩进 &amp;emsp;,一个中文字符 &amp;ensp;,半个中文字符 &amp;nbsp;,1/4个中文字符]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
