<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Finstall-software%2F</url>
    <content type="text"><![CDATA[lrzsz 下载文件]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fno-root-install-python%2F</url>
    <content type="text"><![CDATA[无Root权限中Ubuntu安装Python​ 下载Python wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz 解压 tar -xvf Python-3.6.3.tar.zx 进入到解压后的文件夹 cd Python-3.6.3 ./configure --prefix=&#39;Your Install Director&#39; make &amp;&amp; make install 添加路径,编辑~/.bashrc vim ~/.bashrc 在文件最后添加 export PATH=/Your Install Path:$PATH，如export PATH=/usr/local/bin/:$PATH 创建别名，编辑~/.bashrc vim ~/.bashrc 在文件最后添加 alias python='Your python path'alias pip='Your pip path' ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[Match-LSTM和Pointer Net]]></title>
    <url>%2Fmatch-LSTM-Pointer-Network%2F</url>
    <content type="text"><![CDATA[[TOC] Match-LSTM简介Match-LSTM是由(Wang &amp; Jiang,2016)发表在NAACL的论文提出，用于解决NLI(Natural Language Inference，文本蕴含)问题。 premise：前提，代表上下文 hypothesis：假设，代表一个陈述性的结论 文本蕴含问题：给定一个premise（前提），根据这个premise去判断相应的hypothesis（假说）正确与否，如果从这个premise中能够推断出这个hypothesis，那么就判断为entailment（蕴含），否则就是contradiction（矛盾）。 Word-by-Word AttentionMatch-LSTM是在Rocktaschel et al. (2015)提出的word-by-word attention的基础上进行了改进，先解释一下Rocktaschel et al. (2015)提出的基本模型 用LSTM处理premise和hypothesis，(用premise的最后一个输出初始化hypothesis的LSTM)，得到它们的隐层输出。 其中， $h_j^s(1 \le j \le M )$是premise的输入序列经过LSTM之后得到的隐层输出。 $h_{k}^{t}(1\leq k\leq N)$是hypothesis的隐层输出向量。 word-by-word attention的意思是为每个hypothesis中的词引入一个$ak$,用于表示hypothesis，并称这个$a{k}$向量为attention向量，具体公式如下： 这里的attention权重$a_{kj}$表示hypothesis中第k个词和premise中第j个词之间的关系。 $hj^s$是premise的隐层输出，$h{k}^{t} $是hypothesis的隐层输出，$h_{k-1}^a$是将输入一个RNN之后得到的隐层状态。 最后利用$h_N^a$和$h_N^t$来预测label：y，即判断premise和hypothesis之间的关系。 流程 用两个LSTM处理premise和hypothesis序列。得到两个隐状态$h^s$和$h^t$(s对应前提，t对应假设)。 用下面的公式计算注意力向量$a_k$,这里计算得到的$e$经过归一化和加权求和得到假设$h^t$对前提$h^s$在每个时刻的注意力向量$a_k$ 上式中$h^m$的计算，用下面的公式计算，其中输入$m_k$是$[a_k,h_k^t]$的拼接。作者把这个结构称为mLSTM，把最后时刻的$h^m$作为输出以预测label。 ​ 与Word-to-Word Attention区别 两者的主要区别就是计算$e_{kj}$的不同。 这里用$h^m$代替了$h^a$。 之前的$h^m$是利用RNN得到的,$h^a$是用mLSTM得到的。 为了得到premise跟hypothesis之间的matching关系，用LSTM对它们进行建模，作者认为LSTM能够将premise和hypothesis之间重要的match关系进行保留，忽略不重要的match关系。具体公式如下: 最后利用$h_N^m$来预测。 Pointer Net简介Pointer Network是Vinyals et al.(2015)在NIPS发表的论文中提出的，是为了实现从输入序列中找到相应的tokens来作为输出，其他的阅读理解任务中，可能只需要用输入序列构建一个词典，再从这个候选词典中找到概率最大的一个词作为答案，然而SQuAD数据集的输出答案的长度是变化的，因而无法采用构建词典的方式，而pointer net是利用attention作为pointer，从输入序列中选择一个位置，并将这个位置所指向的词作为输出。对pointer net有兴趣的话，可以参看这个链接进行学习:Pointer net。AS-Reader、AoA-Reader和R-Net等模型都用了PtrNet作为输出层的结构。 模型结构 论文中提出了两个模型，且都包含以下三个部分： 用LSTM对question和passage进行预处理。 用match-LSTM对question和passage进行match。 利用Pointer Net从passage中选择tokens作为答案。 两个模型的区别在于在于第三部分，由于pointer net没有限定所指向的位置必须是连续的，所以第一个模型sequence model直接将答案在passage中出现的位置序号作为答案序列$a=\left( a{1} ,a{2},… \right) $，第二个模型只预测答案的起始位置跟终止位置，即$a=\left(a{s} ,a{e} \right)$。 LSTM Preprocessing Layer用单向LSTM对passage和question进行预处理。 Match-LSTM Layer这里将question当做premise，将passage当做hypothesis，用标准的word-by-word attention得到attention向量，具体公式如下： 其中， $\vec{h}_{i-1}^r \in R^l$是经过单向m-LSTM得到的隐层输出。 $\vec{\alpha_{i,j}}$表示passage中的第i个词和question中的第j个词之间的匹配关系。然后用$\overline{\alpha}$对question的隐层输出进行加权，并将其跟passage的隐层输出进行拼接，得到一个新的向量，并输入到m-LSTM中，得到$\bar{H^r}$，具体公式如下： 再从另一个方向进行相同的处理,将两者进行合并，得到最后的输出向量$H^{r} $ Answer Pointer LayerThe Sequence Model 由于这个模型是生成答案的位置序列$a=(a{1} ,a{2},…)$，每个元素表示的是这个词在passage中位置，其取值范围在1到P+1之间，当出现了P+1时，则答案生成终止。因此在$H^{r}$的最后中加入了一列0向量，用来表示终止词，得到$\bar{H} ^{r} $。 这里再次用到了attention方法去得到向量$\betak \in R^{(P+1)}$,$\beta{k,j}$表示选择passage中的第j个词作为答案序列的第k个词的概率，$\beta_{k,(P+1)}$表示在第k个位置停止答案生成的概率。公式如下： 其中，$h_k^a$也是经过一个LSTM的输出。 模型生成答案的概率公式如下： 损失函数如下： The Boundary Model因为boundary model只需要生成答案的起始和终止位置，因此不用在最后加入一个零向量来表示答案生成结束。生成答案序列的概率模型如下： 其余部分与上个模型相同。]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>阅读理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务型多轮对话系统概述]]></title>
    <url>%2Ftask-oriented-dialog-system%2F</url>
    <content type="text"><![CDATA[[TOC] 主要模块任务型机器人核心模块主要包括三个模块： 自然语言理解模块（NLU） 对话管理模块 自然语言生成模块（NLG） 自然语言理解模块该模块一般包含以下三个模块： 领域识别：即识别该语句是不是属于这个任务场景，一般有多个机器人集成时，如闲聊机器人，问答机器人等，领域识别应当在进入任务型机器人之前做判断与分发 意图识别：即识别用户意图，细分该任务型场景下的子场景、 语义槽填充：用于对话管理模块的输入 举例假设Text=“人民币对美元的汇率是多少”；经过自然语言理解模块会解析为 act ( slot1 = value1, slot2 = value2 ……) 的形式，即意图，槽位，槽位信息三元组形式，即 Text会解析为“查询（槽位1=人民币，槽位2=美元)”这样的形式。 方法基于规则理解方法【优点】 不需要大量训练数据 【缺点】 容易出错 调整规则费时费力，难以维护 统计方法（对齐）基于词对齐数据的自然语言理解通常被看做一个序列标注问题。主要有以下两类方法： 基于生成式模型 随机有限状态机（FST） 统计机器翻译（SMT） 动态贝叶斯网络（DBN） 基于判别式模型 CRF SVM MEMM 深度学习 BiLSTM+CRF CNN：用于序列标注 Seq2Seq 对话管理模块自然语言理解模块的三元组输出将作为对话管理系统的输入。它主要包括两部分： 状态追踪模块 对话策略模块 【状态追踪模块】 该模块在对话的每一轮次对用户的目标进行预估，管理每个回合的输入和对话历史，输出当前对话状态。 【对话策略模块】 该模块的主要功能是根据前面的对话状态决策采取的最优动作（如：提供结果，询问特定限制条件，澄清或确认需求等）从而最有效的辅助用户完成信息或服务获取的任务。该模块基于用户输入的语义表达和当前对话状态输出下一步的系统行为和更新的对话状态。 举例text=“人民币对美元的汇率是多少”。“查询（槽位1=人民币，槽位2=美元)”这样的形式将作为对话管理模块的输入，这时候状态追踪模块就要根据前几轮的信息，结合该输入判断该轮的查询状态，确定查询的槽位，以及与数据库的交互。如得到想要查询的确实是人民币对美元的汇率信息。这时候，根据现有的对话策略判断当前的槽位状态，最后给出对话管理模块的输出，如查询结果(源货币=人民币，目标货币=美元，汇率=1:0.16) 自然语言生成模块该模块主要任务是将对话策略输出的语义表达生成流畅可读的自然语言句子，反馈给用户。]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>多轮对话</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Finterview%2F</url>
    <content type="text"><![CDATA[[TOC] 数据结构排序总结 Java语法深拷贝与浅拷贝的区别Java8改进 Lambda表达式——为多核处理器编写代码 Nashorn引擎——使得Java程序和JavaScript代码互相操作 新日期API GC改进 并发改进 equals()和==的区别 equals() == 是方法 是操作符 判断两个变量指向的内存空间的值是否相等 用于判断两个变量是否指向同一个内存空间 对字符串内容进行比较 对内存地址进行比较 判断值是否相等 判断引用是否相同 HashTable和HashMap区别 HashTable HashMap 线程安全 线程不安全 不允许有null键和null值 允许有一个null键和多个null值 HashTable直接使用对象的HashCode。HashCode是JDK根据对象的地址或字符串或数字算出来的int类型的数值。 HashMap重新计算Hash值。 单线程下HashMap速度较快 HashMap与HashSet区别 HashMap HashSet 实现了Map接口 实现Set接口 存储键值对 存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 使用键对象计算HashCode值 使用成员对象计算HashCode值。对于两个对象来说HashCode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，返回fasle 相对HashSet速度比较快因为是使用唯一的键来获取对象 相对HashMap速度较慢 HashMap实现 结构实现 Hash Map是数组+链表+红黑树实现的（链表长度大于8时，转为红黑树）。 HashMap类中有一个非常重要的字段，是Node[] table,即哈希桶数组。Node是HashMap中的一个内部类，本质是一个映射（键值对）。如果哈希桶数组很大，即使很差的Hash算法也会比较分散。 HashMap是使用哈希表存储的，使用链地址法解决冲突。即数组+链表，每个数组元素上有一个链表结构，当数据被Hash以后，得到数组下标，把数据放在对应下表元素的链表上。 功能实现 根据key获取哈希桶数组索引位置 定位到哈希桶数组的位置是所有操作的第一步。 取key的HashCode值 h=key.hashcode() //取hashcode值 高位运算 h^(h&gt;&gt;&gt;16) //高位参与运算 取模运算 h&amp;(length-1) //取模运算，使用&amp;比%效率高 扩容过程 扩容的方法就是使用一个容量更大的数组代替已有的容量小的数组，然后将原有的数组元素复制到新的数组中。 JDK 1.8使用的是2次幂的扩展（即长度扩展为原来的2倍），所以元素位置是原位置或原位置移动2次幂的位置。 因此，在扩充hashmap时，不需要像jdk1.7重新计算hash，而是看新增的1bit位是0还是1，节省了时间。 jdk1.7扩充时，旧链表迁移到新链表时，如果新表的数组索引位置相同，则链表元素会倒置，jdk1.8不会。 HashMap的几个字段 length：Node[] table的初始化长度，默认值16 loadfactor：负载因子，默认值0.75 threshold：HashMap所能容纳的最大数据量的Node（键值对）的个数。 threshold=length*loadfactor，即定义好数组长度后，负载因子越大，所能容纳的键值对个数越多 size：HashMap中实际存在的键值对数量 【注】 数据结构Hash算法中负载因子的计算α=填入表中的记录个数/散列表的长度。 常见Hash函数： 直接定址法：h(key)=a*key+b 除留余数法：h(key)=key mod p HashTable的线程安全如何实现？两个对象的HashCode相同会发生什么？会发生碰撞，会存储在同一个位置的LinkedList中，键对象的equals()方法用来找到键值对。 如何让HashMap同步？使用Collections内部的SynchronizedMap类。 Java实现多线程的四种方式 继承Thread类 实现Runnable接口 实现Callable接口通过FutureTask包装器创建Thread线程 实现ExecutorService、Callable、Future接口 volatile关键字作用为什么使用线程池避免频繁地创建和销毁线程，达到线程对象的重用，使用线程池可以根据项目灵活控制并发的数目。 什么是乐观锁和悲观锁【乐观锁】 对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 【悲观锁】 对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 Lambda表达式优缺点【优点】 简洁 容易进行并行计算 Java运行过程Java源文件（.java文件）–&gt;Java编译器–&gt;字节码文件(.class文件)–&gt;类装载器–&gt;字节码校验器–&gt;解释器–&gt;操作系统整个文件Load到内存区，操作系统找到main()方法开始执行。 JNI使用步骤 在Java类中声明Native方法，并编译成class文件。 用javah，将上步中的class文件生成头文件。 用其他语言实现上述头文件的函数，生成动态库，供Java使用 发布Java和动态库。 JVMJVM原理操作系统装入JVM是通过JDK中Java.exe来完成，通过以下四个步骤完成JVM环境： 创建JVM装载环境和配置 装在JVM.dll 初始化JVM.dll并挂载到JNI调用接口实例。 调用JNI实例装载并处理class类。 JVM内存模型 程序计数器 作用：当前线程所执行的字节码的行号指示器。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要这个计数器来完成。 Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。在一个确定的时刻，一个cpu只会执行一条县城中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响 ，称这类内存区域是线程私有内存。 ​ 程序计数器用来记录一个线程的行号，字节码解释器在工作时，通过改变计数器的值取下一条语句指令。 程序计数器线程私有。一个线程有一个程序计数器。 在线程创建时创建，指向下一条指令的地址。 程序计数器是唯一一个在Java虚拟机中没有规定OutOfMemoryError的区域。 如果一个线程执行的是Java方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址。 如果执行的是Native方法，则计数器值为空。 Java虚拟机栈 线程私有。 生命周期与线程相同。 栈由一系列帧组成。因此Java栈也叫做帧栈。 帧保存一个方法的局部变量、操作数栈、常量池指针。 每个方法被执行时同时创建一个栈帧，并压栈，用于存储局部变量、操作栈、动态连接、方法出口等信息。 每一个方法被调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 对Java栈定义了两种异常： StackOverflowError：线程请求的栈深度大于虚拟机允许的深度 OutOfMemoryError：栈扩展时无法申请到足够内存 本地方法栈 为虚拟机使用到的Native方法服务。 两种异常：StackOverflowError和OutOfMemoryError。 Java堆 所有线程共享Java堆 在虚拟机启动时创建 所有对象实例及数组都分配在堆上。 堆是GC管理的主要区域 OutOfMemory：如果堆中没有内存完成对象实例分配，且堆也无法扩展时抛出该异常。 方法区 所有线程共享方法区。 存储已被虚拟机加载的类信息、常量、静态变量等。 本地方法栈和Java虚拟机栈区别 本地方法栈为虚拟机使用到的Native方法服务 虚拟机栈为虚拟机执行的Java方法服务 【注】有的虚拟机（如Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一。 Java内存分配机制 指在堆上的分配 分代分配 Eden区是连续的空间，且Survivor区总有一个为空。 在Eden区，HotSpot使用两种技术加快内存分配 bump-the-pointer：由于Eden区是连续的，因此bump-the-pointer就是跟踪最后一个创建的对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可。 TLAB(Thread-Local Allocation Buffers)，针对多线程而言，将Eden区分为若干段，每个线程使用独立的一段，避免互相影响。 TLAB结合bump-the-pointer，保证每个线程都使用Eden区的一段，并快速分配内存。 Java内存回收机制 分代分配 分配算法 新生代：复制算法 将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。 老年代：标记-整理算法 标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。 GC算法 标记-清除算法 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 【缺点】： 效率低 会产生大量的内存碎片。 复制算法 将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉。 【缺点】 浪费一半的内存空间 若对象的存活率很高，需要将所有存活的对象复制一遍，效率低。 标记-整理算法 标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。 【缺点】 效率不高 【总结】 效率：复制算法&gt;标记-整理算法&gt;标记-清除算法 内存整齐率：复制算法&gt;标记-整理算法&gt;标记-清除算法 内存利用率：标记-整理算法=标记-清除算法&gt;复制算法 Java8 JVM/CG改进 Java8中无持久代，被替换为元空间。 移除一些很少使用的GC组合 什么是元空间（Metaspace）？JDK8的HotSpot JVM移除永久代，使用本地内存来存储类的元数据（即一些描述性信息）的区域称为元空间。 【特点】 类及相关的元数据的生命周期与类加载器一致 每个加载器有专门的存储空间 省去GC扫描及压缩的时间 不会单独回收某个类 为什么移除永久代（PermGen），添加元空间（Metaspace）？ 字符串存在永久代中，容易出现性能问题和内存溢出 类及方法的信息等比较难确定大小，因此对永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易导致老年代溢出 永久代为GC带来不必要的复杂度，并且回收效率偏低。 了解JVM参数设置么，频繁出现GC怎么办？频繁GC原因： 人为原因 在代码中调用System.gc()或者Runtime.gc()方法。 System.gc()方法的调用是建议JVM进行Full GC，增加了Full GC的频率，即增加了间歇性停顿的次数。通过-XX:DisableExplicitGC禁止RMI调用System.gc()。 框架原因 在java程序调用相关框架时，框架内部调用了GC方法 内存原因 当Heap大小设置比较小时，会频繁引起GC。因此在Spark这样对内存性能要求比较高的应用程序运行时，可以分配给Heap较大的内存，减少频繁GC。 【参考】 JVM GC与频繁GC JVM频繁Full GC的情况及应对策略 如何调整内存中新生代和老年代的内存大小？可以在JVM参数中设置 -XX:NewSize=n：设置年轻代大小 -XX:NewRatio=n：设置年轻代和老年代的比值，默认是1：2 -XX:SurvivorRatio：设置Eden和From Survivor、To Survivor区比例。默认为8，即8:1:1。 -Xms：初始堆大小 -Xmx：最大堆大小 【参考】 java 虚拟机–新生代与老年代GC GC和Full GC有什么区别？ GC（Minor GC）：发生在新生代的GC，采用复制算法 Full GC（Major GC）：发生在老年代，采用标记-整理算法 Minor GC后，Eden是空的么？是，Minor GC后会把Eden中所有的活的对象移动到Survivor区域中，如果Survivor区中放不下，则剩下的活的对象被移动到Old Generation中。 如何判断一个对象是否存活？ 引用计数法 可达性算法（引用链法） Hadoop什么是Map-ReduceSparkSpark与Hadoop区别【共同点】 两者都是基于Map-Reduce模型来进行并行计算 【区别】 Hadoop有四个主要模块：Hadoop Common、HDFS、Hadoop YARN、Hadoop MapReduce。 Spark本身没有提供分布式文件系统，因此Spark的分析大多依赖于Hadoop的HDFS。 Hadoop的一个作业称为job，job里面分为map task和reduce task，每个task都是在自己的进程中运行的，当task结束，进程也会结束。 Spark提交的任务成为application，一个application对应一个sparkcontext，application中存在多个job，每触发一次action操作就会产生一个job。 Spark运行流程 构建Spark Application的运行环境，启动SparkContext SparkContext向资源管理器申请运行Executor资源，并启动StandaloneExecutorbackend Executor向SparkContext申请Task SparkContext将应用程序分发给Executor SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行 Task在Executor上运行，运行完释放所有资源。 Spark框架基本组件 Driver 【作用】运行Application的main函数并创建SparkContext。 创建SparkContext的目的是为了准备Spark应用程序的运行环境，在Spark中有SparkContext负责与ClusterManager通信，进行资源申请、任务分配和监控，当Executor部分运行完毕后，Driver同时负责将SparkContext关闭。 Master Worker Executor 【作用】执行器，在Worker上执行任务的组件、用于启动线程池运行任务。每个Application拥有独立的一组Executor。 Task Application的运行基本单位，Executor上的工作单元，其调度和管理由TaskScheduler负责。 RDD中的一个分区对应一个Task，Task是单个分区上最小的处理流程单元。 Spark中Application各个组件的关系 Application：用户编写的Spark应用程序，由一个或多个Job组成，提交到Spark之后，Spark为Application分派资源。 Task：RDD中的一个分区对应一个Task，Task是单个分区上最小的处理流程单元。 TaskSet：一组关联的，但相互之间没有Shuffle依赖关系的Task集合 Stage：由Action算子触发生成的由一个或多个Stage组成的计算作业 DAGScheduler：根据Job构建基于Stage的DAG，并提交Stage给TaskScheduler。 TaskScheduler：将Taskset提交给Worker结点集群运行并返回结果。 Spark中的RDD RDD RDD：弹性分布式数据集合，是spark的基本数据结构，spark中所有数据都是通过RDD形式组织。逻辑上是一个数据集，物理上以分块分布在不同机器上并发运行。 它代表一个不可变、可分区、里面的元素可并行计算的集合。 RDD允许用户在执行多个查询时显式地将工作集缓存在内存中。 RDD每个分区数据都是只读的 RDD生命周期：读取或创建RDD，然后对数据进行一系列的转换(transform算子)，保存结果，最后进行处理(action算子)。 RDD属性 一组分片（Partition），即数据集的基本组成单位。 对于RDD来说，每个分片会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，则会采用默认值，默认值即程序所分配到的CPU Core的数目。 一个计算每个分区的函数 Spark中RDD计算以分片为单位的，每个RDD都会实现compute函数达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。 RDD之间的依赖关系 RDD的每次转换都会生成一个新的RDD，所以RDD之间会形成类似于流水线一样的前后依赖关系，在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。 一个Partitioner，即RDD的分片函数 当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。 只有对于key-value的RDD，才会有Partitioner，非key-value的RDD的Partitioner的值是None. Partitoner函数决定了RDD本身的分片数量，也决定了parent RDD Shuffer输出时的分片数量。 一个列表，存储存取每个Partition的优先位置（preferred location） 对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。 算子 转换算子(transform) 不触发提交作业，完成作业中间处理过程。 分为value类型和key-value类型。 所有的转换都是惰性的，不会马上计算结果，当action算子执行时，才会计算transform算子。 动作算子(action) 触发SparkContext提交作业，常见的有count、collection。 Spark运行模式有几种？ standalone(独立集群运行模式) 独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。 不使用其他调度工具时会存在单点故障，可使用Zookeeper解决。 Spark on YARN Spark on Mesos 通用集群管理，有粗粒度模式和细粒度模式 Spark是多线程模式，怎么退化为多进程模式？在每个executor core设置为1，即每个executor为单线程。 什么是Shuffle,具体过程怎么样，有几种方式？【Shuffle】 Shuffle是MapReduce框架中的一个特定的phase，描述数据从Map到Reduce的过程，当Map的输出结果要被Reduce使用时，输出结果按key哈希，并分发到每一个Reducer上。因为Shuffle涉及到磁盘读写和网络传输，因此Shuffle性能的高低直接影响了整个程序性能和吞吐量。 【过程】 首先每一个Mapper会根据Reducer的数量创建出相应的bucket。 Mapper产生的结果会根据设置的partition算法填充到每个bucket中。默认的partition算法是根据key哈希到不同的bucket中去。 当Reducer启动时，会根据自己的task的id和所依赖的Mapper的id从远端或本地的block manager获取相应的bucket作为Reducer的输入进行处理。 Shuffle过程的本质是将Map端获得的数据使用partition算法进行划分，并将数据发送给对应的Reducer。 什么是数据倾斜，如何处理？【数据倾斜】 并行处理的数据集中，有一部分的数据显著多于其它部分，从而使得处理该部分的数据处理速度成为数据集处理的瓶颈。 【原因】 常见于各种Shuffle操作，如reduceByKey、groupByKey、join等。 数据问题 key本身分布不均匀（包括大量的key为空） key的设置不合理 spark使用问题 shuffle时的并发度不够 计算方式有误 【解决方法】 数据问题造成的数据倾斜 找出异常的key 如果任务长时间卡在最后几个任务，对key进行抽样分析，判断是哪些key造成的。 spark使用不当造成的数据倾斜 提高shuffle并行度 dataFrame和sparkSql可以设置spark.sql.shuffle.partition参数控制shuffle的并发度。 RDD操作可以设置spark.default.parallelism控制并发度。 使用map join代替reduce join 在小表不是特别大(取决于你的executor大小)的情况下使用，可以使程序避免shuffle的过程，自然也就没有数据倾斜的困扰了。 MLlib支持的算法有哪些？分类、聚类、回归、协同过滤。 Spark统计词频程序计算机网络TCP三次握手 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 Linux常用命令机器学习线性回归什么是线性回归？线性回归的因变量是连续变量，自变量可以是连续变量，也可以是分类变量。 逻辑回归什么是逻辑回归？逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。 【基本假设】 逻辑回归的第一个基本假设是假设数据服从伯努利分布。$$h_\theta\left(x;\theta \right )=\frac{1}{1+e^{-\theta^{T} x}}$$【损失函数】 逻辑回归的损失函数是它的极大似然函数$$L\theta\left(x\right )= \prod {i=1}^{m}h\theta(x^{i};\theta )^{y{i}}*(1-h\theta(x^{i};\theta))^{1-y^{i}}$$ 为什么逻辑回归的损失函数使用极大似然函数作为损失函数 损失函数一般有四种，平方损失函数，对数损失函数，HingeLoss0-1损失函数，绝对值损失函数。将极大似然函数取对数以后等同于对数损失函数。在逻辑回归这个模型下，对数损失函数的训练求解参数的速度是比较快的。 为什么不选平方损失函数的呢？其一是因为如果你使用平方损失函数，你会发现梯度更新的速度和sigmod函数本身的梯度是很相关的。sigmod函数在它在定义域内的梯度都不大于0.25。这样训练会非常的慢。 为什么在训练过程中将高度相关的特征去掉？ 去掉高度相关的特征会让模型的可解释性更好 可以大大提高训练的速度。如果模型当中有很多特征高度相关的话，就算损失函数本身收敛了，但实际上参数是没有收敛的，这样会拉低训练的速度。其次是特征多了，本身就会增大训练的时间。 数学推导NLP中文特点 汉语是大字符集的意音文字 词与词之间没有空格 同义、同音词多 没有形态变化 中文分词 基于字符串匹配的分词方法 按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行配，若在词典中找到某个字符串，则匹配成功（识别出一个词） 正向最大匹配 （从左到右方向） 选取包含6到8个汉字的符号串作为最大符号串，把最大符号串与词典中的单词条目匹配，如果不能匹配，削掉最右边的一个汉字继续匹配，直到在词典中找到相应的单词为止，匹配的方法从右向左。 逆向最大匹配（从右到左方向） 最小切分（每一句中切出的词数最小） 双向最大匹配 （从左到右、从右到左两次扫描） 基于统计的分词方法 N元文法模型（N-gram） 隐马尔可夫模型（HMM） 最大熵模型（ME） 条件随机场模型（CRF） 【注】 实际应用中，基于统计的分词系统都需要分词词典来进行字符串匹配，同时使用统计方法识别一些新词，即将字符串频率统计和字符串匹配结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。 Word2Vec【两种模型】 CBOW（连续词袋） 无隐层 使用双向上下文窗口 上下文词序无关 输入层直接使用低维稠密表示 输入层、映射层、输出层 输入层即某个单词周围的n-1个单词词向量。 映射层到输出层。需要借助Huffman树，从根节点开始，映射层的zhi需要huffman树不断进行logistic分类。 Skip-Gram 无隐层 投影层也可以省略 每个词向量作为log-linear模型的输入 【两种算法】 层次Softmax 采用Huffman树来编码输出层的词典 只需要计算路径上所有非叶子结点的词向量即可。 负例采样 ​ LDA最大熵模型 最大熵原理指出，当我们需要对一个随机事件的概率分布预测的时候，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。在这种情况下，概率分布最均匀，预测的风险最小。因为这时的概率分布的信息熵最大，所以这种模型叫做“最大熵模型”。即遇到不确定性时，保留各种可能性。 产生式模型和判别式模型对于输入x，类别标签y 产生式模型：估计它们的联合概率分布，如HMM、Naive Bayes、BNs、MRF 判别式模型：估计条件概率分布，如SVM、CRF、LR、Boosting、Neural Networks 生成式模型：有多个模型（一般有多少类就有多少个），把测试用例分别丢给各个模型，最后比较得出最佳结果。 判别式模型：只有一个模型，把测试用例丢给模型，直接得出结果。 【联系】 由生成模型可以得到判别模型，但由判别模型无法得到生成模型 概率图模型【定义】 【分类】 根据途中边有无方向，分为两类： 有向图：贝叶斯网络 无向图：马尔科夫随机场（MRF） HMM CRF【特征函数】 在CRF中，每个特征函数以以下信息作为输入 一个句子s 词在句子中的位置i 当前词的标签 前一个词的标签 输出：一个实数值（一般0 或1） 【应用】 分词（标注字的词位信息，由字构词） 词性标注（标注分词的词性） 命名实体识别 知识图谱实体对齐（同义词关系学习） 从开放链接数据中抽取同意关系 同一百科中的实体对齐 重定向 信息模块：中文别称、别名 不同百科间的实体对齐 名称匹配 基于SVM的自监督百科实体对齐方法（百科间实体） 基于CRF的开放同义关系学习]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装python3]]></title>
    <url>%2Fcentos-install-python%2F</url>
    <content type="text"><![CDATA[下载安装包 sudo wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz 解压 sudo tar -xvJf Python-3.6.2.tar.xz 进入到解压后的Python-3.6.2文件夹 编译安装 sudo ./configure --prefix=xxxxmake &amp;&amp; make install 【注】prefix后是Python-3.6.2的解压路径的父目录 添加软连接到执行目录/usr/bin ln -s xxx/bin/python3 /usr/bin/python3ln -s xxx/bin/pip3 /usr/bin/pip3 【注】xxx代表python的安装路径，即步骤四的prefix后的路径]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】LeetCode总结]]></title>
    <url>%2Falgorithm-leetcode%2F</url>
    <content type="text"><![CDATA[[TOC] 位运算371.两整数之和【题目描述】 不使用运算符 + 和-，计算两整数a 、b之和。 示例：若 a = 1 ，b = 2，返回 3。 【思路】 使用位运算，异或+移位。 【题解】 int getSum(int a, int b) &#123; while (b != 0) &#123; int c = a ^ b; b = (a &amp; b) &lt;&lt; 1; a = c; &#125; return a;&#125; 数1.两数之和#include&lt;unordered_map&gt;class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; um; int n=nums.size(); vector&lt;int&gt; result; for(int i=0;i&lt;n;i++)&#123; if(um.find(target-nums[i]) != um.end())&#123; result.push_back(um[target-nums[i]]); result.push_back(i); &#125;else um[nums[i]]=i; &#125; return result; &#125;&#125;; 7.反转整数int reverse(int x) &#123; long long ret=0; int sign=1; if(x&lt;0)&#123; sign=-1; x=-x; &#125; while(x)&#123; ret=ret*10+x%10; x/=10; &#125; if(ret&gt;INT_MAX || ret&lt;INT_MIN) return 0; return sign*ret;&#125; int reverse(int x) &#123; long long result=0; bool isPositive=true; if(x&lt;0)&#123; isPositive=false; x=-x; &#125; while(x&gt;0)&#123; result=result*10+x%10; x/=10; &#125; if(result&gt;INT_MAX) return 0; if(!isPositive) return -result; return result;&#125; 9.回文数【题目描述】 判断一个数是否是回文数 【思路】 直接判断不是回文数的情况 负数 个位为0（0这个数除外，如果是0也返回true） 否则用一个数字记录它逆转的一半，与其另一半做比较，查看是否相等。 【题解】 bool isPalindrome(int x) &#123; if(x&lt;0 || (x!=0 &amp;&amp; x%10==0)) //负数或者个位数为0 return false; int sum=0; //记录逆转的一半 while(x&gt;sum)&#123; sum=sum*10+x%10; x/=10; &#125; return x==sum || x==(sum/10); //包含数字位数是奇数和偶数两种情况&#125; 15.三数之和【题目描述】 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 【思路】 48.旋转图像【题目描述】 给定一个 n n* 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 【思路】 通过两个步骤的元素交换 按照副对角线翻转一次 按照水平中线翻转一次 【题解】 void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n=matrix.size(); if(n&lt;=0) return ; //按副对角线旋转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n-i;j++)&#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-1-j][n-1-i]; matrix[n-1-j][n-1-i]=tmp; &#125; &#125; //按水平中心旋转 for(int i=0;i&lt;n/2;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-1-i][j]; matrix[n-1-i][j]=tmp; &#125; &#125;&#125; 118.帕斯卡三角形【题目描述】 给定 numRows, 生成帕斯卡三角形的前 numRows 行。 例如, 给定 numRows = 5, 返回 [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 【思路】 n行有n个数 每个数字等于上一行的左右两个数字之和，即第n+1行的第i个数等于第n行的第i-1个数和第i个数之和。 【题解】 vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(numRows==0) return ret; vector&lt;int&gt; last(1,1);//初始化1个值为1的元素 ret.push_back(last); for(int i=2;i&lt;=numRows;i++)&#123; last.push_back(0);//补齐下一位 vector&lt;int&gt; cur=last; for(int j=1;j&lt;i;j++)//第一位都为1，因此从第二位开始 cur[j]=cur[j]+last[j-1]; ret.push_back(cur); last=cur; &#125; return ret; &#125; 169.求众数【题目描述】 给定一个大小为 n的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 【思路】 数组中有一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。 在遍历数组的时候保存两个值 一个是数组中的数字，一个是次数 如果下一个数字和我们之前保存的数字相同，则次数加1 如果下一个数字和我们之前保存的数字不同，则次数减1 如果次数为0，则保存下一个数字，并把次数设为1。 【题解】 int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;=0) return 0; int ret=nums[0]; int times=1; for(int i=1;i&lt;len;i++)&#123; if(ret==nums[i]) times++; else times--; if(times==0)&#123; ret=nums[i]; times=1; &#125; &#125; times=0; for(int i=0;i&lt;len;i++) if(nums[i]==ret) times++; return (times&gt;len/2)?ret:0;&#125; 189.旋转数组【题目描述】 将包含n 个元素的数组向右旋转 k 步。 例如，如果 n = 7 , k = 3，给定数组 [1,2,3,4,5,6,7] ，向右旋转后的结果为 [5,6,7,1,2,3,4]。 【思路】 旋转左部分 旋转右部分 整体旋转 【题解】 void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int len=nums.size(); k=k%len; if(k==0) return ; reverse(nums,0,len-k-1); reverse(nums,len-k,len-1); reverse(nums,0,len-1);&#125;void reverse(vector&lt;int&gt; &amp;nums,int from,int to)&#123; while(from&lt;to)&#123; int tmp=nums[from]; nums[from++]=nums[to]; nums[to--]=tmp; &#125;&#125; 233.数字1的个数【题目描述】 给定一个整数 n，计算所有小于等于 n 的非负数中数字1出现的个数。 例如： 给定 n = 13， 返回 6，因为数字1出现在下数中出现：1，10，11，12，13。 【思路】 628.三个数的最大乘积数组88.合并两个有序数组【题目描述】 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 【思路】 两个数组从后往前比较。 【题解】 void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n)&#123; int i=m-1;//nums1数字长度最后一位 int j=n-1;//nums2最后一位 int k=m+n-1;//nums1+nums2数字长度 while(i&gt;=0 &amp;&amp; j&gt;=0)&#123; if(nums1[i]&lt;nums2[j]) nums1[k--]=nums2[j--]; else nums1[k--]=nums1[i--]; &#125; //如果nums2还没结束，则把剩下的直接复制到nums1，因为剩下的nums2已经有序 while(j&gt;=0) nums1[k--]=nums2[j--];&#125; 283.移动零【题目描述】 给定一个数组 nums, 编写一个函数将所有 0 移动到它的末尾，同时保持非零元素的相对顺序。 例如， 定义 nums = [0, 1, 0, 3, 12]，调用函数之后， nums 应为 [1, 3, 12, 0, 0]。 注意事项: 必须在原数组上操作，不要为一个新数组分配额外空间。 尽量减少操作总数。 【思路】 对原数组进行遍历，把非零值放在前面，空出后面的位置存放0。 【题解】 void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;0) return ; int index=0; for(int i=0;i&lt;len;i++)&#123; if(nums[i]) nums[index++]=nums[i]; &#125; for(int i=index;i&lt;len;i++) nums[i]=0;&#125; 414.第三大的数解法1【思路】 用set，避免同一元素出现多次 定义反向迭代器，之后判断set中有多少个元素，小于三个时直接返回最大值，否则反向迭代就可以找到第三大的值了 时间复杂度是O(n) 【题解】 int thirdMax(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; num; for(int i=0;i&lt;nums.size();i++) &#123; num.insert(nums[i]); &#125; set&lt;int&gt;::reverse_iterator it=num.rbegin(); if(num.size()&lt;3) return *it; it++; it++; return *it; &#125; 解法2【思路】 设置n1=第3大的数，n2=第2大的数，n3=最大数，最后返回n1，遍历一次即可。 【题解】 int thirdMax(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); if(!n) return 0; if(n==1) return nums[0]; else if(n==2) return max(nums[0],nums[1]); int n1=min(nums[0],min(nums[1],nums[2])),n2=max(nums[0],min(nums[1],nums[2])),n3=max(nums[0],max(nums[1],nums[2])); for(int i=3;i&lt;n;i++) &#123; if(nums[i]&gt;n3) &#123; n1=n2; n2=n3; n3=nums[i]; &#125; else if(nums[i]&gt;=n2) &#123; n2=nums[i]; &#125;else if(nums[i]&gt;n1) n1=nums[i]; &#125; return n1; &#125; 字符串5.最长回文子串【思路】 动态规划方法。 动态规划问题的特点： 大问题拆解为小问题 重复利用之前的计算结果 根据回文的特性，一个大回文按比例缩小之后的字符串必定也是回文。 具体的递归方法有多种，这里选取两种递归方法。 解法1 dp[i][j]表示字符串区间[i,j]是否为回文串 当j=i时，只有一个字符，肯定是回文串 当j=i+1时，说明是相邻字符，需要判断s[i]是否等于s[j] 当j&gt;i+1时，说明是不相邻字符，除了判断s[i]和s[j]相等之外，dp[i+1][j-1]若为真，则是回文串，即字符串区间左侧+1，右侧-1。 根据以上分析，写出状态转移方程 $$\begin{equation}dp[i][j]=\left{\begin{aligned}1&amp; &amp; (i=j) \=(s[i]==s[j]) &amp; &amp; (j=i+1) \=(s[i]==s[j] \&amp;\&amp;dp[i+1][j-1]) &amp;&amp;(j&gt;i+1)\end{aligned}\right.\end{equation}$$ 【题解】 （未理解） string longestPalindrome(string s) &#123; int dp[s.size()][s.size()]=&#123;0&#125;; int len=0;//最长回文子串的长度 int start=0;//最长回文子串的起点 for(int j=0;j&lt;s.size();j++)&#123; for(int i=0;i&lt;j;i++)&#123; dp[j][j]=1;//边界条件 //状态转移方程的二三个情况合写 dp[i][j]=(s[i]==s[j] &amp;&amp; (j-i&lt;=1 || dp[i+1][j-1])); if(dp[i][j] &amp;&amp; len&lt;j-i+1)&#123; len=j-i+1; start=i; &#125; &#125; &#125; return s.substr(start,len); &#125; 解法2 【思路】 dp[i][j]表示s[i]到s[j]所表示的子串是否为回文子串，是则为1，不是为0. 若s[i]==s[j]， 若s[i+1]到s[j-1]是回文子串，s[i]到s[j]就是回文子串。 若s[i+1]到s[j-1]不是回文子串，s[i]到s[j]则不是回文子串。 若s[i]!=s[j]，则s[i]到s[j]一定不是回文子串。 状态转移方程$$\begin{equation}dp[i][j]=\left{\begin{aligned}dp[i+1][j-1]&amp; &amp; s[i]==s[j] \0 &amp; &amp; s[i]!=s[j]\ \end{aligned}\right.\end{equation}$$​ 边界：dp[i][i]=1，dp[i][i+1]=(s[i]==s[i+1]?1:0) ​ 8.字符串转整数（atoi）【思路】 字符串格式的合法判断 空格不计入计算，从第一个非空字符开始判断， 首字母只能是+、-或数字 转换结果的溢出判断 Int类型范围是INT_MIN(-2147482648)到INT_MAX(2147483647)，超出范围则返回最大与最小值。因此使用long long 类型变量储存结果。 如果正确的值超过的可表示的范围，则返回 INT_MAX（2147483647）或 INT_MIN（-2147483648）。 如果不能执行有效的转换，则返回 0。 字符串可以在形成整数的字符后包括多余的字符，将这些字符忽略，这些字符对于函数的行为没有影响。 【题解】 int myAtoi(string str) &#123; if(str.length()==0) return 0; int index=0; int sign=1; long long result=0; while(str[index]==' ') index++; if(str[index]=='+') index++; else if(str[index]=='-')&#123; sign=-1; index++; &#125; for(;index&lt;str.length();index++)&#123; if(str[index]&gt;='0' &amp;&amp; str[index]&lt;='9')&#123; result=result*10+(str[index]-'0'); if(result&gt;INT_MAX) return sign&gt;0?INT_MAX:INT_MIN; &#125;else break; &#125; result*=sign; return (int)result;&#125; 14.最长公共前缀【题目描述】 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 输入: ["flower","flow","flight"]输出: "fl" 示例 2: 输入: ["dog","racecar","car"]输出: ""解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 【思路】 67.二进制求和【题目描述】 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = "11", b = "1"输出: "100" 示例 2: 输入: a = "1010", b = "1011"输出: "10101" 【思路】 用0补齐较短字符串左侧至两字符串相等，然后相加即可。 【题解】 未通过 string addBinary(string a, string b) &#123; string result=""; int len1=a.size(); int len2=b.size(); int carry=0; while(len1&gt;len2)&#123; b='0'+b; len2++; &#125; while(len2&gt;len1)&#123; a='0'+b; len1++; &#125; while(len1)&#123; len1--; int tmp=(a[len1]-'0')+(b[len1]-'0')+carry; result=to_string(carry%2)+result; carry=tmp/2; &#125; //如果最后一位有进位，单独处理 if(carry)&#123; result[0]='0'; result='1'+result; &#125; return result; &#125; 通过 string addBinary(string a, string b) &#123; bool flag = false; int aSize = a.size(); int bSize = b.size(); while(aSize&gt;bSize)&#123; b = '0' + b; bSize++; &#125; while(bSize&gt;aSize)&#123; a = '0' + a; aSize++; &#125; string result = ""; while(aSize)&#123; aSize--; if(flag)&#123; if((a[aSize] - '0')^(b[aSize]-'0'))&#123; result = '0' + result; &#125; else if((a[aSize]-'0')&amp;&amp;(b[aSize]-'0'))&#123; result = '1' + result; &#125;else&#123; result = '1' + result; flag = false; &#125; &#125;else&#123; if((a[aSize]-'0')^(b[aSize]-'0')) result = '1' + result; else if((a[aSize]-'0')&amp;&amp;(b[aSize]-'0'))&#123; flag = true; result = '0' + result; &#125;else&#123; result = '0' + result; &#125; &#125; &#125; if(flag) result = '1' + result; return result; &#125; 125.验证回文字符串【思路】 使用一头一尾两个指针，反方向判断是否一一满足即可。 【题解】 bool isAlphanumeric(const char c) &#123; if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') return true; else if ('a' &lt;= c &amp;&amp; c &lt;= 'z') return true; else if ('0' &lt;= c &amp;&amp; c &lt;= '9') return true; return false;&#125;char toLower(const char c)&#123; if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') return 'a' + c - 'A'; return c;&#125;bool isPalindrome(string s)&#123; if (s.empty()) return true; int begin = 0; int end = s.size() - 1; while (true) &#123; while (begin &lt; s.size() &amp;&amp; !isAlphanumeric(s[begin])) begin++; while (end &gt;= 0 &amp;&amp; !isAlphanumeric(s[end])) end--; if (end &lt;= begin) return true; if (toLower(s[begin]) != toLower(s[end])) return false; begin++; end--; &#125;&#125; ###242.有效的字母异位词 【问题描述】 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 例如，s = “anagram”，t = “nagaram”，返回 trues = “rat”，t = “car”，返回 false 【思路】 求每个字符个数判别是否相等。 【题解】 bool isAnagram(string s, string t) &#123; vector&lt;int&gt; count(26,0); int len1=s.size(); int len2=t.size(); //如果两个字符串长度不同，直接返回false if(len1!=len2) return false; //词频统计 for(int i=0;i&lt;s.size();i++) count[s[i]-'a']++; for(int i=0;i&lt;t.size();i++) count[t[i]-'a']--; for(int i=0;i&lt;count.size();i++)&#123; if(count[i] != 0) return false; &#125; return true;&#125; 387.字符串中的第一个唯一字符【问题描述】 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: s = "leetcode"返回 0.s = "loveleetcode",返回 2. 【思路】 字频统计 找出第一个出现次数为1的字符 【题解】 int firstUniqChar(string s) &#123; vector&lt;int&gt; count(26,0); for(int i=0;i&lt;s.size();i++)&#123; count[s[i]-'a']++; &#125; for(int i=0;i&lt;s.size();i++)&#123; if(count[s[i]-'a']==1) return i; &#125; return -1;&#125; 409 Longest Palindrome链表2.两数相加【题目描述】 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 【思路】 遍历两个链表。 将两个结点的值相加，大于10的值进位，放入结果链表中。记录除数和余数。 【题解】 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if(!l1 || !l2 ) return NULL; ListNode *head=new ListNode(-1); ListNode *p=head; int carry=0; while(l1 || l2 || carry)&#123; int tmp=(l1?l1-&gt;val:0)+(l2?l2-&gt;val:0)+carry; p-&gt;next=new ListNode(tmp%10);//tmp%10用来记录相加后的数。 carry=tmp/10;//carry的范围最大不超过18，因此可用来记录进位。 p=p-&gt;next; l1=l1?l1-&gt;next:l1; l2=l2?l2-&gt;next:l2; &#125; return head-&gt;next;&#125; 21.合并两个有序链表【题解】 ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1==NULL &amp;&amp; l2==NULL) return NULL; ListNode *result; if(l1-&gt;val&lt;l2-&gt;val)&#123; result=l1; result-&gt;next=mergeTwoLists(l1-&gt;next,l2); &#125;else&#123; result=l2; result-&gt;next=mergeTwoLists(l1,l2-&gt;next); &#125; return result; &#125; 24.两两交换链表中的结点【题目描述】 【思路】 【题解】 ListNode* swapPairs(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *dummy=new ListNode(-1); dummy-&gt;next=head; ListNode *pre=dummy; ListNode *cur=head; while(cur&amp;&amp;cur-&gt;next)&#123; pre-&gt;next=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; pre-&gt;next-&gt;next=cur; pre=cur; cur=cur-&gt;next; &#125; return dummy-&gt;next;&#125; 61.旋转链表【题目描述】 给定一个链表，旋转链表，将链表每个节点向右移动 k个位置，其中k是非负数。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 【思路】 先计算链表长度，然后从头遍历链表直到倒数第k个点，即原链表倒数k个元素成为新链表的前部分，原链表的前(len-k)个元素成为新链表的后部分。 【题解】 ListNode* rotateRight(ListNode* head, int k) &#123; if(!head || !head-&gt;next) return head; int len=0; ListNode *p=head; while(p)&#123; len++; p=p-&gt;next; &#125; k%=len; if(k&lt;=0) return head; int index=1;//记录新链表的位置 p=head; //寻找右旋k个位置后，新链表的首个结点 while(index&lt;(len-k) &amp;&amp; p-&gt;next)&#123; index++; p=p-&gt;next; &#125; ListNode *ret=p-&gt;next; ListNode *q=p; //原链表寻找尾结点，将其链接到head while(p-&gt;next) p=p-&gt;next; p-&gt;next=head; //前部分尾结点设为NULL q-&gt;next=NULL; return ret;&#125; 82.删除排序链表中的重复元素Ⅱ【题目描述】 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 【题解】 ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode *dummy=new ListNode(-1); ListNode *p=dummy; ListNode *q=head; while(q)&#123; while(q &amp;&amp; q-&gt;next &amp;&amp; q-&gt;next-&gt;val == q-&gt;val)&#123; int tmp = q-&gt;val; while(q &amp;&amp; q-&gt;val==tmp) q=q-&gt;next; &#125; p-&gt;next=q; p=p-&gt;next; if(q) q=q-&gt;next; &#125; return dummy-&gt;next;&#125; 83.删除排序链表中的重复元素【题目描述】 给定一个排序链表，删除所有重复的元素使得每个元素只留下一个。 【题解】 ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode *p=head; while(p &amp;&amp; p-&gt;next)&#123; if(p-&gt;val == p-&gt;next-&gt;val) p-&gt;next=p-&gt;next-&gt;next; else p=p-&gt;next; &#125; return head;&#125; 86.分隔链表【题目描述】 给定一个链表和一个特定值x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x* 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 【思路】 在数组partition中，一般是通过首尾两个指针来进行前后遍历以及交换； 而在链表中，不需要进行元素的交换，可以通过创建两个新的头结点指针，来分别指向小于x的结点和大于等于x的结点，遍历结束之后，再将两个新的链表重新连接起来。 【题解】 141.环形链表【题目描述】 给定一个链表，判断链表中否有环。 【题解】 bool hasCycle(ListNode *head) &#123; if(head==NULL||head-&gt;next==NULL) return false; ListNode *slowP=head; ListNode *fastP=head; while(fastP&amp;&amp;fastP-&gt;next)&#123; fastP=fastP-&gt;next-&gt;next; slowP=slowP-&gt;next; if(slowP==fastP) return true; &#125; return false;&#125; 142.环形链表Ⅱ【题目描述】 给一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 【题解】 ListNode *detectCycle(ListNode *head) &#123; bool isCycle=false; if(head==NULL||head-&gt;next==NULL) return NULL; ListNode *slowP=head; ListNode *fastP=head; while(fastP-&gt;next!=NULL&amp;&amp;fastP-&gt;next-&gt;next!=NULL)&#123; fastP=fastP-&gt;next-&gt;next; slowP=slowP-&gt;next; if(slowP==fastP)&#123; isCycle=true; break; &#125; &#125; if(isCycle)&#123; fastP=head; while(slowP!=NULL&amp;&amp;fastP!=NULL&amp;&amp;fastP!=slowP)&#123; slowP=slowP-&gt;next; fastP=fastP-&gt;next; &#125; return slowP; &#125;else return NULL;&#125; 143.重排链表【题目描述】 【思路】 使用快慢指针将链表从中间分割成两段 后半段就地逆置 合并插入到前半段链表即可。 时间复杂度O(n). 【题解】 void reorderList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return ; ListNode *slow=head; ListNode *fast=head; ListNode *pre=NULL; while(fast &amp;&amp; fast-&gt;next)&#123; pre=slow; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; pre-&gt;next=NULL;//从中间切分 ListNode *rHead=reverse(slow);//rHead是逆置后的头结点 //合并两个链表 ListNode *cur = head; while (cur-&gt;next) &#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = rHead; rHead= rHead-&gt;next; cur-&gt;next-&gt;next = tmp; cur = tmp; &#125; cur-&gt;next = rHead; //链接上最后一个元素&#125; ListNode* reverse(ListNode *head)&#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode *pre=NULL; ListNode *next=NULL; while(head)&#123; next=head-&gt;next; head-&gt;next=pre; pre=head; head=next; &#125; return pre;&#125; 147.链表插入排序【题目描述】 用插入排序对链表进行排序。 【思路】 插入排序的链表实现版。 新建一个头结点，来保存排序后的链表。 【题解】 ListNode* insertionSortList(ListNode* head) &#123; //边界条件判断 if(head==NULL || head-&gt;next==NULL) return head; //创建一个新的链表头部 ListNode *sortedHead=new ListNode(-1); //排序后的链表当前结点 ListNode *cur=sortedHead; ListNode *p=head; while(p!=NULL)&#123; cur=sortedHead; //寻找插入点 while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val&lt;p-&gt;val) cur=cur-&gt;next; //保存原链表当前结点的next域 ListNode *tmp=p-&gt;next; //插入结点 p-&gt;next=cur-&gt;next; cur-&gt;next=p; //移动到原链表的下一个位置 p=tmp; &#125; return sortedHead-&gt;next;&#125; 160.相交链表【题目描述】 找到两个单链表相交的起始结点 【题解】 int GetLength(ListNode *head)&#123; int len=0; ListNode *s=head; while(s)&#123; s=s-&gt;next; len++; &#125; return len;&#125;ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)&#123; if(!headA||!headB) return NULL; int len1=GetLength(headA); int len2=GetLength(headB); int diff=len1-len2; ListNode *fast=NULL; ListNode *slow=NULL; if(diff&gt;0)&#123; fast=headA; slow=headB; &#125;else&#123; fast=headB; slow=headA; diff=-diff; &#125; for(int i=0;i&lt;diff;i++)&#123; fast=fast-&gt;next; &#125; while(fast &amp;&amp; slow &amp;&amp; fast!=slow)&#123; fast=fast-&gt;next; slow=slow-&gt;next; &#125; return fast;&#125; 203.删除链表中的元素【题目描述】 删除链表中等于给定值 val 的所有元素。 【题解】 ListNode* removeElements(ListNode* head, int val) &#123; if(head==NULL) return NULL; ListNode *p=head; ListNode *pre=NULL; while(p)&#123; if(p==head &amp;&amp; p-&gt;val==val)&#123; p=p-&gt;next; delete head; head=p; &#125;else if(p-&gt;val==val)&#123; pre-&gt;next=p-&gt;next; delete p; p=pre-&gt;next; &#125;else&#123; pre=p; p=p-&gt;next; &#125; &#125; return head;&#125; 206.反转链表【思路】 即链表逆置 【题解】 ListNode* reverseList(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return head; ListNode *pre=NULL; ListNode *next=NULL; while(head)&#123; next=head-&gt;next; head-&gt;next=pre; pre=head; head=next; &#125; return pre;&#125; 234.回文链表解法1【思路】 将链表后半段翻转 寻找链表中分界点的方法是：快慢指针法，fast指针一次走两步，slow指针一次走一步 当遍历结束时，如果链表长度是奇数，则slow刚好在中间，若链表长度是偶数，则slow在中间前一个。 将前半段与后半段比较 时间复杂度O(n) 【题解】 bool isPalindrome(ListNode* head) &#123; //如果是空或者是只有一个，必定是回文链表，返回true if(head==NULL || head-&gt;next==NULL) return true; ListNode *slow=head; ListNode *fast=head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; //rHead是逆转后的头结点 ListNode *rHead=slow; //如果链表长度是奇数，则rHead在中间；如果链表长度是偶数，则rHead在中间前一个。 //不论链表长度是奇数还是偶数，只需要一种情况处理。 //如1234321，slow在4上，只需要判断123和321相同即可。 //如123321，长度是偶数，slow在第一个3上，判断123和321是否相同即可。 rHead=reverse(rHead-&gt;next); while(rHead)&#123; if(rHead-&gt;val != head-&gt;val) return false; rHead=rHead-&gt;next; head=head-&gt;next; &#125; return true; &#125; ListNode* reverse(ListNode *head)&#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode *pre=NULL; ListNode *next=NULL; while(head)&#123; next=head-&gt;next; head-&gt;next=pre; pre=head; head=next; &#125; return pre; &#125; 解法2【思路】 用一个vector把链表里的值一次性push进去。 遍历vector，判断v[i]与v[v.size()-i-1]是否相等 不相等，直接返回false 遍历结束，返回true 【题解】 bool isPalindrome(ListNode* head) &#123; vector&lt;int&gt;v; while (head!=NULL)&#123; v.push_back(head-&gt;val); head = head-&gt;next; &#125; for (int i = 0; i &lt; v.size() / 2;i++)&#123; if (v[i] != v[v.size() - i - 1]) return false; &#125; return true; &#125; 328.Odd Even Linked List【题目描述】 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 【思路】 定义两个链表，奇数链表和偶数链表 用两个指针遍历链表，每次遍历两个结点（奇数结点和偶数结点），然后将偶数链表的头部接在奇数链表的尾部。 ListNode* oddEvenList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode *oddHead=head; //奇数链表头 ListNode *evenHead=head-&gt;next;//偶数链表头 ListNode *curOdd=oddHead;//当前奇数指针 ListNode *curEven=evenHead;//当前偶数指针 while(curEven &amp;&amp; curEven-&gt;next)&#123; curOdd-&gt;next=curEven-&gt;next; curOdd=curOdd-&gt;next; curEven-&gt;next=curOdd-&gt;next; curEven=curEven-&gt;next; &#125; curOdd-&gt;next=evenHead;//偶数链表的头部接在奇数链表的尾部 return oddHead;&#125; 树94.中序遍历二叉树【题解】 vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if(!root) return result; stack&lt;TreeNode*&gt; s; TreeNode *p=root; while(!s.empty()||p)&#123; while(p)&#123; s.push(p); p=p-&gt;left; &#125; if(!s.empty())&#123; p=s.top(); s.pop(); result.push_back(p-&gt;val); p=p-&gt;right; &#125; &#125; return result;&#125; 102.二叉树的层序遍历【题目描述】 给定一个二叉树，返回其按层次遍历的节点值。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / \9 20 / \ 15 7 返回其层次遍历结果为： [ [3], [9,20], [15,7]] 【题解】 vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(!root) return result; queue&lt;TreeNode*&gt; q; TreeNode *p=root; vector&lt;int&gt; levelResult; q.push(p); while(!q.empty())&#123; levelResult.clear(); int size=q.size(); for(int i=0;i&lt;size;i++)&#123; p=q.front(); q.pop(); if(p-&gt;left) q.push(p-&gt;left); if(p-&gt;right) q.push(p-&gt;right); levelResult.push_back(p-&gt;val); &#125; result.push_back(levelResult); &#125; return result; &#125; 104.二叉树的最大深度解法1DFS方法 int maxDepth(TreeNode* root) &#123; if(!root) return 0; int leftDepth=maxDepth(root-&gt;left); int rightDepth=maxDepth(root-&gt;right); return (leftDepth&gt;rightDepth)?(leftDepth+1):(rightDepth+1); &#125; 解法2BFS方法 int maxDepth(TreeNode* root) &#123; if(!root) return 0; queue&lt;TreeNode*&gt; q; TreeNode *p=root; q.push(root); int depth=0; int count=1;//记录队列中每一层的元素个数 while(!q.empty())&#123; p=q.front(); q.pop(); count--; if(p-&gt;left) q.push(p-&gt;left); if(p-&gt;right) q.push(p-&gt;right); if(count==0)&#123; depth++; count=q.size(); &#125; &#125; return depth; &#125; 107.二叉树的层次遍历Ⅱ【题目描述】 给定一个二叉树，返回其节点值自底向上的层次遍历。 例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \9 20 / \ 15 7 返回其自自底向上的层次遍历为： [ [15,7], [9,20], [3]] 【思路】 在102题的基础上，将输出的结果逆序即可。 【题解】 vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(!root) return result; TreeNode *p=root; queue&lt;TreeNode *&gt; q; q.push(p); vector&lt;int&gt; levelResult; while(!q.empty())&#123; levelResult.clear(); int size=q.size(); for(int i=0;i&lt;size;i++)&#123; p=q.front(); q.pop(); if(p-&gt;left) q.push(p-&gt;left); if(p-&gt;right) q.push(p-&gt;right); levelResult.push_back(p-&gt;val); &#125; result.push_back(levelResult); &#125; reverse(result.begin(),result.end()); return result;&#125; 108.将有序数组转换为二叉搜索树【题目描述】 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 【思路】 使用递归方法。 每次找到排序数组的中点，中点左边的子排序数组构成左子树，中点右边的子排序数组构成右子树,递归进行。 【题解】 TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;=0) return NULL; return buildBST(nums,0,len-1);&#125;TreeNode *buildBST(vector&lt;int&gt; &amp;nums,int left,int right)&#123; if(left&gt;right) return NULL; int mid=(left+right)/2; TreeNode *node=new TreeNode(nums[mid]); node-&gt;left=buildBST(nums,left,mid-1); node-&gt;right=buildBST(nums,mid+1,right); return node;&#125; 110.平衡二叉树【思路】 用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前就已经遍历了它的左右子树。 只要在遍历每个结点的时候记录它的深度，就可以一边遍历一边判断每个结点是否平衡。 如果子树是平衡二叉树，则返回子树高度 如果子树不是平衡二叉树，直接停止遍历 【题解】 bool isBalanced(TreeNode* root) &#123; int depth=0; return isBalanced(root,&amp;depth);&#125;bool isBalanced(TreeNode* root,int *depth)&#123; if(!root)&#123; *depth=0; return true; &#125; int leftDepth=0; int rightDepth=0; if(isBalanced(root-&gt;left,&amp;leftDepth) &amp;&amp; isBalanced(root-&gt;right,&amp;rightDepth))&#123; int diff=leftDepth-rightDepth; if(abs(diff)&lt;=1)&#123; *depth=1+(leftDepth&gt;rightDepth?leftDepth:rightDepth); return true; &#125; &#125; return false;&#125; 111.二叉树最小深度【题解】 int minDepth(TreeNode* root) &#123; if(!root) return 0; int leftDepth=minDepth(root-&gt;left); int rightDepth=minDepth(root-&gt;right); if(leftDepth==0) return rightDepth+1; if(rightDepth==0) return leftDepth+1; return (leftDepth&lt;rightDepth)?leftDepth+1:rightDepth+1;&#125; 114.二叉树展开为链表【题目描述】 给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / \ 2 5 / \ \3 4 6 将其展开为： 1 \ 2 \ 3 \ 4 \ 5 \ 6 【思路】 144.二叉树的前序遍历【题解】 vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if(!root) return result; TreeNode* p=root; stack&lt;TreeNode*&gt; s; while(p||!s.empty())&#123; while(p)&#123; result.push_back(p-&gt;val); s.push(p); p=p-&gt;left; &#125; if(!s.empty())&#123; p=s.top(); s.pop(); p=p-&gt;right; &#125; &#125; return result; &#125; 145.二叉树的后序遍历vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if(!root) return result; stack&lt;TreeNode*&gt; s; TreeNode *p=root; TreeNode *pre=NULL; s.push(p); while(!s.empty())&#123; p=s.top(); if((!p-&gt;left &amp;&amp; !p-&gt;right)||(pre &amp;&amp; (pre==p-&gt;left || pre==p-&gt;right)))&#123; result.push_back(p-&gt;val); s.pop(); pre=p; &#125;else&#123; if(p-&gt;right) s.push(p-&gt;right); if(p-&gt;left) s.push(p-&gt;left); &#125; &#125; return result; &#125; 230.二叉搜素树第k小的元素int kthSmallest(TreeNode* root, int k) &#123; if(root==NULL||k&lt;0) return -1; stack&lt;TreeNode*&gt; s; TreeNode *p=root; int count=0; while(!s.empty()||p)&#123; while(p)&#123; s.push(p); p=p-&gt;left; &#125; if(!s.empty())&#123; p=s.top(); s.pop(); count++; if(count==k) return p-&gt;val; p=p-&gt;right; &#125; &#125; return -1; &#125; 栈155.最小栈【题目描述】 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素x推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 【思路】 使用两个栈，一个栈是正常的栈s，另一个栈是存最小值的栈sm。 push时，判断sm是否为空，以下两种情况在sm中插入x 为空 非空但栈顶元素大于插入值的 pop时，s的元素删除，若sm中的元素与s的元素相等，则一同删除。 【题解】 public: stack&lt;int&gt; s; stack&lt;int&gt; sm; void push(int x) &#123; s.push(x); if(sm.empty() || (!sm.empty() &amp;&amp; sm.top()&gt;=x)) sm.push(x); &#125; void pop() &#123; if(s.top()==sm.top()) sm.pop(); s.pop(); &#125; int top() &#123; return s.top(); &#125; int getMin() &#123; return sm.top(); &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】剑指Offer总结]]></title>
    <url>%2Falgorithm-offer%2F</url>
    <content type="text"><![CDATA[[TOC] 位运算二进制中1的个数 （面试题10）【题目描述】 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 【思路】 把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0，则一个整数的二进制有多少个1，就可以进行多少次这样的操作。 【题解】 int NumberOf1(int n) &#123; int count=0; while(n!=0)&#123; count++; n=(n-1)&amp;n; &#125; return count;&#125; 数组中只出现一次的数字（面试题40）【题目描述】 一个整形数组里除了两个数字之外，其他的数字都出现了两次，找出这两个只出现一次的数字。要求时间复杂度O(n)，空间复杂度O(1)。 【思路】 【题解】 数组数组中出现次数超过一半的数字（面试题29）【题目描述】 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 【思路】 数组中有一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。 在遍历数组的时候保存两个值 一个是数组中的数字，一个是次数 如果下一个数字和我们之前保存的数字相同，则次数加1 如果下一个数字和我们之前保存的数字不同，则次数减1 如果次数为0，则保存下一个数字，并把次数设为1。 【题解】 /* 第一个数字作为第一个士兵，守阵地；count = 1； 遇到相同元素，count++; 遇到不相同元素，即为敌人，同归于尽,count--；当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。 再加一次循环，记录这个士兵的个数看是否大于数组一般即可。 */ int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int len=numbers.size(); if(len==0) return 0; int result=numbers[0]; int times=1; //次数 for(int i=1;i&lt;len;i++)&#123; if(result==numbers[i]) times++; else times--; // 更新result的值为当前元素，并置次数为1 if(times==0)&#123; result=numbers[i]; times=1; &#125; &#125; // 判断result是否符合条件，即出现次数大于数组长度的一半 times=0; for(int i=0;i&lt;len;i++) if(numbers[i]==result) times++; return (times&gt;len/2)?result:0; &#125; 数字在排序数组中出现的次数（面试题38）【题目描述】 统计一个数字在排序数组中出现的次数 【思路】 看到有序数组的查找，想到二分查找 因为要查找的k是连续出现的，需要确定第一个k的位置和最后一个k的位置。 分两次查找第一个k的位置和最后一个k的位置。 先查找第一个k的位置，查找到k值后，不确定是否是第一个k，所以比较查找到的k值和前面一个值是否相等，即向该k值的左方查找 如果不等，则说明是第一个k值 如果相等，则继续向左比较。 查找最后一个k的位置同理。 最后确定第一个k的位置和最后一个k的位置，lastK-firstK+1即可。 【题解】 int GetFirstK(vector&lt;int&gt; data,int k,int low,int high)&#123; if(data.size()==0 || low&gt;high) return -1; int mid=0; while(low&lt;=high)&#123; mid=(low+high)/2; if(data[mid]&lt;k) low=mid+1; else if(data[mid]&gt;k) high=mid-1; else&#123; //查找到k值，但是不确定是否是第一个k //往左寻找第一个k while(data[mid-1]==data[mid])&#123; mid--; &#125; return mid; &#125; &#125; return -1;&#125;int GetLastK(vector&lt;int&gt; data,int k,int low,int high)&#123; if(data.size()==0 || low&gt;high) return -1; int mid=0; while(low&lt;=high)&#123; mid=(low+high)/2; if(data[mid]&lt;k) low=mid+1; else if(data[mid]&gt;k) high=mid-1; else&#123; //查找到k值，但是不确定是否是最后一个k //往右寻找最后一个k while(data[mid+1]==data[mid])&#123; mid++; &#125; return mid; &#125; &#125; return -1;&#125;int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; if(data.size()==0) return 0; int len=data.size(); int firstK=GetFirstK(data,k,0,len-1); int lastK=GetLastK(data,k,0,len-1); if(firstK==-1 || lastK==-1) return 0; else return (lastK-firstK+1); &#125; 和为s的两个数字（面试题41）【题目描述】 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。 【思路】 同LeetCode 1。 【题解】 vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt; result; int len=array.size(); if(len==0) return result; map&lt;int,int&gt; m; for(int i=0;i&lt;len;i++)&#123; if(m.find(sum-array[i])!=m.end())&#123; result.push_back(sum-array[i]); result.push_back(array[i]); return result; &#125;else m[array[i]]=i; &#125; return result; &#125; 和为s的连续正数序列【题目描述】 输入一个正数s，打印所有和为s的连续正数序列（至少含两个数） 【思路】 用两个数small和big分别表示序列的最小值和最大值。 把small初始化为1，big初始化为2. 当前和的值为(big+small)*(big-small+1)/2 若当前和的值小于sum，big加1 若当前和大于sum，small加1 字符串替换空格 （面试题4）【题目描述】：把字符串中的每个空格替换成”%20”。例如输入”We are happy”，输出”We%20are%20happy” 【思路】O(n)解法 先遍历一遍字符串，统计出字符串中空格的总数，并可由此计算出替换空格之后的字符串的总长度。每替换一个空格，长度增加2。 从字符串尾部开始复制和替换 两个指针p1,p2。p1指向原字符串末尾，p2指向替换之后的字符串末尾。 向前移动p1，逐个把它指向的字符复制到p2指向的位置，直到遇到第一个空格为止。 碰到第一个空格之后，把p1向前移动1格，在p2之前插入“%20”。 因为”%20”长度为3，所以将p2向前移动3格 【题解】 void replaceSpace(char *str,int length) &#123; if(str == NULL || length &lt; 0) return ; int spaceNum=0; int originalLength=0; int index=0; while(str[index] != '\0')&#123; if(str[index] == ' ') spaceNum++; originalLength++; index++; &#125; int newLength=originalLength+spaceNum*2; if(newLength &gt; length) return ; int originalIndex=originalLength; int newIndex=newLength; while(originalIndex &gt;=0 &amp;&amp; newIndex &gt; originalIndex)&#123; if(str[originalIndex] == ' ')&#123; str[newIndex--]='0'; str[newIndex--]='2'; str[newIndex--]='%'; &#125;else&#123; str[newIndex--]=str[originalIndex]; &#125; originalIndex--; &#125;&#125; 打印1到最大的n位数（面试题12）【题目描述】输入数字n，按顺序打印出从1开始到最大的n位十进制数。 【思路】 因为n的范围没给出，因此为了防止溢出使用字符串的方式解决此题。 采用数字排列的方法。在输出的数字前面补0的话，会发现n位所有十进制数其实就是n个从0到9的全排列。即把数字的每一位从0到9排列一遍，得到所有的十进制数。 全排列用递归容易表达，数字的每一位都可能是0-9中的一个数，然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。 【题解】 ​ 字符串全排列（面试题28）【题目描述】输入一个字符串，打印出该字符串中字符的所有排列。 【思路】 该问题即全排列问题，可以分为递归方法和非递归方法实现。 递归方法：《剑指Offer》中的该题题解没有考虑去重的情况。去重的全排列规则：从第一个数字起每个数分别与它后面非重复出现的数字交换。用编程的话描述就是第i个数与第j个数交换时，要求[i,j)中没有与第j个数相等的数。 非递归方法： https://blog.csdn.net/morewindows/article/details/7370155 【题解】 递归方法 //去重全排列的递归实现 #include &lt;stdio.h&gt; #include &lt;string.h&gt; void Swap(char *a, char *b) &#123; char t = *a; *a = *b; *b = t; &#125; //在pszStr数组中，[nBegin,nEnd)中是否有数字与下标为nEnd的数字相等 bool IsSwap(char *pszStr, int nBegin, int nEnd)&#123; for (int i = nBegin; i &lt; nEnd; i++) if (pszStr[i] == pszStr[nEnd]) return false; return true; &#125; //k表示当前选取到第几个数,m表示共有多少数. void AllRange(char *pszStr, int k, int m)&#123; if (k == m)&#123; static int s_i = 1; printf(" 第%3d个排列\t%s\n", s_i++, pszStr); &#125;else&#123; for (int i = k; i &lt;= m; i++)&#123; //第i个数分别与它后面的数字交换就能得到新的排列 if (IsSwap(pszStr, k, i))&#123; Swap(pszStr + k, pszStr + i); AllRange(pszStr, k + 1, m); Swap(pszStr + k, pszStr + i); &#125; &#125; &#125; &#125; void Foo(char *pszStr)&#123; AllRange(pszStr, 0, strlen(pszStr) - 1); &#125; 非递归方法 表示数值的字符串（面试题54）【题目描述】 请实现一个函数用来判断字符串是否表示数值（包括整数和小数） 【思路】 整数开始部分遇到+、-号跳过 小数点只能出现一次 小数点之前不能存在e e之前必须有整数 e只能出现一次 e之后可以存在+、-号，但+ -之后必须有整数 【题解】 bool isNumeric(char* str) &#123; if (str == NULL) return false; if (*str == '+' || *str == '-') ++str; if (*str == '\0') return false; int x = 0; //标记整数部分 int digit = 0; //标记小数点 int e = 0; //标记e的状态 while (*str != '\0') &#123; //标记整数部分的状态 if (*str &gt;= '0' &amp;&amp; *str &lt;= '9') &#123; ++str; x = 1; &#125; //小数点 else if (*str == '.') &#123; //前面已经出现过小数点或小数点之前存在e，则返回false if (digit &gt; 0 || e &gt; 0) return false; ++str; digit = 1; //标记小数点已经出现过 &#125; //e else if (*str == 'e' || *str == 'E') &#123; //e之前没有整数或e已经出现过，则返回false if (x == 0 || e &gt; 0) return false; ++str; e = 1; //标记e表示已经出现过 //e之后可以出现+-号再加整数 if (*str == '+' || *str == '-') ++str; if (*str == '\0') return false; &#125; else return false; &#125; return true; &#125; 翻转单词顺序（面试题42）【题目描述】 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 【思路】 按空格分割单词，然后按头插法插入到目标字符串中。原字符串最后一个单词需要单独处理 翻转两遍，第一遍翻转所有字符，第二遍翻转每个单词中字符的顺序。 【题解】 string ReverseSentence(string str) &#123; string result=""; string tmp=""; for(int i=0;i&lt;str.size();i++)&#123; if(str[i]!=' ')&#123; tmp+=str[i]; //获取完整的一个单词 &#125;else&#123; result=' '+tmp+result; //插入到后面 tmp=""; &#125; &#125; result=tmp+result;//最后的单词单独处理，加在最后 return result; &#125; 左旋转字符串（面试题42）【题目描述】 把字符串前面的若干个字符转移到字符串的尾部。 【思路】 分别旋转前部分字符和后部分字符。如abcdefg把ab移动到cdefg后，则先旋转ab为ba，旋转cdefg为gfedc 最后旋转整个字符串。如旋转bagfedc为cdefgab void reverse(string &amp;str,int begin,int end)&#123; for(;begin&lt;end;begin++,end--)&#123; char tmp=str[begin]; str[begin]=str[end]; str[end]=tmp; &#125; &#125; string LeftRotateString(string str, int n) &#123; if(str=="") return str; int len=str.size(); int firstStart=0; int firstEnd=n-1; int secondStart=n; int secondEnd=len-1; //旋转前部分字符 reverse(str,firstStart,firstEnd); //旋转后部分字符 reverse(str,secondStart,secondEnd); //旋转全部字符 reverse(str,firstStart,secondEnd); return str; &#125; 链表从尾到头打印链表（面试题5）【题目描述】输入一个链表的头结点，从尾到头反过来打印输出每个结点的值 【思路】 从头到尾遍历整个链表，每经过一个结点的时候，把该结点放到栈中，当遍历完整个链表后，再从栈顶开始逐个遍历结点。 【题解】 /*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/ #include&lt;stack&gt; vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; result; if(head == NULL) return result; stack&lt;ListNode *&gt; s; ListNode *p=head; while(p!=NULL)&#123; s.push(p); p=p-&gt;next; &#125; while(!s.empty())&#123; result.push_back(s.top()-&gt;val); s.pop(); &#125; return result; &#125; 在O(1)时间删除链表结点（面试题13）【题目描述】给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。 【思路】 本题与《编程之美》上的「从无头单链表中删除节点」类似。用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。 注意点：若链表中只有一个结点，而我们又要删除链表的头结点（也是尾结点），在删除结点后，需要把链表的头节点设置为NULL。 【题解】 void DeleteNode(Node** pHead,Node* pDeleted)&#123; if(!pHead || !pDeleted) return ; if(pDeleted-&gt;next != NULL)&#123; Node *pNext=pDeleted-&gt;next; pDeleted-&gt;data=pNext-&gt;data; pDeleted-&gt;data=pNext-&gt;next; delete pNext; pNext=NULL; &#125;else if(*pHead==pDeleted)&#123; //链表只有一个结点，删除头结点，也是尾结点 delete pDeleted; pDeleted=NULL; *pHead=NULL; &#125;else&#123; //链表中有多个结点，删除尾结点 Node* pNode=*pHead; while(pNode-&gt;next != pDeleted) pNode=pNode-&gt;next; pNode-&gt;next=NULL; delete pDeleted; pDeleted=NULL; &#125;&#125; 链表中倒数第k个结点（面试题15）【题目描述】输入一个链表，输出该链表中倒数第k个结点。 本题从1开始计数，即链表的尾结点是倒数第1个结点。 【思路】 定义两个指针。 第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动 从第k步开始，第二个指针也开始从链表的头指针开始遍历。 由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。 【题解】 /*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/ ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode *slowP=pListHead; ListNode *fastP=pListHead; if(pListHead == NULL || k==0) return NULL; for(int i=0;i&lt;k-1;i++)&#123; if(fastP-&gt;next!=NULL) fastP=fastP-&gt;next; else return NULL; &#125; while(fastP-&gt;next != NULL)&#123; fastP=fastP-&gt;next; slowP=slowP-&gt;next; &#125; return slowP; &#125; 链表逆置（面试题16）【题目描述】：输入一个单向链表，输出逆序反转后的链表 三指针方法【思路】：非递归方法即就地逆置法，用三个临时指针pre,head,next在链表循环即可。 【题解】 //单链表转置，循环方法 ListNode* ReverseList(ListNode* pHead) &#123; if(pHead==NULL) return NULL; ListNode *pre=NULL; ListNode *next=NULL; while(pHead!=NULL)&#123; next=pHead-&gt;next; pHead-&gt;next=pre; pre=pHead; pHead=next; &#125; return pre; &#125; 利用栈【思路】 同从尾到头打印单链表（面试题5）类似 ListNode* ReverseList(ListNode* pHead) &#123; if(pHead == NULL || pHead-&gt;next == NULL) return pHead; stack&lt;ListNode*&gt; s; ListNode* p=pHead; while(p!=NULL)&#123; s.push(p); p=p-&gt;next; &#125; //从栈里建立新链表,尾插法建立新链表 ListNode *result=s.top(); s.pop(); p=result; while(!s.empty())&#123; p-&gt;next=s.top(); p=p-&gt;next; s.pop(); &#125; //最后不要忘了终端节点指针域置为空 p-&gt;next=NULL; return result; &#125; 合并两个排序的链表（面试题17）【题目描述】输入两个递增排序的链表，合并这两个链表并使新联中的结点仍然是按照递增排序的。 【思路】 若第一个链表是空链表，则结果是第二个链表 若第二个链表是空链表，则结果是第一个链表 若两个链表都是空指针，则结果是空链表 采用递归方法，比较两个链表中值较小的头结点并把它链接到已经合并的链表之后，因为两个链表的结点仍然是有序的，因此采用递归方法完成合并过程 【题解】 ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1==NULL) return pHead2; else if(pHead2==NULL) return pHead1; if(pHead1==NULL &amp;&amp; pHead2==NULL) return NULL; ListNode *result; //采用递归的方法创建单链表，最后返回的result单链表是由一层层返回逆序链接好的单链表结果组合成的。 //相当于倒着一层层返回由上一个排序好的子链表 if(pHead1-&gt;val&lt;pHead2-&gt;val)&#123; result=pHead1; result-&gt;next=Merge(pHead1-&gt;next,pHead2); &#125;else&#123; result=pHead2; result-&gt;next=Merge(pHead1,pHead2-&gt;next); &#125; return result; &#125; 两个链表的第一个公共结点（面试题37）【题目描述】输入两个链表，找出它们的第一个公共结点 【思路】O(m+n) 遍历两个链表得到它们的长度。计算出哪个链表长，并比短的多几个结点 在第二次遍历时，在较长的链表上先走若干步，接着再同时在两个链表遍历，找到的第一个相同的结点就是第一个公共结点。 【题解】 ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1 == NULL || pHead2 == NULL) return NULL; int len1=GetLength(pHead1); int len2=GetLength(pHead2); int diff=0; ListNode *fastIndex,*slowIndex; if(len1&gt;len2)&#123; diff=len1-len2; fastIndex=pHead1; slowIndex=pHead2; &#125;else&#123; diff=len2-len1; fastIndex=pHead2; slowIndex=pHead1; &#125; for(int i=0;i&lt;diff;i++)&#123; fastIndex=fastIndex-&gt;next; &#125; while(fastIndex != NULL &amp;&amp; slowIndex != NULL &amp;&amp; fastIndex != slowIndex)&#123; fastIndex=fastIndex-&gt;next; slowIndex=slowIndex-&gt;next; &#125; return fastIndex;&#125;int GetLength(ListNode *root)&#123; int len=0; ListNode *s=root; while(s!=NULL)&#123; s=s-&gt;next; len++; &#125; return len;&#125; 判断单链表是否有环【题目描述】 单链表有环的定义：链表的尾节点指向了链接中间的某个节点。 如下图所示，如果有环，则遍历到结点7时，又重新回到结点3，结点3就是环的入口结点。 【思路】 采用快慢指针的思想，设两个工作指针，一个快一个慢，比如一个每次走一步，另一个每次走两步，如果链表有环，必定会在某个结点处相遇。 具体流程： 可以设置两个指针(fast,slow)，初始值均指向头，slow每次向前一步，fast每次向前两步； 如果链表中有环，则fast先进入环中，而slow后进入环中，两个指针在环中必定相遇; 如果fast遍历到尾部为NULL，则无环 【题解】 int hasLoop(Node *head)&#123; Node *p1,p2; if(head == NULL || head-&gt;next == NULL) //链表为空，或者是单结点链表返回头结点 return 0; p1=p2=head; while(p1-&gt;next != NULL &amp;&amp; p1-&gt;next-next != NULL)&#123; p1=p1-&gt;next-&gt;next; p2=p2-&gt;next; if(p1==p2) return 1; &#125;&#125; 链表中环的入口结点（面试题56）【题目描述】 一个链表中包含环，请找出该链表的环的入口结点。 【思路】 两个指针一个快fast，一个慢slow。两个指针同时从一个链表的头部出发。 fast指针一次走两步，slow一次走一步。 若该链表有环，则两个指针必然在环内相遇 若有环则把其中一个指针重新指向链表头部，另一个不变（还在环内），两个指针每次都走一步，相遇的地方即是入口结点。 【题解】 if(pHead==NULL || pHead-&gt;next==NULL) return NULL; ListNode *fastP=pHead; ListNode *slowP=pHead; bool isCycle=false; while(fastP-&gt;next!=NULL &amp;&amp; fastP-&gt;next-&gt;next!=NULL)&#123; slowP=slowP-&gt;next; fastP=fastP-&gt;next-&gt;next; if(fastP==slowP)&#123; isCycle=true; break; &#125; &#125; if(isCycle)&#123; slowP=pHead; while(slowP!=NULL &amp;&amp; fastP!=NULL &amp;&amp; slowP!=fastP)&#123; slowP=slowP-&gt;next; fastP=fastP-&gt;next; &#125; return slowP; &#125;else return NULL;&#125; 删除链表中重复的结点（面试题57）【题目】 在一个排序的链表中，如何删除重复的结点。 【思路】 设置一个头结点，然后根据情况遍历 【题解】 ListNode* deleteDuplication(ListNode* pHead) &#123; if(pHead==NULL || pHead-&gt;next==NULL) return pHead; ListNode *head=new ListNode(-1); ListNode *p=head; ListNode *q=pHead; while(q!=NULL)&#123; while(q!=NULL &amp;&amp; q-&gt;next!=NULL &amp;&amp; q-&gt;next-&gt;val==q-&gt;val)&#123; int tmp=q-&gt;val; while(q!=NULL &amp;&amp; q-&gt;val==tmp) q=q-&gt;next; &#125; p-&gt;next=q; p=p-&gt;next; if(q!=NULL) q=q-&gt;next; &#125; return head-&gt;next; &#125; 栈用两个栈实现队列（面试题7）【题目描述】 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 【思路】 利用两个栈stack1和stack2实现队列。 Push操作 直接将元素压入stack1即可。 Pop操作 当stack2非空时，直接弹出栈顶元素 当stack2为空时，把stack1中的元素逐个弹出并压入stack2，再弹出栈顶元素。 【题解】 class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if(stack2.empty())&#123; while(!stack1.empty())&#123; int tmp=stack1.top(); stack1.pop(); stack2.push(tmp); &#125; &#125; int result=stack2.top(); stack2.pop(); return result; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 包含min函数的栈（面试题21）【题目描述】 定义栈的数据结构，请在该类型中实现一个能得到栈的最小元素的min函数 【思路】 堆最小的k个数（面试题30）【题目描述】 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 【思路】 使用堆，在STL中set和multiset都是基于红黑树实现的。 用最大堆保存这k个数，每次只和堆顶比 如果比堆顶小，删除堆顶，新数入堆。 如果比堆顶大，则丢弃，因为要求的是最小的k个数，比堆顶还大则不可能是最小的数 O(nlogk) 【题解】 vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; result; multiset&lt;int,greater&lt;int&gt; &gt; leastNumbers; multiset&lt;int,greater&lt;int&gt; &gt;::iterator greaterIt; int len=input.size(); if(len&lt;0 || k&lt;0 || len&lt;k) return result; vector&lt;int&gt;::iterator vi; for(vi=input.begin();vi != input.end(); vi++)&#123; if(leastNumbers.size() &lt; k) leastNumbers.insert(*vi); else&#123; greaterIt=leastNumbers.begin(); if(*greaterIt&gt;*vi)&#123; leastNumbers.erase(greaterIt); leastNumbers.insert(*vi); &#125; &#125; &#125; for(greaterIt=leastNumbers.begin();greaterIt!=leastNumbers.end();greaterIt++) result.push_back(*greaterIt); return result; &#125; 树树的子结构（面试题18）【题目描述】 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 【思路】 分成两步 第一步在树A中找到和树B的根结点的值一样的结点R 再判断树A中以R为根结点的子树是不是包含和树B一样的结构 采用递归方法 【题解】 /*思路：参考剑指offer1、首先设置标志位result = false，因为一旦匹配成功result就设为true，剩下的代码不会执行，如果匹配不成功，默认返回false2、递归思想，如果根节点相同则递归调用DoesTree1HaveTree2（），如果根节点不相同，则判断tree1的左子树和tree2是否相同，再判断右子树和tree2是否相同3、注意null的条件，HasSubTree中，如果两棵树都不为空才进行判断，DoesTree1HasTree2中，如果Tree2为空，则说明第二棵树遍历完了，即匹配成功，tree1为空有两种情况（1）如果tree1为空&amp;&amp;tree2不为空说明不匹配，（2）如果tree1为空，tree2为空，说明匹配。*/bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)&#123; bool result=false; //当Tree1和Tree2都不为空的时候，才进行比较。否则直接返回false if(pRoot1 != NULL &amp;&amp; pRoot2 != NULL)&#123; //如果找到了Tree A对应Tree B的根结点的结点 if(pRoot1-&gt;val == pRoot2-&gt;val) //以这个根结点为起点判断是否包含Tree2 result=DoesTree1HaveTree2(pRoot1,pRoot2); if(!result) //如果找不到，那么就再去root的左孩子当作起点，去判断时候包含Tree2 result=HasSubtree(pRoot1-&gt;left,pRoot2); if(!result) //如果还找不到，那么就再去root的右孩子当作起点，去判断时候包含Tree2 result=HasSubtree(pRoot1-&gt;right,pRoot2); &#125; return result;&#125;bool DoesTree1HaveTree2(TreeNode *node1,TreeNode *node2)&#123; //如果Tree2已经遍历完了都能对应的上，返回true if(node2==NULL) return true; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if(node1==NULL) return false; //如果其中有一个点没有对应上，返回false if(node1-&gt;val != node2-&gt;val) return false; //如果根节点对应的上，那么就分别去子节点里面匹配 return DoesTree1HaveTree2(node1-&gt;left,node2-&gt;left) &amp;&amp; DoesTree1HaveTree2(node2-&gt;right,node2-&gt;right);&#125; 树的镜像（面试题19）【题目描述】 操作给定的二叉树，将其变换为源二叉树的镜像。 【思路】 类同二叉树的翻转，先翻转左子树，再翻转右子树，然后对整个树进行翻转 【题解】 递归方式void BiTree::invertTree(BiNode *node)&#123; if(node == NULL) return ; swap(node-&gt;lchild,node-&gt;rchild); invertTree(node-&gt;lchild); invertTree(node-&gt;rchild);&#125; 非递归方式利用队列。 void BiTree::invertTreeNonRec(BiNode *node)&#123; if(node == NULL) return ; queue&lt;BiNode *&gt; q; q.push(node); while(!q.empty())&#123; BiNode *cur=q.front(); q.pop(); BiNode *tmp=cur-&gt;lchild; cur-&gt;lchild=cur-&gt;rchild; cur-&gt;rchild=tmp; if(cur-&gt;lchild != NULL) q.push(cur-&gt;lchild); if(cur-&gt;rchild != NULL) q.push(cur-&gt;rchild); &#125;&#125; 从上往下打印二叉树（面试题23）【题目描述】 从上往下打印二叉树各个结点，同层结点从左至右打印。 【思路】 利用队列实现层序遍历 【题解】 vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; result; queue&lt;TreeNode*&gt; q; TreeNode *s; if(root==NULL) return result; q.push(root); while(!q.empty())&#123; s=q.front(); q.pop(); result.push_back(s-&gt;val); if(s-&gt;left!=NULL) q.push(s-&gt;left); if(s-&gt;right!=NULL) q.push(s-&gt;right); &#125; return result; &#125; 二叉搜索树的后序遍历序列（面试题24）【题目描述】 输入一个整数数组，判断该数组是否为某棵二叉搜索树的后序遍历的结果 【思路】 条件： 根结点是后序遍历序列中的最后一个数。 二叉搜索树左子树值都比根结点小，右孩子值都比根结点大。 方法： 确定根结点 遍历除去根结点的序列，找到第一个比根结点大的位置，左边是左子树，右边是右子树 遍历右子树，若存在小于根结点的值，直接返回false 分别判断左子树和右子树是否是二叉搜索树（即递归步骤1、2、3） bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if(sequence.empty()) return false; int len=sequence.size(); int root=sequence[len-1]; int index=0;//划分左右子树界限 //寻找左右子树界限 for(int i=0;i&lt;len;i++)&#123; index=i; if(sequence[i]&gt;root) break; &#125; //遍历右子树，是否符合右子树的值都大于根结点的规律 for(int i=index;i&lt;len;i++)&#123; if(sequence[i]&lt;root) return false; &#125; vector&lt;int&gt; leftSequence,rightSequence; //判断是否有左子树 if(index != 0) for(int i=0;i&lt;index;i++) leftSequence.push_back(sequence[i]); //判断是否有右子树 if(index != len-2) for(int i=index;i&lt;len-1;i++) rightSequence.push_back(sequence[i]); //左右子树是否为二叉搜索树 bool isLeft=true; bool isRight=true; if(leftSequence.size()&gt;1) isLeft=VerifySquenceOfBST(leftSequence); if(rightSequence.size()&gt;1) isRight=VerifySquenceOfBST(rightSequence); return (isLeft&amp;&amp;isRight); &#125; 二叉树的深度（面试题39）【题目描述】 输入一棵二叉树，求该树的深度。 【思路】 如果一棵树只有一个结点，则深度为1； 如果根结点只有左子树而没有右子树，则深度为其左子树深度+1 如果根结点只有右子树而没有左子树，则深度为其右子树深度+1 如果既有左子树又有右子树，则深度是左、右子树深度的较大值+1 【题解】 int TreeDepth(TreeNode* pRoot) &#123; if(pRoot==NULL) return 0; int leftDepth=TreeDepth(pRoot-&gt;left); int rightDepth=TreeDepth(pRoot-&gt;right); return (leftDepth&gt;rightDepth)?(leftDepth+1):(rightDepth+1); &#125; 判断平衡二叉树（面试题39）【题目描述】 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 【思路】 用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前就已经遍历了它的左右子树。 只要在遍历每个结点的时候记录它的深度，就可以一边遍历一边判断每个结点是否平衡。 如果子树是平衡二叉树，则返回子树高度 如果子树不是平衡二叉树，直接停止遍历 【题解】 bool IsBalanced(TreeNode* root,int *depth)&#123; if(root==NULL)&#123; *depth=0; return true; &#125; int leftDepth=0; int rightDepth=0; if(IsBalanced(root-&gt;left,&amp;leftDepth) &amp;&amp; IsBalanced(root-&gt;right,&amp;rightDepth))&#123; int diff=leftDepth-rightDepth; if(abs(diff)&lt;=1)&#123; *depth=1+(leftDepth&gt;rightDepth?leftDepth:rightDepth); return true; &#125; &#125; return false; &#125; bool IsBalanced_Solution(TreeNode* pRoot) &#123; int depth=0; return IsBalanced(pRoot,&amp;depth); &#125; 二叉搜索树的第k个结点（面试题63）【题目描述】 给定一棵二叉搜索树，请找出其中的第k个的结点。 【思路】 按中序遍历可以找出第k个的结点。 【题解】 //非递归遍历二叉树//先将左孩子都存在栈中，从最左孩子开始遍历。TreeNode* KthNode(TreeNode* pRoot, int k) &#123; if(pRoot==NULL) return NULL; stack&lt;TreeNode*&gt; s; TreeNode *p=pRoot; int count=0; //计数器 while(p!=NULL || !s.empty())&#123; while(p!=NULL)&#123; s.push(p); p=p-&gt;left; &#125; if(!s.empty())&#123; p=s.top(); s.pop(); count++; if(count==k) //如果已经是第k个结点，则返回 return p; p=p-&gt;right; &#125; &#125; return NULL; &#125; 动态规划连续子数组的最大和（面试题31）【题目描述】 输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 【思路】 dp[i]表示以A[i]作为末尾的连续序列的最大和，最大和即dp[0],dp[1],dp[2],….,dp[n-1]中的最大值。 因为dp[i]要求是必须以A[i]结尾的连续序列，那么只有两种情况 最大和的连续序列只有一个元素，即以A[i]开始，A[i]结尾。即A[i]本身 最大和的连续序列有多个元素，即从前面某处A[p]开始，一直到A[i]结尾。即dp[i-1]+A[i] 得到结论 状态转移方程：dp[i]=max{A[i],dp[i-1]+A[i]} 边界：dp[0]=A[0] 【题解】 int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int len=array.size(); if(len==0) return 0; vector&lt;int&gt; dp(array.begin(),array.end());//dp用来存放以A[i]结尾的连续序列的最大和 dp[0]=array[0];//边界条件 for(int i=1;i&lt;len;i++) dp[i]=max(array[i],dp[i-1]+array[i]);//状态转移方程 int index=0; for(int i=1;i&lt;len;i++)&#123; if(dp[i]&gt;dp[index]) index=i; &#125; return dp[index]; &#125; 杂项斐波那契数列(面试题9)【题目描述】 输入n，求斐波那契数列的第n项。 【思路】 根据f(0)和f(1)算出f(2)，再根据f(1)和f(2)算出f(3)，以此类推。 【题解】 int Fibonacci(int n) &#123; if(n==0) return 0; if(n==1) return 1; int result=0; int firstItem=0;//相加的第一项 int secondItem=1;//相加的第二项 for(int i=2;i&lt;=n;i++)&#123; result=firstItem+secondItem; firstItem=secondItem; secondItem=result; &#125; return result;&#125; 跳台阶（面试题9的变形）【题目描述】 一只青蛙一次可以跳1级台阶，也可以跳2级台阶，求该青蛙跳上一个n级台阶总共有多少种跳法。 【思路】 把n级台阶跳法看成n的函数f(n)。 如果两种跳法，1级或2级，假定第一次跳的是1级，则剩下n-1级台阶，跳法是f(n-1)。 假定第一次跳的是2级，则剩下的n-2级台阶，跳法是f(n-2) 由a、b可总结出跳法是f(n)=f(n-1)+f(n-2) 根据题意，只有一级台阶时f(1)=1,只有两级台阶时f(2)=2 最后是一个斐波那契数列$$\begin{equation}f(n)=\left{\begin{aligned}1&amp; &amp; (n=1) \2 &amp; &amp; (n=2) \f(n-1)+f(n-2)&amp; &amp;(n&gt;2)\end{aligned}\right.\end{equation}$$ int jumpFloor(int number) &#123; if(number==1) return 1; if(number==2) return 2; int result=0; int firstItem=1; int secondItem=2; for(int i=3;i&lt;=number;i++)&#123; result=firstItem+secondItem; firstItem=secondItem; secondItem=result; &#125; return result; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】面试算法题总结]]></title>
    <url>%2Falgorithm-interview%2F</url>
    <content type="text"><![CDATA[[TOC] 查找二分查找int BiSearch(int a[],int size,int key)&#123; if(a==NULL || size==0) return -1; int low=0; int high=size-1; int mid=0; while(low&lt;high)&#123; mid=(low+high)/2; if(a[mid]&lt;key) low=mid+1; else if(a[mid]&gt;key) high=mid-1; else return mid; &#125; return -1;&#125; 排序快排 //一次划分，选取第一个记录作为关键码int partition(int a[],int first,int end)&#123; int i=first; //初始化 int j=end; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) //右侧扫描 j--; if(i&lt;j)&#123; //将较小的记录交换到前面 swap(a[i],a[j]); i++; &#125; while(i&lt;j &amp;&amp; a[i]&lt;=a[j]) //左侧扫描 i++; if(i&lt;j)&#123; swap(a[i],a[j]); //将较大的记录交换到后面 j--; &#125; &#125; return i;&#125;//整个快排的过程可递归进行，若待排序序列中只有一个记录，则结束递归，否则进行一次划分后，再分别对划分得到的两个子序列进行快排（即递归处理）void quickSort(int a[],int first,int end)&#123; if(first&lt;end)&#123; int pivot=partition(a,first,end); quickSort(a,first,pivot-1); quickSort(a,pivot+1,end); &#125;&#125; 冒泡排序【思路】 设置exchange变量记载每次记录交换的位置，则一趟排序后，exchange记载的一定是这趟排序中记录的最后一次交换的位置，从此位置后所有记录均有序。 if(r[j]&gt;r[j+1])&#123; swap(r[j],r[j+1]); exchange=j; //记载每一次记录交换的位置&#125; 设bound位置的记录是无序区的最后一个记录，则每趟冒泡排序的范围是r[1]~r[bound]。在一趟排序后，exchange位置之后的记录一定是有序的，所以下一趟冒泡排序汇总无序区的最后一个记录的位置是exchange，即bound=exchange for(int j=0;j&lt;bound;j++)&#123; if(r[j]&gt;r[j+1])&#123; swap(r[j],r[j+1]); exchange=j; &#125;&#125; 判别冒泡排序的结束条件应该是在一趟排序过程中没有进行交换记录的操作。为此，在每趟冒泡排开始之前，设exchange初值为0，在该趟排序的过程中，只要有记录的交换，则exchange值大于0. 通过exchange的值是否为0可以判断是否有记录的交换，从而判断整个冒泡排序是否结束。 while(exchange != 0)&#123; bound=exchagne; exchange=0; for(int j=0;j&lt;bound;j++)&#123; if(r[j]&gt;r[j+1])&#123; swap(r[j],r[j+1]); exchange=j; &#125; &#125;&#125; 【实现】 void bubbleSort(int a[],int n)&#123; if(n==0) return ; int exchange=n; //第一趟冒泡排序的区间是[1,n] while(exchange != 0)&#123; //当上一趟排序有记录交换时 int bound=exchange; exchange=0; for(int i=0;i&lt;bound;i++)&#123; //一趟冒泡排序，区间是[1,bound] if(a[i]&gt;a[i+1])&#123; swap(a[i],a[i+1]); exchange=i; //记载每一次记录交换的位置 &#125; &#125; &#125;&#125; 堆排以最大堆进行升序排序为例 初始化堆：即构造堆 交换数据，调整堆 #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//向下调整void DownAdjust(int a[],int i,int size)&#123; //i是指欲调整结点 int lchild=2*i; int rchild=2*i+1; int maxIndex=i; if(i&lt;=size/2)&#123; if(lchild&lt;=size &amp;&amp; a[lchild] &gt; a[maxIndex]) maxIndex=lchild; if(rchild&lt;=size &amp;&amp; a[rchild] &gt; a[maxIndex]) maxIndex=rchild; if(maxIndex != i)&#123; //如果最大值maxIndex更新了 swap(a[maxIndex],a[i]); DownAdjust(a,maxIndex,size); &#125; &#125;&#125;//建堆，对每一个非叶结点进行堆调整（从最后一个非叶结点开始）void BuildHeap(int a[],int size)&#123; for(int i=size/2;i&gt;=1;i--) //注意：这里从(size/2)开始到1 DownAdjust(a,i,size);&#125;void HeapSort(int a[],int size)&#123; BuildHeap(a,size); for(int i=size;i&gt;=1;i--)&#123; swap(a[1],a[i]); //将堆顶放在末尾 DownAdjust(a,1,i-1); //将未完成排序的部分进行堆排序 &#125;&#125;int main()&#123; int array[8] = &#123;8, 1, 14, 3, 21, 5, 7, 10&#125;; HeapSort(array,8); for(int i=1;i&lt;9;i++) cout&lt;&lt;array[i]&lt;&lt;" "; return 0;&#125; Trie树struct Trie&#123; //字典树定义 Trie* next[26]; int num; //以当前字符串为前缀的单词的数量 Trie() //构造函数 &#123; int i; for(i=0;i&lt;26;i++)&#123; next[i] = NULL; &#125; num=0; &#125;&#125;;Trie root;void Insert(char word[]) //将字符串word插入到字典树中&#123; Trie *p = &amp;root; int i; for(i=0;word[i];i++)&#123; //遍历word的每一个字符 if(p-&gt;next[word[i]-'a']==NULL) //如果该字符没有对应的节点 p-&gt;next[word[i]-'a'] = new Trie; //创建一个 p = p-&gt;next[word[i]-'a']; p-&gt;num++; &#125;&#125;int Find(char word[]) //返回以字符串word为前缀的单词的数量&#123; Trie *p = &amp;root; int i; for(i=0;word[i];i++)&#123; //在字典树找到该单词的结尾位置 if(p-&gt;next[word[i]-'a']==NULL) return 0; p = p-&gt;next[word[i]-'a']; &#125; return p-&gt;num;&#125; 二叉树树结点结构struct BiNode&#123; char data; BiNode *lchild,*rchild;&#125;; 创建二叉树此处是按先序序列构造一颗二叉树 BiNode *BiTree::Create()&#123; char c; c=cin.get(); BiNode *pnode; if(c=='#') pnode=NULL; else&#123; pnode=new BiNode; pnode-&gt;data=c; pnode-&gt;lchild=Create(); pnode-&gt;rchild=Create(); &#125; return pnode;&#125; 前序遍历【访问顺序】根左右 递归方法void BiTree::PreOrder(BiNode *node)&#123; if(node == NULL) //递归调用的结束条件 return ; else&#123; cout&lt;&lt;node-&gt;data; //访问根节点的数据域 PreOrder(node-&gt;lchild); //前序递归遍历左子树 PreOrder(node-&gt;rchild); //前序递归遍历右子树 &#125;&#125; 非递归方法【思路】 对任一结点 访问结点p，并将p入栈 判断结点p的左孩子是否为空 若为空，则弹出栈顶结点，将栈顶结点的右孩子置为当前结点p，循环至1 若不为空，则将结点p的左孩子置为当前结点p 直到结点p为NULl且栈为空，遍历结束。 void BiTree::PreOrderNonRec(BiNode *node)&#123; if(node == NULL) return ; stack&lt;BiNode *&gt; s; BiNode *p=node; while(p!=NULL || !s.empty())&#123; while(p!=NULL)&#123; cout&lt;&lt;p-&gt;data; s.push(p); p=p-&gt;lchild; &#125; if(!s.empty())&#123; p=s.top(); s.pop(); p=p-&gt;rchild; &#125; &#125;&#125; 中序遍历【访问顺序】左根右 递归方法void BiTree::InOrder(BiNode *node)&#123; if(node==NULL) return ; else&#123; InOrder(node-&gt;lchild); cout&lt;&lt;node-&gt;data; InOrder(node-&gt;rchild); &#125;&#125; 非递归方法对于任一结点p： 判断当前结点p左孩子结点是否为空 若其左孩子结点不为空，则将p入栈，并将p的左孩子结点置为当前p，对当前结点p做相同处理。 若其左孩子结点为空，则弹出栈顶结点，将当前结点p置为栈顶结点的右孩子结点。 直到当前结点p为NULL且栈为空，遍历结束。 void BiTree::InOrderNonRec(BiNode *node)&#123; if(node==NULL) return; stack&lt;BiNode *&gt; s; BiNode *p=node; while(p!=NULL || !s.empty())&#123; while(p!=NULL)&#123; s.push(p); p=p-&gt;lchild; &#125; if(!s.empty())&#123; p=s.top(); cout&lt;&lt;p-&gt;data; s.pop(); p=p-&gt;rchild; &#125; &#125;&#125; 后序遍历【访问顺序】左右根 递归方法void BiTree::PostOrder(BiNode *node)&#123; if(node==NULL) return; else&#123; PostOrder(node-&gt;lchild); PostOrder(node-&gt;rchild); cout&lt;&lt;node-&gt;data; &#125;&#125; 非递归方法【思路】要保证根结点在左孩子和右孩子访问之后才能访问。 对于任一结点p， 将p入栈 若结点p不存在左孩子结点和右孩子结点，则直接访问该结点p； 若结点p存在左孩子结点或右孩子结点，但其左孩子结点和右孩子结点都已被访问，则直接访问该结点p 若非上述两种情况，则将结点p的右孩子结点和左孩子结点依次入栈，这就保证了每次取栈顶元素时，左孩子在右孩子前面被访问，左孩子和右孩子在根结点前被访问。 void BiTree::PostOrderNonRec(BiNode *node)&#123; if(node==NULL) return ; stack&lt;BiNode *&gt; s; BiNode *p;//当前结点 BiNode *pre=NULL;//前一次访问的结点 s.push(node); while(!s.empty())&#123; p=s.top(); //如果当前结点没有孩子结点或孩子结点都被访问过 if((p-&gt;lchild == NULL &amp;&amp; p-&gt;rchild == NULL)||(pre!=NULL&amp;&amp;(pre==p-&gt;lchild || pre==p-&gt;rchild)))&#123; cout&lt;&lt;p-&gt;data; s.pop(); pre=p; &#125;else&#123; if(p-&gt;rchild != NULL) s.push(p-&gt;rchild); if(p-&gt;lchild != NULL) s.push(p-&gt;lchild); &#125; &#125;&#125; 层序遍历层序遍历需要用到队列，使用#include&lt;queue&gt; void BiTree::LevelOrder(BiNode *node)&#123; //使用队列实现 queue&lt;BiNode*&gt; q; BiNode *s=node; if(s==NULL) return; q.push(s); while(!q.empty())&#123; s=q.front(); q.pop(); cout&lt;&lt;s-&gt;data; if(s-&gt;lchild!=NULL) q.push(s-&gt;lchild); if(s-&gt;rchild!=NULL) q.push(s-&gt;rchild); &#125;&#125; 深度优先遍历【思路】 即前中后序三种遍历方式。 这里给出深度优先前序遍历的另一种实现方式，利用栈。 void BiTree::DFS(BiNode *node)&#123; stack&lt;BiNode*&gt; s; BiNode *p; s.push(node); while(!s.empty())&#123; p=s.top(); cout&lt;&lt;p-&gt;data; s.pop(); if(p-&gt;rchild != NULL) s.push(p-&gt;rchild); if(p-&gt;lchild != NULL) s.push(p-&gt;lchild); &#125;&#125; 广度优先遍历【思路】 即层次遍历 求深度【思路】 每个节点都有自己的左右子树 每次返回当前节点左右子树长度大的那个 int BiTree::GetTreeDepth(BiNode *node)&#123; int lchildDep=1; int rchildDep=1; //如果根节点为空，深度为0，返回0，递归的出口 //否则深度至少为1，然后累加它们左右子树的深度 if(node == NULL) return 0; lchildDep+=GetTreeDepth(node-&gt;lchild); rchildDep+=GetTreeDepth(node-&gt;rchild); return (lchildDep&gt;rchildDep)?(lchildDep):(rchildDep);&#125; 求两个节点距离翻转二叉树 递归方法【思路】先翻转左子树，再翻转右子树，然后对整个树进行翻转 void BiTree::invertTree(BiNode *node)&#123; if(node == NULL) return ; swap(node-&gt;lchild,node-&gt;rchild); invertTree(node-&gt;lchild); invertTree(node-&gt;rchild);&#125; 非递归方法【思路】 与二叉树的层序遍历类似，需要queue实现 把根结点入队列，从队列中取出，交换左右孩子结点。若存在则分别将左右孩子结点入队，以此类推直到队列中没有结点则停止。 void BiTree::invertTreeNonRec(BiNode *node)&#123; if(node == NULL) return ; queue&lt;BiNode *&gt; q; q.push(node); while(!q.empty())&#123; BiNode *cur=q.front(); q.pop(); BiNode *tmp=cur-&gt;lchild; cur-&gt;lchild=cur-&gt;rchild; cur-&gt;rchild=tmp; if(cur-&gt;lchild != NULL) q.push(cur-&gt;lchild); if(cur-&gt;rchild != NULL) q.push(cur-&gt;rchild); &#125;&#125; 表达式求值中缀表达式【概念】 中缀表达式是指运算符在运算数中间。 【思路】 需要两个栈：操作数栈和操作符栈 如果是数字，压入操作数栈。 如果是操作符 当前是加减法 若栈顶是加减乘除，则计算栈内直到操作符栈顶不是加减乘除或为空，压栈。 否则直接压栈。 当前是乘除法 若栈顶是乘除，计算直到操作符栈顶不是乘除或者为空，压栈。 否则直接压栈。 当前是左括号，压栈。 当前是右括号，计算直到遇到左括号。 当所有的分析完后，循环计算栈顶直到操作符栈为空，此时操作数栈里只有一个元素，即最后的结果。 【范例】 1 + 2 *（3 + 4 * 5） 计算过程 数栈 操作符栈 1 1 2 1 + 3 1、2 + 4 1、2 +、* 5 1、2、（ +、* 6 1、2、（、3 +、* 7 1、2、（、3 +、*、+ 8 1、2、（、3、4 +、*、+ 9 1、2、（、3、4 +、、+、 10.1 1、2、（、3、4、5 +、、+、 10.2 1、2、（、3、20 +、*、+ 11 1、2、23 +、* 12 1、46 + 13 47 https://blog.csdn.net/wangzengdi/article/details/47023653 https://segmentfault.com/a/1190000005659574 动态规划乘积最大子序列【题目描述】 找出一个序列中乘积最大的连续子序列（至少包含一个数） 【思路】 data[i]：第i个数据 dp1[i]：以第i个数据结尾的连续子序列最大乘积 dp2[i]：以第i个数据结尾的连续子序列最小乘积 状态转移方程 dp1[i]=max(data[i],max(dp1[i-1] * data[i],dp2[i-1] * data[i])); dp2[i]=min(data[i],min(dp1[i-1] * data[i],dp2[i-1] * data[i])); 边界条件 dp1[0]=data[0]; dp2[0]=data[0]; 最后遍历dp1得到最大值即可 【题解】 double max(double a,double b)&#123;return a&gt;b?a:b;&#125;double min(double a,double b)&#123;return a&lt;b?a:b;&#125;int maxProduct(vector&lt;int&gt; &amp;nums) &#123; int len=nums.size(); if(len==0) return 0; vector&lt;double&gt; dp1(len); vector&lt;double&gt; dp2(len); //边界条件 dp1[0]=nums[0]; dp2[0]=nums[0]; for(int i=1;i&lt;len;i++)&#123; dp1[i]=max(nums[i],max(dp1[i-1]*nums[i],dp2[i-1]*nums[i])); dp2[i]=min(nums[i],min(dp1[i-1]*nums[i],dp2[i-1]*nums[i])); &#125; int index=0; for(int i=1;i&lt;len;i++) if(dp1[i]&gt;dp1[index]) index=i; return dp1[index];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】小米2015暑假实习笔试题]]></title>
    <url>%2Falgorithm-xiaomi2015%2F</url>
    <content type="text"><![CDATA[懂二进制题目描述：世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？ 题解： 【思路】两个数异或，因为两个数异或不同为1，相同为0，则统计1的个数即可。 异或运算，得到数c。 c&amp;(c-1)，从而统计1的个数。 class Solution &#123;public: int countBitDiff(int m, int n) &#123; int c=m^n; int count=0; while(c!=0)&#123; //得到的数c-1再进行逻辑与，可以统计有多少个1 //因为c末尾为1时，c-1，末尾为0； //c末尾为0时，c-1，向高位借1，若高位为1，则变为0，逻辑与后该高位变为0，低位也变为0 //若高位为0，则向更高位借1，更高位为0，逻辑与后，更高位为0，高位和低位也为0 //从而统计有多少个1 c=c&amp;(c-1); count++; &#125; return count; &#125;&#125;; 风口的猪——中国牛市题目描述：风口之下，猪都能飞。当今中国股市牛市，真可谓“错过等七年”。 给你一个回顾历史的机会，已知一支股票连续n天的价格走势，以长度为n的整数数组表示，数组中第i个元素（prices[i]）代表该股票第i天的股价。 假设你一开始没有股票，但有至多两次买入1股而后卖出1股的机会，并且买入前一定要先保证手上没有股票。若两次交易机会都放弃，收益为0。 设计算法，计算你能获得的最大收益。 输入数值范围：2&lt;=n&lt;=100,0&lt;=prices[i]&lt;=100 题解 小米Git题目描述：git是一种分布式代码管理工具，git通过树的形式记录文件的更改历史，比如： base’&lt;–base&lt;–A&lt;–A’ ^ | — B&lt;–B’ 小米工程师常常需要寻找两个分支最近的分割点，即base.假设git 树是多叉树，请实现一个算法，计算git树上任意两点的最近分割点。 （假设git树节点数为n,用邻接矩阵的形式表示git树：字符串数组matrix包含n个字符串，每个字符串由字符’0’或’1’组成，长度为n。matrix[i][j]==’1’当且仅当git树种第i个和第j个节点有连接。节点0为git树的根节点。） 题解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】面试题：链表]]></title>
    <url>%2Falgorithm-linkedlist%2F</url>
    <content type="text"><![CDATA[前述本文用到的链表节点的定义 struct Node&#123; int data; Node* next;&#125;; 有参构造函数头插法 template &lt;class DataType&gt;LinkList&lt;DataType&gt;::LinkList(DataType a[],int n)&#123; Node *first=new Node; fisrt-&gt;next=NULL; for(int i=0;i&lt;n;i++)&#123; Node *s=new Node; s-&gt;data=a[i]; s-&gt;next=first-&gt;next; first-&gt;next=s; &#125;&#125; ###尾插法 template&lt;class DataTpye&gt;LinkList&lt;DataType&gt;::LinkList(DataType a[],int n)&#123; Node *first=new Node; Node *r=first; for(int i=0;i&lt;n;i++)&#123; Node *s=new Node; s-&gt;data=a[i]; r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125; 在O(1)时间内删除链表节点题目描述：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。（Google面试题） 分析：本题与《编程之美》上的「从无头单链表中删除节点」类似。用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。 #include&lt;assert.h&gt;void deleteNode(Node *cur)&#123; assert(cur == NULL); assert(cur-&gt;next == NULL); Node *pNext=cur-&gt;next; pCur-&gt;data=pNext-&gt;data; pCur-&gt;next=pNext-&gt;next;&#125; 单链表逆置题目描述：输入一个单向链表，输出逆序反转后的链表 分析：非递归方法即就地逆置法，用三个临时指针pre,head,next在链表循环即可。 //单链表转置，循环方法Node* reverse(Node *head)&#123; if(head == NULL || head-&gt;next == NULL) return head; Node *pre=NULL; Node *next=NULL; while(head != NULL)&#123; next = head-&gt;next; head-&gt;next=pre; pre=head; head=next; &#125; return pre;&#125; 求单链表倒数第k个节点题目描述：输入一个单链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。 分析：设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。 //倒数第k个节点Node* theKthNode(Node *head,int k)&#123; if(k &lt; 0) return NULL; //异常判断 Node *slow,*fast; slow = fast = head; int i = k; for(;i&gt;0 &amp;&amp; fast!=NULL;i--) &#123; fast = fast-&gt;next; &#125; if(i &gt; 0) return NULL; //考虑k大于链表长度的case while(fast != NULL) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 判断单链表是否有环【题目描述】 单链表有环的定义：链表的尾节点指向了链接中间的某个节点。 如下图所示，如果有环，则遍历到结点7时，又重新回到结点3，结点3就是环的入口结点。 【思路】 采用快慢指针的思想，设两个工作指针，一个快一个慢，比如一个每次走一步，另一个每次走两步，如果链表有环，必定会在某个结点处相遇。 具体流程： 可以设置两个指针(fast,slow)，初始值均指向头，slow每次向前一步，fast每次向前两步； 如果链表中有环，则fast先进入环中，而slow后进入环中，两个指针在环中必定相遇; 如果fast遍历到尾部为NULL，则无环 int hasLoop(Node *head)&#123; Node *p1,p2; if(head == NULL || head-&gt;next == NULL) //链表为空，或者是单结点链表返回头结点 return 0; p1=p2=head; while(p1-&gt;next != NULL &amp;&amp; p1-&gt;next-next != NULL)&#123; p1=p1-&gt;next-&gt;next; p2=p2-&gt;next; if(p1==p2) return 1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Docker CE for Windows后VirtualBox无法启动问题解决]]></title>
    <url>%2Fdocker-virtualbox-problem%2F</url>
    <content type="text"><![CDATA[原因在Windows上运行Docker需要借助虚拟机来运行一个简化的Linux系统，Docker CE for Windows使用的是Windows系统自带的Hyper-V（从Win8开始）虚拟机组件。 因此在安装Docker CE for Windows时，会打开Hyper-V组件（默认是关闭的），会和Virtual Box冲突。 解决方案关闭Hyper-V组件控制面板-程序和功能-启用或关闭Windows功能，去掉Hpyer-V功能。重启。 打开Virtualbox依然报错 这是因为vboxdrv服务没有安装或成功启动，在Virtualbox安装目录下的drivers\vobxdrv文件夹下，右击VBoxDrv.inf，选择安装，然后重启。 如果还是失败，则直接重新安装即可。 安装老版Docker Toolbox老版Docker Toolbox使用的时Virtualbox虚拟机。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10下Docker简明教程]]></title>
    <url>%2Fwindows-docker%2F</url>
    <content type="text"><![CDATA[概述Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 内部结构 Docker使用C/S架构模式，Docker客户端会与Docker守护进程通信。Docker守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。 Docker分为三种部件： Docker镜像-Docker Images Docker容器-Docker Containers Docker仓库-Docker Registeries Docker镜像Docker运行容器前需要本地存在对应的镜像。Docker镜像可以用来创建Docker容器，一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序。 Docker镜像是只可读的，一个镜像可以创建多个容器。 通俗说，Images是已经打包好的环境文件，我们运行的时候把Images加载运行在本地容器中，你在这个容器中可以进行一些修改重新打包成新镜像上传。 分层存储因为镜像包含操作系统完整的root文件系统，其体积往往是巨大的，因此Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。 分层存储的特征使得镜像并非像一个ISO类似的打包文件，而是由一组文件系统组成。 Docker容器Docker利用容器来开发、运行应用。容器是镜像创建的实例，可以被开始、启动、停止、删除。每个容器都是相互隔离的。 Docker仓库仓库是集中存放镜像文件的场所。每个仓库中包含了多个镜像，每个镜像有不同的标签。 最大的公开仓库是DockerHub)，因为墙的原因，可以使用DaoCloud、阿里云)加速下载。 安装 Win10版本Docker安装以下版本Docker Community Edition 17.12.0-ce Win10之前版本安装Docker ToolBox，官方文档 安装之前，需要开启Windows10的Hpyer-V。 控制面板-程序-启用或关闭Windows功能 本文以Docker Community Edition为例，开启Hpyer-V后直接安装Docker Community Edition即可。 安装成功后，运行cmd,执行docker version，安装成功则显示下图 设置Docker任务栏鲸鱼图标右键-Settings打开设置界面 Shared Drivers：可以将主机（即Windows）中的驱动器共享到Docker Container中 Advanced：用于配置运行Docker Daemon的虚拟机环境的CPU和内存和镜像路径 Network：配置Docker的网络环境 Proxies：代理的配置 Docker Daemon：使用JSON格式的设置，对Docker Daemon进行设置，类似于在Linux中利用conf文件对Docker设置。 修改CPU数目及内存点击Advanced，如下图修改参数即可 修改代理Docker Hub速度较慢，修改为阿里云镜像。 登陆容器Hub服务，找到以下链接 点击Daemon设置镜像，直接在Registry mirrors中填写阿里云的镜像地址，点击Apply重启应用即可。 更改镜像默认存储路径打开Docker的Settings，点击Advanced，在Images and volumes VHD location选择新的路径。重启后即可更新设置。 常用命令查看Docker版本docker version 查看本机已安装镜像docker images 查看所有容器docker ps -a 拉取镜像docker pull Name:Tag 【例】 docker pull sameersbn/redmine:latest 删除单个容器docker rm Name/ID 删除所有的容器docker rm docker ps -a -q 停止、启动、杀死一个容器docker stop Name/IDdocker start Name/IDdocker kill Name/ID 参考 【Docker】windows10 docker 使用 Docker on Windows初体验 Docker for Windows使用简介 Docker的Windows容器初体验]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10下Docker搭建深度学习框架]]></title>
    <url>%2Fdocker-deeplearning%2F</url>
    <content type="text"><![CDATA[概述DeepoDeepo是一个几乎包含所有流行深度学习框架的Docker映像，拥有一个完整的可复制的深度学习研究环境。它涵盖了 theano tensorflow sonnet pytorch keras lasagne mxnet cntk chainer caffe torch 安装直接从Docker Hub下载Deepo镜像。Github地址 CPU版本 docker pull ufoym/deepo:cpu GPU版本 docker pull ufoym/deepo 运行打开powershell执行以下命令，以bash方式运行该容器。 docker run -it ufoym/deepo:cpu bash DL-docker包含的框架及系统依赖 Ubuntu 14.04 CUDA 7.5 (GPU version only) cuDNN v4 (GPU version only) Tensorflow Caffe Theano Keras Lasagne Torch (includes nn, cutorch, cunn and cuDNN bindings) iPython/Jupyter Notebook (including iTorch kernel) Numpy, SciPy, Pandas, Scikit Learn, Matplotlib A few common libraries used for deep learning 安装 cpu版本 docker pull floydhub/dl-docker:cpu 运行docker run -it -p 8888:8888 -p 6006:6006 -v /sharedfolder:/root/sharedfolder floydhub/dl-docker:cpu bash 运行以上命令后，会连接到bash，执行jupyter notebook。 然后在Windows的浏览器中输入localhost:8888，会连接到该容器的Jupyter notebook]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常见问题解决方法]]></title>
    <url>%2Fhexo-solve%2F</url>
    <content type="text"><![CDATA[fatal: HttpRequestException encountered. 将_config.yml中的repository: https://github.com:username/username.github.io.git 改成repository: git@github.com:username/username.github.io.git]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Jupyter Notebook]]></title>
    <url>%2Fwindows-jupyter-notebook%2F</url>
    <content type="text"><![CDATA[简介文学编程文学编程(Literate Programming)是由Donald Knuth提出的编程方法。传统的结构化编程，人要按照计算机的逻辑顺序来编写代码，而文学编程则可以让人们按照自己的逻辑来开发程序。 Jupyter NotebookJupyter Notebook是一个交互式笔记本，支持运行40多种编程语言。它的本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和markdown。 Jupyter Notebook优点： 适合数据分析 支持多语言 分享便捷 远程运行 交互式展示 ##安装 安装Anaconda即自带，不需要安装 启动点击Jupyter Notebook即可启动，或在cmd中输入jupyter notebook 默认地址为http:localhost:8888 使用更改Jupyter Notebook工作空间最新版Ipython和Jupyter配置文件是分开的，需要分别配置文件。 打开cmd输入命令jupyter notebook --generate-config 【注】-config之前没有空格 打开该目录下的文件，改文件夹路径 【注】若存在编码问题，可改成f://file//jupyter_notebook 启动Jupyter Notebook 新建Notebook点击new创建新的Notebook 界面 菜单栏各项功能概述 File Save and Checkpoint 保存并记录点，类似于不同版本 Revert to Checkpoint返回到某一记录点 View Toggle Header是否显示头部信息，包括文件名和上次保存时间 Toggle ToolBar是否显示工具栏 Kernel Change kernel更换内核环境 Notebook文档由一系列单元(cell),主要有两种形式的单元： 代码状态单元：编写代码的区域，使用Shift+Enter运行代码，结果显示在本单元下方。代码单元左边有In[1]：类似的序列标记，方便人们查看代码的执行次序。 Markdown状态单元：编写文本的区域，使用Shift+Enter显示格式化的文本。 模式 编辑模式：编辑文本和代码。选中单元按Enter进入编辑模式，单元左侧显示绿色竖线 命令模式：执行输入的命令。按Esc进入命令模式，单元左侧显示蓝色竖线 快捷键命令模式 查看快捷键：H 执行当前单元，并自动跳到下一个单元：Shift+Enter 执行当前单元，不自动跳到下一个单元：Ctrl+Enter 进入编辑模式：Enter 进入命令模式：Esc 删除当前单元：双击D 变为代码状态：Y 变为Markdown状态：M 在下方插入新单元：B 剪切选中单元：X 复制选中单元：C 粘贴到下方单元：V 选中上方单元：J 选中下方单元：K 恢复删除的最后一个单元：Z 保存当前Notebook：Ctrl+S 编辑模式 代码缩进或补全：Tab 代码提示：Shift+Tab 注释：Ctrl+/ Magic命令Magic命令以%或%%开头 %：行命令 %%：单元命令。必须出现在单元第一行。 以下为常用Magic命令 %lsmagic：列举所有Magic命令 %magic：查看Magic命令说明 %timeit：代码运行时间 %matplotlib inline：显示matplotlib包生成的图形 使用技巧运行Python文件运行以下命令 %run xxx.py 【注】xxx.py是当前工作空间下的一个python文件 导入代码运行以下命令 %load xxx.py 【注】xxx.py是当前工作空间下的一个python文件 重置单元格序号重置单元格In[x]序号 点击Kernel-Restart即可。 使用Seaborn绘图需要使用%matplotlib inline命令。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下安装Anaconda]]></title>
    <url>%2Fubuntu-ancaconda%2F</url>
    <content type="text"><![CDATA[Anaconda安装下载使用Python3.6版本的Anaconda 5.1，点击下载 安装 进入到下载后的文件目录，执行 bash Anaconda3-5.1.0-Linux-x86_64.sh 根据提示输入回车 查看注册信息，一直回车到输入yes 输入安装目录路径，默认回车即可 是否加入环境变量，输入yes 安装成功后，新打开一个终端输入以下命令查看版本号 anaconda -V 使用Jupyter Notebook输入以下命令则能够使用Jupyter Notebook ipython notebook]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[武大植物分布]]></title>
    <url>%2Fwhu-plants%2F</url>
    <content type="text"><![CDATA[文理学部李达塑像 樟树 蝴蝶花：4月，鸢尾科 鸢尾 吉祥草：百合科，秋花 南天竹：小檗科 锦绣杜鹃：杜鹃科 麦冬：百合科，6月开花 池衫 羊蹄：蓼科，酸模属 车前 蛇莓：蔷薇科，果不能吃 扬子毛茛 何首乌：蓼科 鸡矢藤：蓼科 海仙花 紫丁香 厚萼凌霄：位于亭子，6月开花 紫荆：苏木亚科，早春 工学部世纪广场 二球悬铃木 樟树 棕榈 复羽叶栾树 洋玉兰：常绿乔木，椭圆形革质叶 玉兰（白玉兰）：落叶乔木，先叶开花 结香：瑞香科，早春开花，先叶开花，花香久闻头疼 苏铁（铁树）：裸子植物，苏铁科 鹅观草：位于世纪广场草丛，下同 棒头草 雀麦 菵草 看麦娘 瓶尔小草：蕨类，此类是野生，不属于武大常规品种 绶草（盘龙参）：兰科，此类是野生，不属于武大常规品种 医学部广场 雪松 桂花（木犀） 樟树 池衫 细叶结缕草：位于广场草地，下同 狗牙根 早熟禾：早春开花 救荒野豌豆：荚果，比下类野豌豆果长 四籽野豌豆：荚果， 匍茎通泉草：玄参科，通泉草属，二唇形花 直立婆婆纳：玄参科 垂丝海棠：，蔷薇科苹果亚科苹果属，不位于广场，下同 贴梗海棠：灌木状，木瓜属，结果 槐树：豆科 喜树：珙桐科 信部星湖园 孝顺竹：丛生，禾本科 君迁子（黑枣）： 旱柳：星湖周围，下同 垂柳 榔榆：榆科，秋花秋果 朴树：榔榆旁边 木瓜：蔷薇科，树皮类似迷彩服 臭椿：苦木科 侧柏：柏科 柏木 武大牌坊入口区 金叶女贞 大叶黄杨 樟树 人文馆 桂花 圆柏 海桐 含笑 大叶黄杨 龙爪槐 桃花：距离人文馆稍远处，下同 梅花 山茶 紫薇 情人坡 池衫 山茶 垂丝海棠 贴梗海棠 湖北海棠 木瓜 茶港教工宿舍区小游园 枇杷 桂树 西区教工宿舍小游园 广玉兰 桂树 雪松 棕榈 小叶女贞 大叶黄杨 紫藤 中心湖区 秤锤树 杜仲 榔榆 朴树 小叶栎 皂荚 毛竹 紫叶李 绣球荚蒾 红继木 鸡爪槭 红枫 蝴蝶花 麦冬 酢浆草 珞珈山枫园路 水杉 枫树 棕榈 桂树 石楠 柑橘 鸡爪槭 紫叶李 老图书馆王世杰塑像 银杏 黑松 刺柏 黄连木 石榴 海桐 王星拱塑像 女贞 棕榈 海桐 法国冬青 西侧入口 石榴 南天竹 桂树 石榴 桑树 落木石楠 朴树 东侧入口 石楠 英国梧桐 龙柏 棕榈 侧柏 广玉兰 大楼前与老斋舍接邻草地 大叶黄杨 油茶 石榴 侧柏 棕榈 柑橘 黑松 红檵木 狗牙根 老斋舍顶从东到西的种植槽 龙柏 椤木石楠 竹 木槿 紫藤 圆柏 刺柏 行政楼行政楼内左右两侧的绿化圃 龙柏 吉祥草 行政楼东侧 对节白蜡 樱花基于《珞珈山原色植物图谱》 240号红花高盆樱：2月底至三月初开花，位于梅园校医院 241号尾叶樱桃：3-4月开花，位于行政楼旁，即绿樱，橘黄色果 242号大岛樱：3-4月开花，鲲鹏广场后的花园有几株 243号东京樱花：4月开花，奥场周围，樱花大道，黑果 244号垂枝樱花：3月底至四月初开花，晚樱，位于枫园14舍，岔路口通往枫园食堂。枫园三舍南侧路边、樱园南坡绿地（即情人坡） 245号日本晚樱：4月开花，教五周围，樱花大道和梅操之间情人坡，鲲鹏广场 信部星湖东侧： 山樱花：又称福岛樱或青肤樱，4月初开花，花期15-20天，位于校医院前、教四前、樱园入口路旁、樱园南坡绿地（下沉花园） 绿线学府路 樟树：行道树 金叶女贞：位于花坛 大叶黄杨：位于花坛 科技路 广玉兰：生科院到教四楼行道树 银杏：生科院到教四楼行道树 大叶黄杨 英国梧桐：教四到樱园路行道树 综述用途分类行道树 银杏 雪松 池衫 水杉 三角枫 枫树 梅树 桂树 女贞 樟树 广玉兰 英国梧桐 垂柳 石楠 樱树 园景树 樱树 圆柏 龙柏 重阳木 拐枣 榉树 榔榆 朴树 三角枫 雪松 杜英 水杉 乌桕 复羽叶栾树 梧桐 国槐 石楠 白玉兰 棕榈 黄连木 花灌类 红枫 紫薇 卫矛 紫叶桃 紫叶李 海桐 金丝桃 八角金盘 南天竹 竹叶椒 杜鹃 云南黄馨 月季 火棘 枸骨 绿篱类 马甲子 栀子 十大功劳 金心黄杨 雀舌黄杨 紫叶小檗 法国冬青 花坛花境类 月季 杜鹃 葱兰 一串红 一串蓝 火棘 重瓣棣棠 石蒜 大花马齿苋 夜来香 柳叶马鞭草 矮亚菊 山茶 夹竹桃 结香 木槿 中华绣线菊 凤尾鸡冠花 金盏菊 雏菊 金鸡菊 玉簪 萱草 美人蕉 锦带花 金钟花 观赏特性观形树 樟树 桂花 银杏 池衫 水杉 马尾松 雪松 侧柏 龙柏 广玉兰 英国梧桐 石楠 椤木石楠 红檵木 垂柳 朴树 大叶黄杨 三角枫 鸡爪槭 女贞 白花泡棢 榔榆 日本冷杉 黑松 金钱松 杉木 日本柳杉 落羽杉 日本花柏 罗汉松 鹅掌楸 粗榧 润楠 合欢 黄杨 雀舌黄杨 交让木 旱柳 胡桃 化香 卫矛 珊瑚朴 榆树 榉树 乌桕 重阳木 南酸枣 黄连木 盐肤木 中华槭 金钟花 白蜡树 十大功劳 紫薇 毛泡桐 七叶树 观花树春 含笑 白玉兰 桃 湖北海棠 李 梅 樱 麻叶绣线菊 中华绣线菊 重瓣棣棠 紫荆 瑞香 连翘 金钟花 探春花 云南黄馨 毛泡桐 白花泡桐 夏 广玉兰 金樱子 小果蔷薇 山合欢 合欢 绣球 山茱萸 荚蒾 红檵木 栾树 栀子 金丝桃 六月雪 春夏 紫藤 锦鸡儿 忍冬 锦带花 芜花 石楠 夏秋 白兰 糯米条 六道木 木槿 木芙蓉 多花勾儿茶 夹竹桃 牡荆 石榴 锦葵 秋 决明 冬春 腊梅 油茶 四季 月季 杜鹃 桂花 观叶树木春 山麻秆 石楠 秋 金钱松 落羽杉 水杉 池衫 银杏 鹅掌楸 榔榆 朴树 榆树 榉树 美国地锦 三角枫 鸡爪槭 中华槭 英国梧桐 重阳木 七叶树 四季 紫叶桃 紫叶李 特殊叶形 紫荆 八角枫 八角金盘 黄杨 雀舌黄杨 锦熟黄杨 旱柳 垂柳 海桐 爬山虎 美国地锦 大叶黄杨 夹竹桃 苏铁 杂集 秤锤树：位于未名湖畔东南角 大叶黄杨：位于梅园花坛 鹅掌楸：花期4-5月，枫园五舍、工学部网球场、珞珈广场 含笑：花期4-6月，位于标本馆前、校医院前花坛 红花酢浆草：校园花坛广布 红花石蒜：位于樱花大道至标本馆一带 海桐：花期4-5月，人文馆周边 合欢：珞珈山庄背面山坡、鲲鹏广场 花木兰：学校行道树 金丝桃：花期7-8月，梅园花坛 金银花：又名忍冬，花期4-6月，路旁、山坡灌丛、疏林中 鸡冠花：花期8-10月，花坛栽培 郁李：位于樱园 鸢尾：梅园花坛 棕榈：茶港教工生活区行道树 水杉：茶港教工生活区行道树 马尾松：南三区教工宿舍区 石榴：南三区教工宿舍区 女贞：狮子山、行政楼 枫树：枫园、奥场、珞珈广场 枫香树：枫园 桑树：信部、樱顶 樱花大道旁8棵银杏是20世纪30年代珞珈山建校初期栽植 罗汉松：育才路 绿樱：行政楼前 美人梅：梅园，梅和紫叶李杂交 阿拉伯婆婆纳： 柞树：武大附小花坛旁 南酸枣：武大梅园，名木]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】Python中字典常用方法]]></title>
    <url>%2Fpython-dict%2F</url>
    <content type="text"><![CDATA[字典常用操作定义空字典dic=&#123;&#125; 键值对的添加dic['name']='zhangsan' 字典遍历通过items()方法返回的元组列表进行序列解包 for key,value in dic.items(): print('&#123;&#125;:&#123;&#125;'.format(key,value)) #print('%s:%s' %(key,value)) 字典排序字典按键排序第一类dic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;print(key,dic[key] for key in sorted(dic.keys)) 第二类dic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;#升序排序dic=dict(sorted(dic.items(),key=lambda x:x[0]))#降序排序dic=dict(sorted(dic.itmes(),key=lambda x:x[0],reverse=True)) sorted(iterable,key,reverse) iterable参数代表可以迭代的对象，例如可以是dict.items()，dict.keys() key参数是一个函数，用来选取参与比较的元素 reverse参数用来指定是升序还是降序 dic=dict(sorted(dic.items(),key=lambda x:x[0])) dic.items()将dic转换为可迭代对象，迭代对象的元素为该字典元素，将其转换为元组 key参数对应的lambda表达式即选取元组中的第一个元素作为比较参数，即键。 lambda x:yx表示输出参数，y表示lambda函数的返回值. sorted()函数返回值是list类型。 字典按值排序并输出Top K个元素dic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;#升序排序dic=dict(sorted(dic.items(),key=lambda x:x[1]))#降序排序dic=dict(sorted(dic.itmes(),key=lambda x:x[1],reverse=True))#输出Top K个cnt=0k=10for key,value in dic.items(): cnt+=1 if cnt&gt;k: break print('&#123;&#125;:&#123;&#125;'.format(key,value)) 字典对象写入Json文件import jsondic=&#123; "key1": 5, "key2": 6, "key3": 4, "key4": 3,&#125;#中文字符需要设置ensure_ascii属性为False，否则输出为ASII码data=json.dumps(dic,ensure_ascii=False)with open('xxx.json','w',encoding='utf-8') as f: f.write(data)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】Python的switch-case实现]]></title>
    <url>%2Fpython-switch%2F</url>
    <content type="text"><![CDATA[前言在Python中，并没有实现switch-case语句，通过if-elif实现会显得麻烦，因此通过以下方式实现该语句功能。 实现方式通过字典实现以如下情景为例，将百分制分数转换为五分制分数。如100%转换为5，80%转换为4等。 def foo(score): return &#123; '100%':5, '80%':4, '60%':3, '40%':2, '20%':1, '0%':0 &#125;.get(score)print(foo('100%')) #输出5print(foo('80%')) #输出4 通过匿名函数实现def foo(score,x): return&#123; '100%':lambda x:x+5, '80%':lambda x:x+4, '60%':lambda x:x+3, '40%':lambda x:x+2, '20%':lambda x:x+1, '0%':lambda x:x+0, &#125;[score](x) print(foo('100%',0)) #输出5print(foo('80%',0)) #输出4]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下pip更换源地址]]></title>
    <url>%2Fwindows-pip%2F</url>
    <content type="text"><![CDATA[打开cmd，输入 echo %APPDATA% 进入到显示的路径中 进入该路径，新建pip文件夹，然后在该文件夹下新建pip.ini 编辑pip.ini，输入以下内容，即把源地址改为阿里云地址。 [global]timeout = 6000index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seaborn库的使用]]></title>
    <url>%2Fseaborn%2F</url>
    <content type="text"><![CDATA[CountPlot%matplotlib inlineimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as snstrain_data=pd.read_csv('./data/train.csv')sns.countplot(x='Score',data=train_data) sns.countplot(x=&#39;Score&#39;,data=train_data) 【注】 属性x为x轴名称，值必须为数据集中的列名。属性x或y中任一一组没有值，则默认count 属性data为数据集，值可以为pandas的dataframe类型。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汽车口碑分析】3.爬取汽车评论数据]]></title>
    <url>%2Fautomobile-analysis-3%2F</url>
    <content type="text"><![CDATA[环境配置 Ubuntu 16.04 Python 3.5 技术框架 Scrapy 需求目标本项目为汽车口碑分析，第一步需要爬取对于不同车型的评论数据。 选择58车的车型分类爬取评论数据。 爬取流程 先获取每个车型的链接，以下图中红框内的车型为例 打开链接后，抓取下图红框中的总评分，写入文件中。 写入总评分后，通过拼接链接进入该车型的用户评论页面。 通过第一步中获取的链接拼接上list_s1_p1.html，组成用户评论页面的链接。 【注】此为第一页的链接，若还有下一页，下述步骤会提及处理方法。 抓取评论页面中的各种数据，如id，评分，评论等。 若该评论页面还有下一页，则继续抓取下一页中的评论数据。 【方法】 判断页面中是否有下一页元素，若有则回调解析评论页面的方法。 将爬取的数据保存到文件中。 详细步骤创建新工程先创建工程目录 cd /home/t/dataset/mkdir carSpider 创建新工程 scrapy startproject carSpider 编辑items.py文件# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# http://doc.scrapy.org/en/latest/topics/items.htmlimport scrapyclass CarspiderItem(scrapy.Item): file=scrapy.Field() #文件名 car=scrapy.Field() #车型 score=scrapy.Field() #总评分 u_id=scrapy.Field() #用户ID u_score=scrapy.Field() #用户评分 u_merit=scrapy.Field() #用户评论优点 u_demerit=scrapy.Field() #用户评论缺点 u_summary=scrapy.Field() #用户评论综述 u_flower=scrapy.Field() #用户评论鲜花数 u_brick=scrapy.Field() #用户评论板砖数 编写carSpider.py文件import scrapyfrom carSpider.items import CarspiderItembaseDir = '/home/t/dataset/carRemark/'startUrl='http://www.58che.com/brand.html'class CarSpider(scrapy.Spider): name='spider' #爬虫名 def __init__(self): self.start_urls=[startUrl] #第一层解析方法 def parse(self,response): #定位到车型元素 subclasses=response.css('body &gt; div.fltop &gt; div.marcenter &gt; div &gt; div &gt; div.r &gt; ul &gt; li &gt; dl &gt; dt &gt; a') for subclass in subclasses: subclass_name=subclass.xpath('text()').extract_first() #获取车型名称文本 subclass_link=subclass.xpath('@href').extract_first() #获取车型链接 yield scrapy.Request(url=subclass_link,callback=self.parse_car_subclass,meta=&#123;'file':subclass_name&#125;) #回调下一层解析方法，并把车型名称传递给该方法作为文件名 #第二层解析方法 def parse_car_subclass(self,response): infos=response.css('#line1 &gt; div.cars_line2.l &gt; div.dianpings &gt; div.d_div1.clearfix &gt; font') #定位到总评分元素 for info in infos: score=info.xpath('text()').extract_first() #获取总评分元素文本 file=response.meta['file'] #获取上个Request传递来的meta['file'] self.writeScore(file,score) #将总评分写入文件中 link=response.url+'list_s1_p1.html' #拼接用户评论第一页链接 yield scrapy.Request(url=link,callback=self.parse_remark,meta=&#123;'file':file&#125;) #回调下一层解析方法，把车型名称传递给该方法作为文件名 #第三层解析方法 def parse_remark(self,response): #定位到用户评论元素 infos=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; dl') for info in infos: uid=info.xpath('dd[1]/strong/a/text()')[0].extract() #获取用户ID score=info.xpath('dd[1]/div/div/@style')[0].extract() #获取用户评分星级 score=self.getScore(score) #将用户评分星级转化为5分制评分 try: #先获取是否有‘优点’元素，若有则定位‘优点’元素的下一个兄弟节点，即‘优点评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l redc00")]')[0] if node is not None: merit=node.xpath('following-sibling::*[1]/text()')[0].extract() else: merit='' except: merit='' try: #先获取是否有‘缺点’元素，若有则定位‘缺点’元素的下一个兄弟节点，即‘缺点评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l hei666")]')[0] if node is not None: demerit=node.xpath('following-sibling::*[1]/text()')[0].extract() else: demerit='' except: demerit='' try: #先获取是否有‘综述’元素，若有则定位‘综述’元素的下一个兄弟节点，即‘综述评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l")]')[0] if node is not None: summary=node.xpath('following-sibling::*[1]/text()')[0].extract() else: summary='' except: summary='' flower=info.xpath('dd[2]/div[contains(@class,"apply")]/a[3]/span/text()')[0].extract() #获取鲜花数 brick=info.xpath('dd[2]/div[contains(@class,"apply")]/a[4]/span/text()')[0].extract() #获取板砖数 #创建Item item=CarspiderItem() item['file']=response.meta['file'] item['u_id']=uid item['u_score']=score item['u_merit']=merit item['u_demerit']=demerit item['u_summary']=summary item['u_flower']=flower item['u_brick']=brick #生成Item yield item #获取`下一页`元素，若有则回调`parse_remark`第三层解析方法，即继续获取下一页用户评论数据 #定位`下一页`元素 next_pages=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; div &gt; a.next') for next_page in next_pages: #若有`下一页`元素，则拼接`下一页`元素链接，并回调第三层解析方法，用来获取下一页用户评论数据 if next_page is not None: next_page_link=next_page.xpath('@href')[0].extract() next_page_link='http://www.58che.com'+next_page_link file=response.meta['file'] yield scrapy.Request(url=next_page_link, callback=self.parse_remark, meta=&#123;'file': file&#125;) #将总评分写入文件 def writeScore(self,file,score): with open('/home/t/dataset/carRemark/'+file+'.json','a+') as f: f.write(score+'\n') #将用户评分星级转为5分制分数，类似switch功能 def getScore(self,text): text=text.split(':')[1] #分割文本，原文本格式形如`width:100%`，分割并截取`:`后的文本 return &#123; '100%':5, '80%':4, '60%':3, '40%':2, '20%':1, '0%':0 &#125;.get(text) 【解析】 #定位到用户评论元素 infos=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; dl') 此句代码定位的元素如下图所示，定位到的是评论页面每条评论的元素整体。 for info in infos: uid=info.xpath('dd[1]/strong/a/text()')[0].extract() #获取用户ID score=info.xpath('dd[1]/div/div/@style')[0].extract() #获取用户评分星级 score=self.getScore(score) #将用户评分星级转化为5分制评分 uid定位到的元素如下图所示， score定位到的元素如下图所示，获取score元素的style属性，值形如width:80%，需要通过getScore()方法转换为五分制分数。 try: #先获取是否有‘优点’元素，若有则定位‘优点’元素的下一个兄弟节点，即‘优点评语’，若无则为空 node=info.xpath('dd[2]/div/div[contains(@class,"l redc00")]')[0] if node is not None: merit=node.xpath('following-sibling::*[1]/text()')[0].extract() else: merit=''except: merit='' 先定位是否有优点元素，如下图红框所示，若有该元素，则获取优点元素的下一个兄弟节点内容，如下图蓝框所示，若无则为空。 #获取`下一页`元素，若有则回调`parse_remark`第三层解析方法，即继续获取下一页用户评论数据#定位`下一页`元素next_pages=response.css('body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; div &gt; a.next') for next_page in next_pages: #若有`下一页`元素，则拼接`下一页`元素链接，并回调第三层解析方法，用来获取下一页用户评论数据 if next_page is not None: next_page_link=next_page.xpath('@href')[0].extract() next_page_link='http://www.58che.com'+next_page_link file=response.meta['file'] yield scrapy.Request(url=next_page_link, callback=self.parse_remark, meta=&#123;'file': file&#125;) 解析完上述内容，判断用户评论页面是否有分页，定位是否有下一页元素，如下图红框所示，若有则获取该元素链接，如下图橙框所示。 获取之后，回调parse_remark方法解析下一页的评论页面。 编辑pipelines.py文件# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: http://doc.scrapy.org/en/latest/topics/item-pipeline.htmlimport jsonimport codecsbaseDir = '/home/t/dataset/carRemark/'class CarspiderPipeline(object): def process_item(self, item, spider): print(item['file']) with codecs.open(baseDir+item['file']+'.json','a+',encoding='utf-8') as f: line=json.dumps(dict(item),ensure_ascii=False)+'\n' f.write(line) return item 编辑settings.py文件# -*- coding: utf-8 -*-# Scrapy settings for carSpider project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## http://doc.scrapy.org/en/latest/topics/settings.html# http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html# http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.htmlBOT_NAME = 'carSpider'SPIDER_MODULES = ['carSpider.spiders']NEWSPIDER_MODULE = 'carSpider.spiders'# Crawl responsibly by identifying yourself (and your website) on the user-agent#USER_AGENT = 'carSpider (+http://www.yourdomain.com)'# Obey robots.txt rulesROBOTSTXT_OBEY = False# Configure maximum concurrent requests performed by Scrapy (default: 16)#CONCURRENT_REQUESTS = 32# Configure a delay for requests for the same website (default: 0)# See http://scrapy.readthedocs.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docs#DOWNLOAD_DELAY = 3# The download delay setting will honor only one of:#CONCURRENT_REQUESTS_PER_DOMAIN = 16#CONCURRENT_REQUESTS_PER_IP = 16# Disable cookies (enabled by default)#COOKIES_ENABLED = False# Disable Telnet Console (enabled by default)#TELNETCONSOLE_ENABLED = False# Override the default request headers:#DEFAULT_REQUEST_HEADERS = &#123;# 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',# 'Accept-Language': 'en',#&#125;# Enable or disable spider middlewares# See http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.html#SPIDER_MIDDLEWARES = &#123;# 'carSpider.middlewares.CarspiderSpiderMiddleware': 543,#&#125;# Enable or disable downloader middlewares# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html#DOWNLOADER_MIDDLEWARES = &#123;# 'carSpider.middlewares.MyCustomDownloaderMiddleware': 543,#&#125;# Enable or disable extensions# See http://scrapy.readthedocs.org/en/latest/topics/extensions.html#EXTENSIONS = &#123;# 'scrapy.extensions.telnet.TelnetConsole': None,#&#125;# Configure item pipelines# See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; 'carSpider.pipelines.CarspiderPipeline': 300,&#125;# Enable and configure the AutoThrottle extension (disabled by default)# See http://doc.scrapy.org/en/latest/topics/autothrottle.html#AUTOTHROTTLE_ENABLED = True# The initial download delay#AUTOTHROTTLE_START_DELAY = 5# The maximum download delay to be set in case of high latencies#AUTOTHROTTLE_MAX_DELAY = 60# The average number of requests Scrapy should be sending in parallel to# each remote server#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0# Enable showing throttling stats for every response received:#AUTOTHROTTLE_DEBUG = False# Enable and configure HTTP caching (disabled by default)# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settingsHTTPCACHE_ENABLED = False#HTTPCACHE_EXPIRATION_SECS = 0#HTTPCACHE_DIR = 'httpcache'#HTTPCACHE_IGNORE_HTTP_CODES = []#HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' 【解析】 ROBOTSTXT_OBEY = False 将原来的True改为False。 ITEM_PIPELINES = &#123; 'carSpider.pipelines.CarspiderPipeline': 300,&#125; 将原来的注释去掉，即注册pipelines，否则无法使用该pipelines。 运行爬虫在项目根目录下新建文件entrypoint.py from scrapy.cmdline import executeexecute(['scrapy','crawl','spider']) 项目源码Github地址]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>汽车口碑分析</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】四——Pycharm运行Python版Spark程序]]></title>
    <url>%2Fspark-pycharm%2F</url>
    <content type="text"><![CDATA[前言此前搭建成功分布式Spark环境，此文介绍使用Pycharm运行Python语言的Spark程序。 操作步骤安装Pycharm 点击下载。 过程与安装Intellij IDEA类似，在此不在赘述。 进入到安装目录下执行 ./bin pycharm-sh 配置运行环境 创建新项目 新建一个Python文件，这里命名为main.py from pyspark import SparkContext,SparkConfconf=SparkConf().setAppName("sparkDemo").setMaster("local")sc=SparkContext(conf=conf)logFile='/data/input/README.txt' logData=sc.textFile(logFile).cache()numAs = logData.filter(lambda s: 'a' in s).count()numBs = logData.filter(lambda s: 'b' in s).count()print("Lines with a: %i, lines with b: %i" % (numAs, numBs)) logFile=&#39;/data/input/README.txt&#39; 此路径是之前运行Hadoop例程在HDFS中创建的/data/input文件夹以及上传到此文件夹的README.txt文件。 将Spark中的pyspark模块添加到Python环境变量中去 sudo vim /etc/profile 添加以下代码 export PYTHONPATH=$SPARK_HOME/libexec/python:$SPARK_HOME/libexec/python/build:$PYTHONPATH 更新配置 source /etc/profile 将/usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip解压。 tar -zxvf /usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip 将解压后的文件夹复制到/usr/spark-2.2.1-bin-without-hadoop/Python文件夹下。 sudo mv /usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j /usr/spark-2.2.1-bin-without-hadoop/Python 【注】 /usr/spark-2.2.1-bin-without-hadoop是spark安装目录。 py4j-0.10-4-src.zip根据版本号不同，文件名称也有差异 点击Run-Edit Configurations 点击左上角绿色+，选择Python 填写配置 Name：任起一个名字即可 Script path：执行的Python文件的路径。可以点右侧的下图中红框选择文件路径。 Environment variables：添加PYTHONPATH和SPARK_HOME变量。 PYTHONPATH：spark安装目录/python SPARK_HOME：spark安装目录 点击File-Settings-Project-Project Structure 点击右侧Add Content Root 添加/usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip和/usr/spark-2.2.1-bin-without-hadoop/Python/lib/pyspark.zip 运行即可 【注】若from pyspark import SparkContext,SparkConf下还有红线，则添加以下代码即可 import syssys.path.insert(1,'/usr/spark-2.2.1-bin-without-hadoop/python')]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】三——基于VirtualBox的Spark完全分布式环境]]></title>
    <url>%2Fvirtualbox-spark%2F</url>
    <content type="text"><![CDATA[前言Spark的搭建依赖于Hadoop，因此本文基于之前分布式Hadoop环境，JDK、Hadoop等已安装好， 系统环境 虚拟机：VirtualBox Linux：Ubuntu 16.04 LTS HAdoop 2.7.5 IDE：Intellij IDEA JDK 1.8.0_151 Scala-2.12.4 Spark-2.2.1 操作步骤安装Scala 下载Scala-2.12.4 解压到当前目录 tar -zxvf scala-2.12.4.tgz 将解压后的文件夹移动到/usr下 sudo mv scala-2.12.4/ /usr/ 配置环境变量 sudo vim /etc/profile 添加如下代码，路径根据情况自己修改 export SCALA_HOME=/usr/scala-2.12.4export PATH=$SCALA_HOME/bin:$PATH 更新环境变量配置 source /etc/profile 验证是否安装成功 scala -version 安装Spark 下载Spark，由于Spark基于Hadoop，且之前已经安装好Hadoop，所以下载没有绑定Hadoop的版本，所以选择spark-2.2.1-bin-without-hadoop.tgz 解压到当前目录 tar -zxvf spark-2.2.1-bin-without-hadoop.tgz 将解压后的文件夹移动到/usr/local/ sudo mv spark-2.2.1-bin-without-hadoop/ /usr/ 配置环境变量 sudo vim /etc/profile 添加以下代码 export SPARK_HOME=/usr/spark-2.2.1-bin-without-hadoopexport PATH=$PATH:$SPARK_HOME/binexport PATH=$PATH:$SPARK_HOME/sbin 更新环境变量配置 source /etc/profile Spark配置【注】此处以master主机为例，其他从机作相应更改 配置spark-env.shcd /usr/spark-2.2.1-bin-without-hadoop/conf/sudo cp spark-env.sh.template spark-env.shsudo vim spark-env.sh 添加以下代码 export SPARK_HOME=/usr/spark-2.2.1-bin-without-hadoopexport SPARK_DIST_CLASSPATH=$(/usr/hadoop-2.7.5/bin/hadoop classpath)export JAVA_HOME=/usr/jdk1.8.0_151export SCALA_HOME=/usr/scala-2.12.4export HADOOP_HOME=/usr/hadoop-2.7.5export HADOOP_CONF_DIR=/usr/hadoop-2.7.5/etc/hadoopexport SPARK_MASTER_IP=masterexport SPARK_MASTER_HOST=masterexport SPARK_LOCAL_IP=masterexport SPARK_WORKER_MEMEORY=1gexport SPARK_EXECUTOR_MEMEORY=1gexport SPARK_DRIVER_MEMORY=1gexport SPARK_WORKER_CORES=1 【注】 SPARK_LOCAL_IP为本地地址，从机需要更改为自己的IP 配置slavessudo cp slaves.template slavessudo vim slaves 添加所有从机的主机名 node1node2 启动集群因为Spark基于Hadoop，所以需要先启动Hadoop。 start-all.sh 再启动Spark，进入到Spark安装目录下的sbin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/sbin 执行sbin文件夹下的start-all.sh，若直接执行start-all.sh，启动的是Hadoop ./start-all.sh 查看集群查看进程jps 主机上显示以下进程 从机显示以下进程 通过Web查看状态在主机master上打开浏览器，访问http://localhost:8080 运行pyspark进入到spark安装目录下的bin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/bin/ 运行pyspark ./pyspark 运行spark-shell进入到spark安装目录下的bin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/bin/ 运行spark-shell ./sparkshell 以上，证明spark配置成功。 关闭集群同样进入到Spark安装目录下的sbin文件夹 cd /usr/spark-2.2.1-bin-without-hadoop/sbin./stop-all.sh]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】二——基于Hadoop的MapReduce程序]]></title>
    <url>%2Fhadoop-wordcount%2F</url>
    <content type="text"><![CDATA[此前配置好分布式Hadoop环境，此篇主要讲解通过Intellij IDEA编写分布式MapReduce程序以及利用Hadoop实现词频统计 系统环境 虚拟机：VirtualBox Linux：Ubuntu 16.04 LTS Hadoop 2.7.5 IDE：Intellij IDEA JDK 1.8.0_151 安装Intellij及破解 安装Intellij IDEA 破解Intellij IDEA 创建Hadoop工程创建新工程 打开Intellij IDEA，创建一个新工程 选择Java项目，并添加JDK路径 添加依赖包点击File-Project Structure 打开后点击左侧Modules，然后点击Dependencies 点击右侧+，选择JARs or directories，将下图所有依赖包的目录导入 【注】/usr/hadoop-2.7.5是Hadoop安装目录 编写代码新建一个类名为WordCount，代码如下 import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import java.io.IOException;import java.util.Iterator;import java.util.StringTokenizer;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one); &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125; &#125; 配置编译环境点击Run-Edit Configuration 点击左上角+，然后点击Application Name，即该运行配置的名字，这里命名为RunHadoop Main Class，即需要运行的主类，这里使用的默认包，所以填写WordCount Program arguments，即运行时需要输入的参数，此处填写参数为hdfs://master:9000/data/input/README.txt hdfs://master:9000/output/ 此处，第一个参数为输入文件路径，第二个参数为输出文件路径。 master:9000为分布式Hadoop环境中core-site.xml配置文件中fs.default.name的值 /data/input/README.txt为分布式Hadoop环境中利用 hdfs dfs -mkdir -p /data/inputhdfs dfs -put README.txt /data/input 创建并上传到HDFS系统中的文件路径。 【注】若hdfs://master:9000/output已经存在，需要手动删除 hdfs dfs -rm -r /output 查看运行结果web界面查看通过http://localhost:50070查看各个结点运行状况]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>文本分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分布式编程】一——基于VirtualBox的Hadoop完全分布式环境搭建]]></title>
    <url>%2Fvirtualbox-haddop%2F</url>
    <content type="text"><![CDATA[系统架构 虚拟机环境：VirtualBox Linux系统：Ubuntu 16.04 LTS 工具包 JDK1.8 Hadoop 2.7.5 拓扑结构：如下 操作步骤【注】本步骤以Master为例，其他虚拟机可以使用克隆功能复制，然后更改 安装常用软件安装vimsudo apt-get install vim 安装工具包设置共享文件夹 安装VirtualBox增强功能包,Ubuntu系统直接点击设备-&gt;安装增强功能 剩余步骤看教程 安装JDK 下载JDK-8u151 剩余步骤看教程 创建用户组创建用户组每个主机都需要加入到同一用户组。此处创建名为hadoop用户组 sudo addgroup hadoop 查看当前用户who 当前用户为t 添加当前用户到用户组sudo adduser t hadoop #sudo adduser user group 查看归属用户组groups t #group user 安装Hadoop下载Hadoop点击链接下载 解压Hadoop将文件复制到/Downloads/文件夹下进行解压 cd Downloads/tar -zxvf hadoop-2.7.5.tar.gz 将解压后的文件夹移动到/usr/文件夹 sudo mv hadoop-2.7.5/ /usr/ 配置文件需要配置的文件都在解压后的hadoop-2.7.5即usr/hadoop-2.7.5/文件夹中的/etc/hadoop/文件夹中 配置hadoop-env.shcd /usr/hadoop-2.7.5/etc/hadoop/sudo vim hadoop-env.sh 添加java安装路径 配置core-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/t/hadoop/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 【说明】 &lt;name&gt;fs.default.name&lt;/name&gt; 此参数设置NameNode的URI，此处设master主机为NameNode &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; 此参数设置Hadoop的一个临时目录，用来存放每次运行的作业jpb的信息。 此处设置/home/t/hadoop/tmp为临时目录，因没有此目录，因此需要先创建 sudo mkdir /home/t/hadoop/tmp 【附】 其他部分参数，如需要更多参数，请自查 参数 默认值 说明 fs.default.name file:/// NameNode的URI hadoop.tmp.dir 临时目录位置 hadoop.native.lib true 是否使用hadoop的本地库 hadoop.http.filter.initializers 空 设置Filter初始器 配置hdfs-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/home/t/hadoop/tmp/dfs/name&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/home/t/hadoop/tmp/dfs/data&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 【说明】 &lt;name&gt;dfs.name.dir&lt;/name&gt; dfs.name.dir存储永久性的元数据的目录列表。这个目录会创建在master主机上。 &lt;name&gt;dfs.data.dir&lt;/name&gt; dfs.data.dir存放数据块的目录列表，这个目录在node1和node2上创建 &lt;name&gt;dfs.replication&lt;/name&gt; dfs.replication设置文件副本数,此处有两个从机，设置副本数为2 配置mapred-site.xml先创建mapred-site.xml，进入到~/etc/hadoop/文件夹下 cp mapred-site.xml.template mapred-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置slaves把其他从机的主机名添加，有几个就添加几个，多添加会无法运行 配置环境变量sudo vim /etc/profile 将环境变量添加即可 export HADOOP_HOME=/usr/hadoop-2.7.5export PATH=$PATH:$HADOOP_HOME/sbinexport PATH=$PATH:$HADOOP_HOME/bin 更新生效 source /etc/profile 运行是否配置环境变量成功 hadoop version 【注】此步骤完成之后，可以克隆两个虚拟机分别命名为node1,node2 更改网络配置虚拟机设置【注】所有虚拟机都需要进行此步操作 点击控制-&gt;设置-&gt;网络，连接方式选择桥接网卡，然后重启虚拟机 修改Hostnamesudo vim /etc/hostname 【注】其他虚拟机修改其Hostname为相应的名称 以master为例，直接改为 修改hosts文件sudo vim /etc/hosts 增加以下内容，所有虚拟机都要增加以下内容 10.10.11.191 master10.10.11.192 node110.10.11.193 node2 其中127.0.0.1 oldhostname删掉 更改IP地址、网关【注】此处以master主机为例，其他主机根据上述拓扑图做相应更改 1.更改IP 利用ifconfig命令查看网卡名称，然后更改设置，本虚拟机网卡为enp0s3 sudo ifconfig enp0s3 10.10.11.191/24 【注】此种更改IP的方法，系统重启后需要重新配置 2.更改网关 sudo route add default gw 10.10.11.1 关闭防火墙sudo ufw disablesudo apt-get remove iptables 【注】此步骤后即可利用VirtualBox克隆功能复制出其他从机 连接测试使用ping命令测试是否能够连接 ping hostname 配置SSH安装sshsudo apt-get install ssh 查看已安装的sshdpkg --list|grep ssh 如果缺少openssh-server，需要安装 sudo apt-get install openssh-server 配置ssh下述步骤在不同的主机上进行，请注意区分 master机操作 生成master机的一对公钥和私钥 ssh-keygen -t rsa -P '' 进入.ssh目录查看公钥和私钥，id_rsa和id_rsa.pub cd .sshls 将公钥加入到已认证的key中 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 登录本机 ssh localhost 如果出现The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.，输入yes即可。 其他从机操作 将master主机上的id_rsa.pub复制到node1从机上。同理node2进行类似操作 scp ~/.ssh/id_rsa.pub t@node1:~/ 然后再在从机执行 cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 若遇到/home/t/.ssh/node1_rsa.pub: No such file or directory，则手动通过共享文件夹复制到其他从机相应位置。 若从机cd .ssh遇到No such file or directory，则手工创建.ssh文件夹。 在/home/t图形化界面按Ctrl+H显示隐藏文件夹， 若已经存在.ssh文件夹，则删除suso rm -r /home/t/.ssh。这里的/home/t是用户目录，t是用户名，其他用户名则需要做相应更改。 若没有.ssh文件夹，则创建sudo mkdir /home/t/.ssh 更改权限sudo chmod a+w /home/t/.ssh 通过共享文件夹把master中的id_rsa.pub复制到/home/t/中 将master主机上的密钥加入到认证中 cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 在master主机上验证能否正常登陆 ssh node1 出现以下则表示登陆成功 启动集群格式化namenode在主机master运行 hadoop namenode -format 若出现has been successfully formatted和Exiting with status 0表示格式化成功 若出现hadoop:Cannot create directory /home/t/hadoop/name/current错误即文件夹权限不足 sudo chmod -R a+w /home/t/hadoop/name/current 启动集群start-all.sh 启动完毕后，执行命令 jps 若master主机看到四个开启的进程代表启动成功 若从机上看到启动进程 【问题解释】为什么没有jobtracker和tasktracker 停止集群stop-all.sh 查看运行状态查看Namenode状况通过Web界面查看NameNode运行状况，默认为http://localhost:50070 查看ResourceManager状况http://localhost:8088 运行测试程序向hadoop集群系统提交第一个mapreduce任务，统计词频 进入本地hadoop目录.此处是/usr/hadoop-2.7.5 cd /usr/hadoop-2.7.5 在虚拟分布式文件系统上创建一个目录/data/input hdfs dfs -mkdir -p /data/input 将当前目录下的README.txt复制到虚拟分布式文件系统中 hdfs dfs -put README.txt /data/input 查看虚拟分布式文件系统中是否有复制上去的文件 hdfs dfs -ls /data/input 向Hadoop提交单词统计任务 hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.5.jar wordcount /data/input /data/output/result 查看结果 hdfs dfs -cat /data/output/result/part-r-00000]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题之NextD]]></title>
    <url>%2Fhexo-next%2F</url>
    <content type="text"><![CDATA[简介本次更改的主题为NextD，一款基于NexT而修改的主题。 ##集成Gitment评论系统 点击https://github.com/settings/applications/new注册 填写内容 Application name 随便填写 Homepage URL 填写你的个人博客域名如https://tianwenyu.github.io。 【注】前面的https://也要完整填写 Application description 随便填写 Authorization callback URL 同Homepage URL 在github的个人主页的issue页面可以看到网站评论 ##开启本地搜索功能 安装Local Search 安装hexo-generator-searchdb，在站点根目录下执行以下命令 npm install hexo-generator-searchdb --save 开启CNZZ统计功能 打开网址，注册个人帐号 登陆后，点击个人中心 点击U-Web,之后点击立即使用 添加站点 填写网站域名即可 将网站id填写到./themes/nextd/_config.yml中的cnzz_siteid。]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows中CMD命令之Tree生成目录]]></title>
    <url>%2Fcmd-tree%2F</url>
    <content type="text"><![CDATA[作用以图形显示驱动器或路径的文件夹结构 格式tree [path] [/f] [/a]#/f 显示每个文件中文件的名称#/a 使用ASCII字符，而不使用扩展字符 样例tree C:\Users\Administrator\.android /f &gt;F:\path\android-tree.txt]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java多态性]]></title>
    <url>%2Fjava-polymorphism%2F</url>
    <content type="text"><![CDATA[实例分析class A&#123; public String show(D obj)&#123; return ("A and D"); &#125; public String show(A obj)&#123; return ("A and A"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; return ("B and B"); &#125; public String show(A obj)&#123; return ("B and A"); &#125;&#125;public class C extends B&#123; &#125;public class D extends B&#123; &#125;public class Test&#123; public static void main(String[] args)&#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125; 运行结果： 解析①②③比较好理解，一般不会出错。④⑤就有点糊涂了，为什么输出的不是”B and B”呢？ 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。） 在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 上面程序中的A,B,C,D存在如下关系： 分析4： ​ a2.show(b)，a2是一个引用变量，类型为A，则this为a2，b是B的一个实例，于是它到类A里面找show(B obj)方法，没有找到，于是到A的super(超类)找，而A没有超类，因此转到第三优先级this.show((super)O)，this仍然是a2，这里O为B，(super)O即(super)B即A，因此它到类A里面找show(A obj)的方法，类A有这个方法，但是由于a2引用的是类B的一个对象，B覆盖了A的show(A obj)方法，因此最终锁定到类B的show(A obj)，输出为”B and A”。 分析5： ​ a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。 分析8： ​ b.show(c)，b是一个引用变量，类型为B，则this为b，c是C的一个实例，于是它到类B找show(C obj)方法，没有找到，转而到B的超类A里面找，A里面也没有，因此也转到第三优先级this.show((super)O)，this为b，O为C，(super)O即(super)C即B，因此它到B里面找show(B obj)方法，找到了，由于b引用的是类B的一个对象，因此直接锁定到类B的show(B obj)，输出为”B and B”。 ​ 按照同样的方法我也可以确认其他的答案。 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)； ​ 这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“ 被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话： 它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Github Pages+Hexo搭建个人博客]]></title>
    <url>%2Fgitpage-hexo%2F</url>
    <content type="text"><![CDATA[技术简介Github PagesGitHub Pages 本来用于介绍托管在Github上的项目，由于它的空间免费稳定，因此适合用来搭建博客。 每个帐号只能有一个仓库来存放个人主页，且仓库的名字必须是username/username.github.io。你可以通过http://username.github.io来访问你的个人主页 个人主页的网站内容是在master分支下 HexoHexo是一个快速、简洁高效的博客框架，具有如下特点： 生成静态网页 支持Markdown 一键部署博客到Github Pages 丰富插件 七牛云使用七牛云作为图床。 认证后的七牛云存储提供10G的免费空间以及每月10G的流量 MPic用于方便上传图片到七牛云的一款工具 点击下载 配置环境Git安装Git进入网站https://git-scm.com/下载安装即可 Node.JS安装Node.JS进入网站https://nodejs.org/en/，下载安装即可 Hexo安装Hexo在任意位置右键点击Git Bash Here 使用npm安装hexo，可以先切换npm源，加速安装过程 npm config set registry https://registry.npm.taobao.orgnpm install -g hexo 【注】若安装不成功，可以使用npm install hexo --save再次安装 出现以下图示表示安装完成。 【注】若提示This package is no longer maintained，耐心等待安装即可。 配置Hexo创建hexo文件夹在某一文件夹下如F:\hexo\blog，右键Git Bash Here，使用以下命令创建建立网站需要的文件 hexo init 安装依赖包npm install 生成静态文件hexo generate #生成静态文件，会在当前目录下生成一个新的名为public的文件夹 启动Hexohexo server -p 5000 #使用hexo server 默认端口4000，会无法访问localhost:4000，因此改为5000端口 常用hexo命令hexo help #查看帮助hexo -v #查看本地环境hexo init #初始化一个目录hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo gernerate #生成网页，可以在public目录查看整个网站的文件hexo server #本地预览 Ctrl+C关闭hexo deploy #或hexo d 部署到远端如github、herokuhexo clean #清除缓存 建议每次执行命令前先清理缓存，每次部署前先删除 .deploy文件夹 #常用缩写hexo n #hexo newhexo g #hexo generatehexo s #hexo serverhexo d #hexo deploy #常用组合hexo d -g #生成部署hexo s -g #生成预览 操作流程Github Pages创建页面仓库创建一个仓库，需要和帐号对应，格式yourname.github.io，创建仓库 生成SSH密钥任意地方右键Git Bash Here,执行以下命令 ssh-keygen -t rsa -C "你的邮箱地址" 出现Enter file in which to save the key (.....)直接回车选择默认位置 出现Enter passphrase(empty for no passphrase)直接两次回车不设密码以及确认 在Github上添加SSH密钥打开id_rsa.pub，复制内容。 进入https://github.com/settings/ssh。 点击New SSH key 填写后点击Add SSH key Hexo目录结构 deploy #需要部署的文件 node_modules #Hexo插件 public #生成的静态网页文件 scaffolds #模板 source #博客正文和其他源文件 drafs #草稿 posts#文章 themes #主题 config.yml #配置文件 部署原理 上述步骤中在Github上创建的那个仓库username.github.io，可以通过该链接访问 Hexo -g 会生成一个静态网站，第一次会生成一个public目录，这个静态文件可以直接访问 需要将Hexo生成的静态网站，提交(git commit)到github上 过程需要在_config.yml中修改 deploy: type: git repository: http://github.com/tianwenyu/tianwenyu.github.io.git branch: master 【注】 repository:后面的tianwenyu/tainwenyu.github.io.git要与自己创建的仓库名保持一致 .yml文件对格式要求严格，type: repository: branch: 前面两个空格，冒号后面一个空格 安装依赖包 npm install hexo-deployer-git --save 配置好之后执行 hexo geneartehexo deploy 【注】以上命令执行的环境必须在执行hexo init创建的文件夹下执行 执行完以上命令，会出现页面输入你的github用户名和密码，验证后就可以上传成功 访问tianwenyu.github.io，成功打开页面即部署成功。 配置选择的主题为indigo，具体问题可以看链接。 安装主题安装前确认你的Hexo版本在3.0以上，以及Node版本为6.x以上，在Hexo根目录，执行以下命令 git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 安装依赖 安装Less npm install hexo-renderer-less --save 安装Feed npm install hexo-generator-feed --save 安装Json-content npm install hexo-generator-json-content --save 安装QRCode npm install hexo-helper-qrcode --save 启用主题编辑站点配置文件hexo/_config.yml 搜索theme，修改为theme: indigo 基本配置修改以下内容 title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url indigo主题配置编辑主题配置文件hexo/themes/_config.yml 详情见indigo主题配置 新建文章hexo new &quot;postname&quot; 该命令会自动在hexo/source/_post文件夹下创建一个名为postname的markdown文件，会自动在文件开头添加 ---title: 你的题目tags: 你的标签category: 你的分类--- 填写tags,category，新建标签页面和分类页面后即可以显示相应的标签和分类 新建标签页面hexo new page tags 该命令会自动在hexo/source文件夹下创建tags文件夹并在该文件夹下创建index.md文件。 修改index.md文件，添加以下两项 layout: tagscomments: false 新建分类页面hexo new page categories 该命令会自动在hexo/source文件夹下创建categories文件夹并在该文件夹下创建index.md文件 修改index.md文件，添加以下两项： layout: categoriescomments: false Mpic 点击设置账号 将七牛云对应信息填入 空间名称：七牛存储文件的空间名，这里选择tpic SecretKey&amp;AccessKey：点击个人面板-密钥管理 域名：点击对象存储，在空间概览页面 ​]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualbox 下LVS-NAT模式集群部署]]></title>
    <url>%2Flinux-lvs%2F</url>
    <content type="text"><![CDATA[系统架构 虚拟机环境：VirtualBox Linux系统：CentOS 7 模型：LVS-NAT 调度算法：RR 【注】所有连接方式都采用桥接方式 主机 IP 角色 Client 192.168.33.145 客户机，用来访问网页 VS 192.168.33.150 VIP，Virtual Ip对外提供的IP VS 192.168.33.149 DIP，Director IP RS1 192.168.33.148 Real Server IP，安装Nginx RS2 192.168.33.147 Real Server IP，安装Nginx 客户机配置桥接IP设置 打开网络与共享中心 点击更改适配器设置 选择客户机（即物理机）网卡 4.打开属性，设置IPV4地址 虚拟机环境配置1.网卡模式设置【注】所有Virtual Box虚拟机网络设置都要设置为桥接方式 打开控制-&gt;设置-&gt;网络 连接方式选择桥接网卡，高级-&gt;混杂模式选全部允许 2.sudo命令配置【注】以一台虚拟机为例，其余虚拟机与此类似 切换到root用户 su -1 添加/etc/sudoers文件写权限 chmod u+w /etc/sudoers1 编辑/etc/sudoers vim /etc/sudoers1 找到root ALL=(ALL) ALL在下面添加21751096_1 ALL=(ALL) ALL，并保存退出 4.撤销/etc/sudoers文件的写权限 bash chmod u-w /etc/sudoers Director配置1.安装ipvsadmsudo yum install -y ipvsadm1 2.建立一个虚拟IP地址进行广播sudo ifconfig enp0s3:0 192.168.33.150/24 3.将该虚拟机地址添加到路由表sudo route add -host 192.168.33.150 dev enp0s31 4.使用ipvsadm安装LVS服务sudo ipvsadm -At 192.168.33.150:80 -s rr1 5.增加真实服务器sudo ipvsadm -at 192.168.33.150:80 -r 192.168.33.148 -gsudo ipvsadm -at 192.168.33.150:80 -r 192.168.33.147 -g12 6.设置DirectorIPsudo ifconfig enp0s3 192.168.33.149/241 7.查看ifconfig设置sudo ifconfig1 所有设置如图 Real Server配置1.安装nginx服务【注】需要在21751096_2和21751096_3两台RealServer上安装nginx服务，以其中一台为例 使用yum安装nginx,需要安装nginx的库 cd /etc/yum.repos.d/nginx.reposudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm12 编辑nginx.repo文件 sudo vim /etc/yum.repos.d/nginx.reponame=nginx repobaseurl=http://nginx.org/packages/centos/7/x86_64/gpgcheck=0enabled=1123456 使用yum安装nginx sudo yum install nginx1 安装完成后启动nginx服务 sudo service nginx start1 修改index.html首页区分两个nginx服务器 sudo vim /usr/share/nginx/html/index.html1 修改内容如下 查看是否启动服务 curl -i localhost1 2.IP设置 切换到root账户 su -1 设置虚拟IP ifconfig lo:0 192.168.33.150/361 添加到路由表 route add -host 192.168.33.150 dev lo:01 设置IPV4转发 bash echo &quot;1&quot; &gt;/proc/sys/net/ipv4/ip_forward 设置RS1的IP ifconfig enp0s3 192.168.33.148/241 查看ifconfig设置 ifconfig1 全部设置如图所示 运行测试在浏览器中输入192.168.33.150 第一次显示Real Sever 1的页面 刷新后显示Real Server 2的页面]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【评论文本分类】1.爬取评论数据]]></title>
    <url>%2Ftext-classification%2F</url>
    <content type="text"><![CDATA[环境配置 Ubuntu 16.04 Python 3.5 技术框架 Scrapy Selenium PhantomJS 需求目标对网址http://liuyan.cjn.cn/index.html进行数据爬取 本文爬虫有三层爬取，爬取结构层次如图所示， 主页面 列表页面，需要利用selenium+phantomJS模拟点击加载更多按钮 详情页面 把主页面中的红框中的各区（功能区）、政府部门、法检及其他单位等作为一级类保存，然后依次爬取一级类中各个分类 进入到列表页面，因为此页面是动态加载，并且是简介列表，因此需要加载完所有列表进入到详情页面。 进入到详情页面，爬取相应内容。 设计方案动态爬取数据一般有两种方法 分析包，构造Request 通过模拟浏览器行为加载页面 通过尝试，第一种方法对于此网站不适合，采用第二种方法。 采用Scrapy+Selenium+PhantomJS来进行动态网页的爬取。 SeleniumSelenium是一个自动化测试工具，本文用到的是其Webdriver，用其来操作浏览器，可以操作多种主流浏览器，如Chrome，Firefox等，下文中的PhantomJS是一种无界面的浏览器。 PhantomJSPhantomJS是一个无界面浏览器，提供JavaScript接口。通过这个工具，可以进行页面的加载、解析、操作等。 爬取方案 先爬取主页面各个主类（如各区（功能区）、政府部门等）下的子类链接，如（江岸区、江夏区等） 按照先前爬取的子类链接依次打开跳转到列表界面，然后利用Selenium+PhantomJS模拟浏览器动态加载完全部列表，解析出所有列表的链接，跳转到详情页面 进入到详情页面，解析所要提取的内容 详细步骤安装Scrapysudo pip3 install scrapy 安装PhantomJS 安装PhantomJS sudo apt-get install phantomjs apt-get会安装不完整，需要安装以下 sudo apt-get install nodejssudo apt-get install nodejs-legacysudo apt-get install npmsudo npm -g install phantomjs-prebuilt 安装Seleniumsudo pip3 install selenium 使用Scrapy 创建新工程 scrapy startproject xxxx 编辑items.py文件 from scrapy import Itemfrom scrapy import Field class MessageboardspiderItem(Item): # define the fields for your item here like: dir_name=Field() url=Field() title=Field() domain=Field() type=Field() content=Field()​ 3. 编写Spider 流程： - 先通过scrapy爬取`主页面`上的所有子分类链接， - 然后依次利用`PhantomJS`模拟点击`列表页面`的`加载更多`按钮，动态加载所有列表项，然后保存网页源码，抽取出其中的列表项的链接，进入`详情页面` 此两过程的代码都在`parse(self,response)`方法中 - 通过`parse_detailed_remark(self,response)`方法，解析出需要的内容 【注】目前版本爬取`主页面`上不同的主类需要手动改动`baseDir`与`self.start_urls` ```python import os import stat import scrapy import time from selenium import webdriver from scrapy.selector import Selector from scrapy.http import HtmlResponse from messageBoardSpider.items import MessageboardspiderItem baseDir = '/home/t/dataset/msgBoard/department/' #爬取不同主分类，需要手动改动 baseUrl='http://liuyan.cjn.cn' global subclass_name global brower class DistrictSpider(scrapy.Spider): name='spider' def __init__(self): global brower self.start_urls=['http://liuyan.cjn.cn/forum/list?fid=4'] #爬取不同主分类，需要手动改动 brower=webdriver.PhantomJS() #创建PhantomJS浏览器 def parse(self,response): global brower global subclass_name subclasses=response.xpath('/html/body/div[7]/ul/li/b/a') #解析出所有子分类 for subclass in subclasses: #逐条解析子分类 subclass_name=subclass.xpath('text()').extract() #解析 #make district directory self.mkdirs(baseDir+subclass_name[0]) #extrat new link link=subclass.xpath('@href').extract() #解析出子类的链接 #joint link link=str(baseUrl+link[0].split('..')[1]) #拼接链接 brower.get(link) #利用PhantomJS打开链接 #进行动态解析，直到没有'加载更多'按钮之后停止 while True: try: more=brower.find_element_by_id('show_more') #找到'加载更多'按钮 time.sleep(0.5) more.click() time.sleep(0.5) except: with open(baseDir+subclass_name[0]+'/web_page.txt','w',encoding='utf-8') as f: f.write(brower.page_source) print('ending') break #对加载完后的源码进行解析，解析出列表标题 items=brower.find_elements_by_xpath('//*[@id="list_content"]/li/h2/b/a') for item in items: #解析出列表标题链接 title_link=item.get_attribute('href') print(title_link+'.........') yield scrapy.Request(url=title_link,callback=self.parse_detailed_remark) #解析详情页面 def parse_detailed_remark(self,response): global subclass_name item=MessageboardspiderItem() item['dir_name']=subclass_name[0] item['url']=response.url item['title']=response.xpath('/html/body/div[6]/h2/b/text()').extract() item['domain']=response.xpath('/html/body/div[6]/h3/em[1]/a/text()').extract() item['type']=response.xpath('/html/body/div[6]/h3/em[2]/a/text()').extract() item['content']=response.xpath('//*[@id="zoom"]/text()').extract() yield item def mkdirs(self,path): if not os.path.exists(path): os.makedirs(path) os.chmod(path,stat.S_IRWXU|stat.S_IRWXG|stat.S_IRWXO) 编辑pipelines.py文件 import jsonimport codecsbaseDir = '/home/t/dataset/msgBoard/department/'class DistrictPipeline(object): def process_item(self, item, spider): with codecs.open(baseDir+item['dir_name']+'/data.json','a+',encoding='utf-8') as f: self.file=f line=json.dumps(dict(item),ensure_ascii=False)+'\n' self.file.write(line) return item 编辑settings.py文件 编辑pipelines的设置，把如下内容的注释去掉即可 #ITEM_PIPELINES = &#123;# 'messageBoardSpider.pipelines.DistrictPipeline': 300,#&#125; 运行爬虫 在项目根目录下新建一个main.py文件，运行爬虫执行该文件即可。 from scrapy.cmdline import executeexecute(['scrapy','crawl','spider']) 【注】execute([&#39;scrapy&#39;,&#39;crawl&#39;,&#39;spider&#39;]) 其中spider是爬虫名，按需更改即可。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之Indigo主题配置]]></title>
    <url>%2Fhexo-indigo%2F</url>
    <content type="text"><![CDATA[正文宽度加宽/themes/indigo/source/css/_partial/variable.less 把@contentWidth: 960px改成@contentWidth: 90% 同时config文件中修改cdn:false Header高度调整 themes/indigo/source/css/_partial/header.less` 修改content-header下的 .content-header &#123; //min-height: 210px; margin-left: -240px; //padding: 104px 16px 48px 256px; padding: 50px 16px 5px 256px; color: @textPrimaryColor; background: @primaryColor; text-shadow: 0 1px 1px rgba(0, 0, 0, .2); 把min-height注释掉 修改padding:50px 16px 5px 256px; 根据https://github.com/OhYee/hexo-theme-indigo/tree/OhYee更改 同时调整themes/indigo/source/css/_partial/article.less .post-card &#123; //margin-top: -150px; margin-top: 0px; min-height: 100px; padding: 35px; background: #fff; border-radius: 4px; box-shadow: 0 10px 30px rgba(0, 0, 0, .2); .post-meta &#123; margin-top: 8px; &#125;&#125; 修改margin-top: 0px 更改主题若是想要更改其他版本主题，如本主题其他人修改的主题，可以直接放到/themes文件夹下，重命名。再在./config.yml里更改主题。]]></content>
      <categories>
        <category>个人建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 yum安装nginx-1.12.0]]></title>
    <url>%2Fcentos-nginx%2F</url>
    <content type="text"><![CDATA[CentOS 7 中的 yum 没法直接使用 yum install nginx 这个指令去安装nginx，因为nginx这个服务不是yum库中自带的。图1是官方提供的大致安装步骤，图2是官网提供的多个版本的nginx安装包，下面是我给合自己的系统环境总结的安装方法，供大家参考： 在/etc/yum.repos.d/文件夹下执行 sudo rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm 按图1中的要求vi nginx.repo这个文件，将图中[nginx]字段中的内容复制进去，保存退出！ [root@lnboxue ~]# vi /etc/yum.repos.d/nginx.repo[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/x86_64/gpgcheck=0enabled=1 这里需要注意的是：要将$releasever替换为7，将$basearch替换成x86_64。可以通过下面这条指令获取你自己系统的$releasever和$basearch。 [root@lnboxue ~]# rpm -qa | grep centos-releasecentos-release-7-3.1611.el7.centos.x86_64 yum安装nginx，参见图3和图4。 [root@lnboxue ~]# yum install nginx 可以使用两种方法启动nginx服务 [root@lnboxue ~]# service nginx start 或 [root@lnboxue ~]# systemctl start nginx 查看nginx服务是否已经启动 [root@lnboxue ~]# netstat -ntl 查看nginx版本 [root@lnboxue ~]# nginx -vnginx version: nginx/1.12.0 本地测试nginx服务 [root@lnboxue ~]# curl -i localhostHTTP/1.1 200 OKServer: nginx/1.12.0Date: Tue, 04 Jul 2017 05:27:07 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Wed, 12 Apr 2017 15:23:46 GMT……………………&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer tonginx.org.&lt;br/&gt;Commercial support is available atnginx.com.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 看到以上信息，说明你的nginx服务已安装成功！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 添加新用户并授权Root权限]]></title>
    <url>%2Fcentos-root%2F</url>
    <content type="text"><![CDATA[切换到root用户su - 添加新用户useradd xxx 查看是否在/home下创建用户ls /home 删除用户userdel -rf xxx 为新创建的用户添加密码passwd xxx【注】xxx为用户名 查看新建用户信息tail -3 /etc/passwd 切换用户su - xxx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习评估方法——P值校验]]></title>
    <url>%2Fml-pvalue%2F</url>
    <content type="text"><![CDATA[目标假设在α=0.05的情况下，根据舆情监测项目需求，查看召回率和准确率的置信区间，均值。 过程1.输入数据，三列分别是precision,recall,f1-score，每一列分别计算，以此为例，一共四十行。即样本容量为402.计算标准差STDEV(A2:A41)计算出的标准差放在A43单元格3.计算置信区间3.1公式-&gt;插入函数-&gt;CONFIDENCE.NORMALCONFIDENCE.NORMAL(0.05,A43,40)【解释】 Alpha=0.05即说明置信区间的显著性水平，置信水平是指总体参数值落在样本统计值某一区内的概率，一般用1-α表示，即在这个区间内的可能性为1-0.05=0.95，即有95％的可能认为落在这个区间。 Standard_dev=A43即上一步骤算出的标准差,上一步的标准差存储在A43单元格 Size=40即样本容量为40 4.计算平均值AVERAGE(A2:A41)5.理论解释6.操作动态图]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汽车口碑分析】2.Ubuntu 16.04下MongoDB安装、设置与使用]]></title>
    <url>%2Fautomobile-analysis-2%2F</url>
    <content type="text"><![CDATA[安装MongoDB sudo apt-get install mongo 通过pgrep mongo -l查看进程是否已经启动 运行mongo进入数据库 MongoDB设置 关闭/启动服务 sudo servie mongodb stop #停止服务sudo service mongodb start #启动服务sudo service mongodb restart #重启服务sudo service mongod status #查看状态1234 允许开机启动，默认当重启服务器后，mongodb服务会停止，需要设置开机启动mongodb服务。 sudo systemctl enable mongodb 使用MongoDB 默认mongodb只能在本机连接，在服务器外部是不能链接mongodb的。需要修改配置文件sudo vim /etc/mongodb.conf修改完成后，保存文件，重启mongosudo service mongodb restart]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>汽车口碑分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【汽车口碑分析】1.Ubuntu 16.04 LTS下安装Scrapy]]></title>
    <url>%2Fautomobile-analysis-1%2F</url>
    <content type="text"><![CDATA[安装pip3sudo apt-get install python3-pip 安装Scrapy依赖库 sudo apt-get install python-devsudo apt-get install libevent-devsudo apt-get install libssl-dev123 安装Scrapy sudo pip3 install scarpy]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>汽车口碑分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】判断字符串是否为空]]></title>
    <url>%2Fpython-string-null%2F</url>
    <content type="text"><![CDATA[str=''if str.strip()=='': print('str is null')if not str.strip(): print('str is null')str='hello'if str.strip(): print('str is not null')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python Trick】set与list]]></title>
    <url>%2Fpython-set-list%2F</url>
    <content type="text"><![CDATA[利用set去除list重复元素set是一个无序不重复元素集，基本功能包括关系测试和消除重复元素。若需要消除重复元素，如下 a=[5,2,5,1,4,3,3]a=list(set(a))12 提取两个list中出现过的非重复元素line1=['a','b','a']line2=['a','c']line=line1+line2line=list(set(line))1234 两个set的并集set1=set(['a','b'])set2=set(['a','c'])set(list(set1)+list(set2))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Git 2.15.0安装、配置]]></title>
    <url>%2Fwindows-git%2F</url>
    <content type="text"><![CDATA[安装下载链接:http://git-scm.com/download 安装 配置 用户名和邮箱地址的作用：用户名和邮箱地址是本地Git客户端的一个变量，不随Git库而改变。每次Commit都会用用户名和邮箱地址记录。 git config --global user.name "xxxx"git config --global user.email "xxxx"]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij Idea 码云教程]]></title>
    <url>%2Fintellij-mayun%2F</url>
    <content type="text"><![CDATA[1.点击导航栏 VCS -&gt; Import into Version Control -&gt; 托管项目到码云 2.输入码云帐号密码，点击login。 3.勾选private，点击托管按钮。 4.点击OK。 5.在项目上右键 -&gt;Git -&gt;Commit Directory 6.填写Commit Message（养成良好编码习惯），点击Commit按钮 如果没有定义Git的用户名，点击Commit会弹出此弹窗，输入 name和email 点击 Set and Commit即可。 8.项目右键 -&gt; Git -&gt; Repository -&gt; Push 9.点击Push。 10.登录码云查看。到此，项目上传码云成功！~ 注意：（private勾选后项目并未成为私有项目，需要到码云网页上进行私有设置）]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
        <tag>码云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm设置]]></title>
    <url>%2Fpycharm-config%2F</url>
    <content type="text"><![CDATA[使用Tab缩进Editor-&gt;Code Style-&gt;Python-&gt;Tabs and Indents勾选Use tab character和Smart tabs 取消自动更新Appearance&amp;Behavior-&gt;System Settings-&gt;Updates勾掉Automatically check updates for和Use secure connection]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij idea使用教程]]></title>
    <url>%2Fintellij-tutorial%2F</url>
    <content type="text"><![CDATA[快捷键设置 如 Gif 所示，在没有对 Ctrl + D 快捷键进行修改前，此快捷键将是用来复制并黏贴所选的内容的，但是黏贴的位置是补充在原来的位置后，我个人不喜欢这种风格，我喜欢复制所选的行数完整内容，所以进行了修改，修改后的效果如上图 Gif 演示。 如Gif 所示，默认 Ctrl + 空格 快捷键是基础代码提示、补充快捷键，但是由于我们中文系统基本这个快捷键都被输入法占用了，所以我们发现不管怎么按都是没有提示代码效果的，原因就是在此。我个人建议修改此快捷键为 Ctrl + 逗号。 Ctrl 快捷键 介绍 Ctrl+, 代码补全，自定义 Ctrl+F 当前文件文本查找 Ctrl+R 当前文件文本替换 Ctrl+Y 删除光标所在行或选中行 Ctrl+D 复制光标所在行 Ctrl+U 前往光标所在方法的父类方法或接口 Ctrl+E 显示最近打开的文件记录列表 Ctrl+J 插入自定义动态代码模板 Ctrl+P 方法参数提示 Ctrl+W 递进式选择代码块。 Ctrl+Q 光标所在的变量、类名、方法名上显示文档内容 Ctrl+N 根据输入的类名查找类文件 Alt 快捷键 介绍 Alt+Enter 快速修复 Alt+Insert 代码自动生成，如set/get方法，构造函数 Alt+前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt+后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt+1 显示/隐藏 导航栏 Shift 快捷键 介绍 Shift+F6 重命名文件/文件夹 Shift+Tab 取消缩进 Shift+End 使光标到当前行尾位置 Shift+Home 使光标到当前行首位置 Shift+滚轮滚动 当前文件的横向滚动 Shift+Enter 开始新的一行 Ctrl+Alt 快捷键 介绍 Ctrl+Alt+L 格式化代码，可以对当前文件和整个包目录使用 Ctrl+Alt+O 优化导入的类 Ctrl+Alt+I 光标所在行代码缩进 Ctrl+Alt+S 打开系统设置 Ctrl+Shift 快捷键 介绍 Ctrl+Shift+F 查找整个项目 Ctril+Shift+R 在整个项目范围内替换 Ctrl+Shift+J 自动将下一行合并到当前行末尾 Ctrl+Shift+Z 取消撤销 Ctrl+Shift+W 递进式取消选择代码快 Ctrl+Shift+T 对当前类生成单元测试类 Ctrl+Shift+C 复制当前文件磁盘路径到剪切板 Ctrl+Shift+B 跳转到类型声明处 Ctrl+Shift+/ 代码块注释 Ctrl+Shift+Space 智能代码提示 Ctrl+Shift+Enter 自动结束代码，行末自动添加分号` Ctrl+Shift+Backspace 退回到上次修改的地方 Ctrl+Shift+Alt 快捷键 介绍 Ctrl+Shift+Alt+S 打开当前项目设置 其他 快捷键 介绍 F2 跳转到下一个高亮错误或警告位置 F4 编辑源 Shift连按两次 弹出Search Everywhere 常用设置 如Gif 所示，我们可以勾选此设置后，增加 Ctrl + 鼠标滚轮 快捷键来控制代码字体大小显示。Editor-&gt;General-&gt;Change font size(Zoom) with Ctrl+Mouse Wheel 可以勾选此设置后，增加 Ctrl + 鼠标滚轮 快捷键来控制图片的大小显示。Editor-&gt;Images-&gt;Zoom image with mouse wheel(Ctrl+Mouse Wheel) 显示方法线Eidtor-&gt;General-&gt;Apperance-&gt;Show method separators 如Gif 所示，即使我们项目没有使用版本控制功能，IntelliJ IDEA 也给我们提供了本地文件历史记录。除了简单的记录之外，我们还可以给当前版本加标签。 如Gif 所示，IntelliJ IDEA 自带模拟请求工具 Rest Client，在开发时用来模拟请求是非常好用的。 如Gif 所示，IntelliJ IDEA 的自定义 TODO 功能非常好用，强烈建议平时开发要经常使用上。 如图箭头所示，在 Debug 状态下，如果我们要批量删除断点，可以点击图上箭头所示的按钮，然后选中要删除的断点按断点上面的减号进行删除。 如图所示，不管是用 IntelliJ IDEA 打开新文件，或是在安装本地插件，在弹出的窗口中，图 1 按钮支持快速定位到系统桌面目录，图 2 按钮支持快速定位到当前项目目录。 如图所示，默认 IntelliJ IDEA 对于 Java 代码的单行注释是把注释的斜杠放在行数的最开头，我个人觉得这样的单行注释非常丑，整个代码风格很难看，所以一般会设置为单行注释的两个斜杠跟随在代码的头部。Editor-&gt;Code Style-&gt;Java-&gt;Code Generation-&gt;Line comment at fisrt勾掉 如图 Gif 所示，对于横向太长的代码我们可以进行软分行查看。软分行引起的分行效果是 IntelliJ IDEA 设置的，本质代码是没有真的分行的。 如图箭头所示，该设置可以增加 Ctrl + E 弹出层显示的记录文件个数。 默认 IntelliJ IDEA 是没有开启自动帮你生成 serialVersionUID 的，需要我们自行设置。如图第一张，需要先勾选：Serializable class without serialVersionUID如图第二张，在已经继承了 Serializable 接口的类名上，把光标放在类名上（必须这样做），按 Alt + Enter，即可提示帮你生成 serialVersionUID 功能。 如图 gif 演示的：Load/Unload Modules 是 2017.2 引入的新特性，对于多模块的项目开发 Unload 部分少用到的模块可以减少计算机 CPU 和内存的消耗。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中安装Intellij Idea]]></title>
    <url>%2Fubuntu-intellij%2F</url>
    <content type="text"><![CDATA[下载Intellij Idea 解压到/opt下sudo tar -zxvf ideaIU-2017.2.5.tar.gz -C /opt 进入IDEA文件夹的bin目录cd /opt/idea-IU-172.4343.14/bin 启动IDEA./idea.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 17.10安装sklearn]]></title>
    <url>%2Fubuntu-sklearn%2F</url>
    <content type="text"><![CDATA[安装支持库 sudo pip3 install numpy scipy matplotlib pandas 安装sklearn sudo pip3 install scikit-learn ​]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox中Ubuntu 17.10 安装JDK8]]></title>
    <url>%2Fubuntu-jdk8%2F</url>
    <content type="text"><![CDATA[下载JDK8http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 因为是在虚拟机中运行Ubuntu，所以JDK8文件是下载在Windows系统中，需要设置共享文件夹，把文件复制到Downloads文件夹下。 解压文件cd Downloads/tar -zxvf jdk-8u151-linux-x64.gz 将解压的文件夹jdk1.8.0_151移动到/usr/sudo mv jdk1.8.0_151/ /usr/ 配置系统环境变量，编辑/etc/profile文件，在文件的末尾添加以下内容sudo vim /etc/profile export JAVA_HOME=/usr/jdk1.8.0_151 #jdk主目录export JRE_HOME=$JAVA_HOME/jre #jre目录export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib #CLASSPATH目录export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin #将jdk的可执行文件目录添加到系统环境目录中1234 更新配置source /etc/profile 查看是否安装成功java -version]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Could not get lock /var/lib/dpkg/lock - open 解决方法]]></title>
    <url>%2Flinux-lock%2F</url>
    <content type="text"><![CDATA[出现此问题的原因是另外一个线程使用apt-get下载，结束现场呢个即可。1.搜索所有的线程ps -A | grep apt-get得到如图所示结果 结束线程数字就是线程号，结束线程即可sudo kill 1358]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下pip3的安装、升级、卸载]]></title>
    <url>%2Fubuntu-pip3%2F</url>
    <content type="text"><![CDATA[安装sudo apt-get install python3-pip 升级sudo pip3 install --upgrade pip 卸载sudo apt-get remove python3-pip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij Idea 2017 设置Eclipse快捷键风格]]></title>
    <url>%2Fintellij-eclipse-shortcut%2F</url>
    <content type="text"><![CDATA[Intellij Idea 可以设置Eclipse风格快捷键。File--&gt;Settings--&gt;Keymap选择Eclipse]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox中Linux设置共享文件夹]]></title>
    <url>%2Flinux-share-dir%2F</url>
    <content type="text"><![CDATA[安装Virtual Box增强功能包，若已安装，跳过该步骤。 在物理机设置一个共享文件夹，如F:/share/linux 点击VirtualBox状态栏上设备——共享文件夹 添加共享文件夹，这里共享文件夹名称为share，后面步骤会用到，选择固定分配和自动挂载。 进入Linux，打开终端，创建挂载点目录，这里为/mnt/shared sudo mkdir /mnt/shared 挂载共享文件夹，这里的share就是上面步骤4中的共享文件夹名称share sudo mount -t vboxsf share /mnt/shared 设置自动挂载，可以在/etc/fstab中添加一项 sudo vim /etc/fstabshare /mnt/shared vboxsf rw,gid=110,uid=1100,auto 0 0 卸载挂载点命令 sudo umount -f /mnt/shared 共享文件可以在/mnt/shared中查看]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持备份/还原win10系统的分区工具DiskGenius v4.9.3专业版下载+序列号注册文件激活教程]]></title>
    <url>%2Fwin10-diskgenius%2F</url>
    <content type="text"><![CDATA[关于DiskGenius这款分区软件，相信大家都使用的炉火纯青了，今天之所以给大家重新介绍分享，是因为之前给大家分享的DiskGenius版本都是网上现成的绿色版本，而今天给大家分享的版本是官方原版，并且是目前官方提供的最新版本DiskGenius v4.9.3，大家都知道，默认情况下在官网下载的DiskGenius在不购买输入序列号的情况下是免费版本，有功能限制，但今天亦是美网络小编要给大家分享的是如何将DiskGenius免费版本升级成专业版，还有一点，使用DiskGenius v4.9.3专业版还可以备份还原win10系统的分区，何不尝试一下？！ DiskGenius v4.9.3官网下载 64位下载地址：http://download.eassos.cn/DG493409_x64.zip 32位下载地址：http://download.eassos.cn/DG493409_x86.zip DiskGenius v4.9.3官方免费版升级专业版 从官网下载的DiskGenius是一个压缩包，解压缩后可以直接点击DiskGenius.exe运行打开。 不过，如果直接运行的话，得到的只是一个免费版本，要想使用功能齐全的专业版，我们需要进行以下一个步骤： 首先下载Options.ini文件：http://pan.baidu.com/s/1kTq12Kn 密码: r9jz 下载完成后，直接将该文件复制到刚刚解压缩的DiskGenius目录里，替换掉原先的Options.ini文件即可。 tips：Options.ini是存放注册激活信息的文件。 替换后，再次打开DiskGenius的时候就显示成专业版本啦。 如何使用DiskGenius v4.9.3备份/还原win10系统的分区 以备份为例，打开DiskGenius后，选中一个分区，比如系统所在分区C盘，右键点击该分区，然后选择”备份分区到镜像文件”，然后根据提示进行操作就可以了，很简单的。 如果要还原分区的话，同样的步骤，右键点击该分区，选择”从镜像文件还原分区”，不过需要注意的是，如果是还原系统分区的话，需要在PE下才能进行。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>DiskGenius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++中代码格式化插件NppAStyle]]></title>
    <url>%2Fnotepad-nppastyle%2F</url>
    <content type="text"><![CDATA[工具/原料 Windows7 Notepad++ NppAStyle(Notepad++的一个插件) 方法/步骤 直接在插件扩展中安装 下载Notepad++并安装NppExec插件。 插件—&gt;Plugin Manager—&gt;show Plugin Manager—&gt;安装NppAStyle插件。 自己下载dll插件 或者直接下载NppAStyle插件。登录NppAStyle网站下载，网址： http://sourceforge.net/projects/nppastyle/files/ 我们选择下载NppAStyle_bin_0.10.02.14.zip这个文件。 ​ 解压 下载后我们打开这个压缩文件，发现有两个文件夹ansi和unicode(ansi是标准编码，支持语言少；unicode是通用编码，支持更多的语言)。 打开unicode文件夹，将里面的NppAStyle.dll解压出来，将NppAStyle.dll放置到Notepad++安装目录下的plugins文件夹下。 ​ 重启Notepad++看NppAStyle是否安装成功，看到如图所示的信息就说明安装成功。 ​ 配置NppAStyle。 点击菜单栏中的”插件”—&gt;”NppAStyle”—&gt;”options”，在代码风格中选择java。 ​ 点击菜单栏中的”插件”—&gt;”NppAStyle”—&gt;”Format code”（或者按快捷键Alt+f），欣赏格式化后的代码风格。 ​ ​ 体验不同的代码风格并选择自己中意的某种代码风格。 重复第4步骤，例如将代码风格选中ANSI，按下快捷键Alt+f，欣赏格式化后的代码风格，并与第5步骤中格式化后的代码风格相比较。 ​ ​ 特别要注意：目前NppAStyle插件只支持格式化C、C++、C#、Java这四种编程语言的代码。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++没有插件管理器(Plugin Manager)的原因以及解决方法]]></title>
    <url>%2Fnotepad-plugin-error%2F</url>
    <content type="text"><![CDATA[今天想下几个notepad++的插件玩玩，结果发现根本就没有插件管理器。 后来上官网发现了这样一句话Note that the most of plugins (including Plugin Manager) are not yet available in x64 于是重新安装了一个32位的版本]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows上自动设置java环境变量的脚本]]></title>
    <url>%2Fwindows-java-script%2F</url>
    <content type="text"><![CDATA[代码这里默认设置了java jdk的安装路径为C:\Program Files\Java\jdk1.7.0_71，如果你的jdk安装路径不在此，可在执行此命令的时候，会有提示输入jdk安装路径，输入即可。 首先粘贴命令如下： 下载地址 @echo off:: TODO:设置java环境变量:: Author: Gwtcolor 02::设置java的安装路径，可方便切换不同的版本set input=set /p "input=请输入java的jdk路径（或回车默认路径为C:\Program Files\Java\jdk1.7.0_71）:"if defined input (echo jdk已设置) else (set input=C:\Program Files\Java\jdk1.7.0_71)echo jdk路径为%input%set javaPath=%input%::如果有的话，先删除JAVA_HOMEwmic ENVIRONMENT where "name='JAVA_HOME'" delete::如果有的话，先删除ClASS_PATH wmic ENVIRONMENT where "name='CLASS_PATH'" delete::创建JAVA_HOMEwmic ENVIRONMENT create name="JAVA_HOME",username="&lt;system&gt;",VariableValue="%javaPath%"::创建CLASS_PATHwmic ENVIRONMENT create name="CLASS_PATH",username="&lt;system&gt;",VariableValue=".;%%JAVA_HOME%%\lib\tools.jar;%%JAVA_HOME%%\lib\dt.jar;"::在环境变量path中，剔除掉变量java_home中的字符，回显剩下的字符串call set xx=%Path%;%JAVA_HOME%\jre\bin;%JAVA_HOME%\bin::echo %xx%::将返回显的字符重新赋值到path中wmic ENVIRONMENT where "name='Path' and username='&lt;system&gt;'" set VariableValue="%xx%"pause 解释下面就解释下命令 @echo off 是关闭回显的，不会显示命令信息 on打开会显示命令信息 color 02是设置输出文本颜色的，这里是控制命令台输出绿颜色 set /p “input=请输入命令信息” 是用来接收控制台输入的文本信息的 if else 是用来做判断 if defined input 是用来判断用户是否输入信息，回车的话，则表示未定义input的值 echo “输出信息” 是用来显示信息的 set javaPath=%input% 是用来吧变量input的值赋值给javaPath变量的 wmic 是提供了批处理的命令，可以方便的操作环境变量值 删除某一环境变量 就使用 wmic ENVIRONMENT where “name=’JAVA_HOME’” delete命令 创建某一环境变量 使用 wmic ENVIRONMENT create name=”JAVA_HOME”,username=”“,VariableValue=”%javaPath%”命令 修改某一环境变量 使用 wmic ENVIRONMENT where “name=’Path’ and username=’‘“ set VariableValue=”value” 注意事项 在上述批处理脚本命令中，要严格注意空格和大小写等的输入，不然执行不成功的 要以管理员方式运行命令，不然提示拒绝执行命令的提示]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 17.03 安装Chrome浏览器]]></title>
    <url>%2Fubuntu-chrome%2F</url>
    <content type="text"><![CDATA[1.移动到下载文件存放目录cd Downloads2.下载chrome文件2.1 32位使用如下命令wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb2.2 64位使用如下命令wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb3.安装chromesudo dpkg -i google-chrome*;sudo apt-get install -f]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 17.03安装搜狗拼音]]></title>
    <url>%2Fubuntu-sogou%2F</url>
    <content type="text"><![CDATA[添加fcitx 的键盘输入法系统，因为搜狗是基于fctix 安装搜狗输入法 设置系统参数 添加fcitx 添加源sudo add-apt-repository ppa:fcitx-team/nightly 更新系统sudo apt-get update 安装fcitxsudo apt-get install fcitx 安装fcitx的配置工具sudo apt-get install fcitx-config-gtk 安装fcitx的table-all软件包sudo apt-get install fcitx-table-all 安装im-switch切换工具sudo apt-get install im-switch 查看fictx是否安装完成 安装搜狗输入法 选择操作系统版本下载 安装搜狗输入法2.1 移动到文件夹位置cd xxxsudo dpkg -i xxx.deb【注】会出现错误，可不用理会 设置语言选项 System Settings--&gt;Language Support,将键盘输入法系统由默认的iBus设置为fcitx 上述步骤之后重启一次 搜索Fxitx Configruation,将搜狗输入法设为默认3.1 在Input Method界面点击加号，3.2 把only show current language勾选掉，搜索sogou3.3 使用Ctrl+Space切换]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 安装截图工具 Shutter]]></title>
    <url>%2Fubuntu-shutter%2F</url>
    <content type="text"><![CDATA[一、安装截图工具 Shutter 添加安装包软件源 sudo add-apt-repository ppa:shutter/ppa 更新源并安装 shutter sudo apt-get updatesudo apt-get install shutter 搜索 shutter 可看到已安装成功 二、设置 Shutter 快捷键 打开系统设置 打开 Keyboard 键盘设置 添加成功的状态 单击右侧 Disabled，然后快速按下 Ctrl+Alt+A 如下图 Ctrl+Alt+A 测试OK。 ps: 里面的快捷键命令用：shutter -s 或者shutter –select 截取当前活动窗口：shutter -a （a表示active） 截取拖拉区域：shutter -s （s是select之意），拖拉出矩形区域后按Enter。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 Ubuntu双系统双硬盘 硬盘安装]]></title>
    <url>%2Fwin10-ubuntu%2F</url>
    <content type="text"><![CDATA[准备工作 ubuntu-17.04-desktop-amd64.iso EasyBCD 2.3 一个单独的分区（磁盘管理器中删除卷，但是不格式化，具体操作过程类似下述开辟临时分区）【注】使用Win+X选择打开磁盘管理器 安装过程开辟一个临时分区 打开磁盘管理器,找一个分区，右键点击压缩卷。【注】不要选择要安装Linux系统分区分出一个临时分区，否则后面合并的时候会从基本磁盘转变为动态磁盘。后续处理会变得麻烦。 输入压缩空间，与系统镜像文件相同就可以。会得到一个未分配分区。 右键点击新建卷，格式化为FAT32格式。 最后安装完成系统后，可以在创建的临时分区上右键点击删除卷，会得到一个未分配的分区空间，再在想要合并的分区上右键点击扩展卷。 安装EasyBCD 2.3 添加新条目--&gt;NeoGrub 点击安装 点击配置 在打开的menu.lst文件中输入以下内容 title Installroot (hdM,N) kernel (hdM,N)/vmlinuz.efi boot=casper iso-scan/filename=/linux.iso ro quiet splash locale=zh_CN.UTF-8 initrd (hdM,N)/initrd.lztitle rebootreboottitle halthalt12345678 【注】 hdM是指第几块硬盘，我的是第二块硬盘所以是hd1，从0开始N是指存放的第几个分区 linux.iso是指你要安装的Linux系统镜像，要与实际镜像文件相同。\3. 若在安装过程启动的过程中卡住。把quiet splash改成nomodeset 复制镜像文件到临时分区 将镜像文件命名为linux.iso 复制到临时分区根目录下，解压缩出casper中的initrd.lz和vmlinuz.efi文件。【注】若casper文件夹中的vmlinuz.efi文件没有efi后缀，重命名文件加上后缀即可。 重启电脑 选择NeoGrub【注】若不能选择NeoGrub，进行如下更改。打开EasyBCD，编辑引导菜单--&gt;等待用户选择 选择Install【注】若出现找不到文件的错误，返回到上一级目录，按e进行修改，修改(hdM,N)修改N的数值，以便找到文件。 安装系统 Ctrl+Alt+T打开终端，卸载镜像sudo umount -l /isodevice 点击安装Ubuntu按钮，进行安装【注】建议拔掉网线，关闭Wifi，会加速安装速度。 分区操作，选择Something else 选择空余的free space双硬盘需要按以下格式分区，不然安装后会卡在启动界面。 挂载点 分区类型 文件系统类型 / 逻辑分区 Ext4 /boot 逻辑分区 Ext4 /home 逻辑分区 Ext4 swap 逻辑分区 Swap area 【注】双硬盘双系统都应该是逻辑分区\5. 安装完成 删除Linux系统目前的方法不太安全，进入Win10磁盘管理器，直接将Linux系统的分区删除卷,会得到一个未分配分区，然后新建简单卷。此种方法会重新开机找不到引导项，需要进入pe系统，修复引导项即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全的将动态磁盘转为基本磁盘]]></title>
    <url>%2Fhdware-dynamic2basic%2F</url>
    <content type="text"><![CDATA[前言手里有一块拆机硬盘，想着格式化几个分区，空间就大了，然后不知怎的就识别不了了，在windows磁盘管理显示为动态磁盘，用diskgenius打开，可以看到磁盘里的文件，但是如果想拷贝出来就得花钱，可是我又不想花钱，而且我还不想拷贝出来，有没有什么办法使硬盘恢复正常呢，百度了一通，答案大同小异，其中有个什么傲什么的软件，安装后提示该硬盘是MBR分区表，不支持，shit,纠结了好久，感觉还是不能放弃啊，咱身为一个技术人员一块硬盘都搞不定以后还怎么生（装）存（逼），终于自己摸索出来了一条新路子。由于直接将动态磁盘转为基本磁盘会丢失所有数据，这里我们还是先了解下硬盘为什么会变为动态磁盘。硬盘之所以能被系统识别，是因为每一个分区都有一份分区表，这份分区表保存在注册表里，就像是一块地图，系统根据这个地图到达每一个硬盘分区，如果这份地图丢失，那么这几个分区就变成未知的新大陆了，当然还有其他原因，不过误删分区引起的分区表丢失是最容易遇到的，这里我就针对此问题抛出我的解决方案。相信你也猜到了，那就是恢复分区表。 恢复丢失的分区表这里利用diskgenius磁盘分区软件，百度搜一大堆，这里就不给下载地址了，免安装的直接运行 我是用一个移动硬盘盒，将硬盘插进去，作为一个移动硬盘插到电脑上，当然你也可以用光驱硬盘驱动器，道理一样。 右键选中移动硬盘的根节点，注意，不是单独的分区，也不是动态磁盘根节点，是移动硬盘根节点。点菜单栏第二个 1.硬盘—&gt;重建主引导记录（MBR）2.弹出一个框，直接点确定，会搜索丢失的分区3.最后会发现左侧分区树发生了变化，动态磁盘已经变成逻辑磁盘了4.然后点击保存分区表，会问保存为MBR还是GUID格式，这个看你自己了，应该是都可以，我选了GUID,然后提示会将分区表保存在硬盘上，会影响磁盘结构啥的，不用管，点确定。然后在我的电脑里可以看到，移动硬盘的分区一个接一个都显示出来了,数据都在，完好无损。 如果上面执行第一步时没有可选菜单，先将磁盘转为不同于当前模式的磁盘，比如当前是MBR转为GUID，或者GUID转为MBR，只要跟当前格式不一样就行。然后进行上面操作 总结套路为：搜索分区，一路都点保留按钮，完毕后点击左上角的保存按钮，退出即可。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10利用DiskGenius重建分区表]]></title>
    <url>%2Fwin10-diskgenius-partition%2F</url>
    <content type="text"><![CDATA[安装DiskGenius 工具--&gt;搜索已丢失的分区界面如下： 开始搜索后，如果找到一个分区，会提示你忽略还是保留。【注】搜索到的第一个结果一般是系统盘C盘，这个结果需要忽略，否则后面无法找到其他分区。后面搜索到的分区需要确认其中是否为你原来分区中保存的文件之后才选择保留。 搜索完成后，点击硬盘--&gt;保存分区表.win10系统保存为GUID格式。]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>DiskGenius</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox Ubuntu 16.04安装Tensorflow]]></title>
    <url>%2Ftensorflow-ubuntu-install%2F</url>
    <content type="text"><![CDATA[1.安装python-pip和python-devsudo apt-get install python-pip python-dev2.安装Tensroflow sudo pip install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl 【注】如果有错误，可以尝试使用上述命令重新安装 3.安装完成。出现以下界面表示安装完成。 测试 $ python&gt;&gt;&gt;import tensorflow as tf&gt;&gt;&gt;hello=tf.constant('hello')&gt;&gt;&gt;sess=tf.Session()&gt;&gt;&gt;print(sess.run(hello))hello&gt;&gt;&gt;a=tf.constant(10)&gt;&gt;&gt;b=tf.constant(32)&gt;&gt;&gt;print(sess.run(a+b))4212345678910 5.安装IDE安装的IDE为Komodo Edit链接：http://komodoide.com/download/edit-linux64/#解压缩后界面如下：安装步骤： 进入到该文件解压缩的文件夹中 运行./install.sh,界面如下：]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat `#`不是内部或外部命令，也不是可运行的程序或批处理文件]]></title>
    <url>%2Ftomcat-error%2F</url>
    <content type="text"><![CDATA[打开tomcat根目录/bin/catalina.bat 查找# Configure JAVA 9 specific start-up parameters 修改为rem Configure JAVA 9 specific start-up parameters]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij部署Tomcat问题]]></title>
    <url>%2Fintellij-tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat部署中war与war exploded区别 war模式：即发布模式，将Web工程以war包的形式上传到服务器。 war exploded模式：将Web工程以当前文件夹的位置关系上传到服务器。 【注】 此模式直接把文件夹、jsp页面等相关文件移动到Tomcat部署文件夹里进行加载部署。因此此模式支持热部署。 使用热部署，需要对其他选项进行设置]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装Python 3.6.1]]></title>
    <url>%2Flinux-install-python%2F</url>
    <content type="text"><![CDATA[准备编译环境 sudo yum groupinstall 'Development Tools'sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel12 2.下载Python 3.6.1源码包 打开https://www.python.org/downloads/release/python-361/,下载XZ compressed source tarball 3.安装 3.1 创建安装文件的目录sudo mkdir /usr/local/python3 3.2 进入到下载的目录解压缩tar -Jxvf Python-3.6.1.tar.xz 3.3 配置./configure --prefix=/usr/local/python3 3.4 编译make 3.5安装sudo make install 4.安装后已自动做软链，无需再进行操作 5.pip做软链sudo ln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++编译、运行C/C++]]></title>
    <url>%2Fnotepad-c%2F</url>
    <content type="text"><![CDATA[安装MinGW编译器若安装过CodeBlocks，只需要将绝对路径MinGW/bin添加到环境变量path中。 若未安装任何编译器，先安装编译器，并将bin文件夹的绝对路径添加到环境变量path中。 安装NppExec插件之前文章Notepad++编译运行Java中有安装过程，在此不再重复 配置C/C++编译器 配置C编译器 打开Plugins-&gt;NppExec--&gt;Execute 在对话框中输入 cmd /c "gcc -o $(CURRENT_DIRECTORY)\$(NAME_PART) $(FULL_CURRENT_PATH) &amp;&amp; CLS &amp;&amp; pushd $(CURRENT_DIRECTORY) &amp;&amp; $(NAME_PART).exe" 点击Save保存，命名为Run C 将上述保存的命令添加到Macros中。 点击Plugins-&gt;NppExec-&gt;Advanced Options 在Associated script中选择Run C 点击Add/Modify添加到Menu Items中，勾选Place to the Macros submenu 点击Macros，此时已经有Run C，点击Macros-&gt;Modify Shortcut/Delete Macro 打开后点击Plugin Commands,为Run C设置快捷键 配置C++编译器步骤同上，第二步输入替换为 cmd /c "g++ -o $(CURRENT_DIRECTORY)\$(NAME_PART) $(FULL_CURRENT_PATH) &amp;&amp; CLS &amp;&amp; pushd $(CURRENT_DIRECTORY) &amp;&amp; $(NAME_PART).exe" 删除NppExec中的命令脚本点击Plugins-&gt;NppExec-&gt;Execute,点击Save... ​ 删除点击Delete]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NotePad++配置Python]]></title>
    <url>%2Fnotepad-python%2F</url>
    <content type="text"><![CDATA[1.安装python 建议更改安装路径到c:\python，可以方便notepad++调用。 安装时选项建议选择add path，可以自动配置 2.配置notepad++ run–&gt;run 填入命令cmd /k c:\python\python.exe &quot;$(FULL_CURRENT_PATH)&quot; &amp; ECHO. &amp; PAUSE &amp; EXIT]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python】两个txt文件通过某一字段关联]]></title>
    <url>%2Fpython-txt%2F</url>
    <content type="text"><![CDATA[背景将两个txt文件通过两者共有的某一项进行关联，类似于数据库中的不同表通过id相关联。txt1:#checkins(userID/venueID/time/offset)txt2:#pois(venueID/latitude/longtitude/words/country)通过共有项venueID，将txt1的数据以及txt2的数据关联起来，写入一个新的文件txt3。格式如userID/venueID/time/offset/latitude/longitude/words/country 思路将txt2文件的venueID作为字典的key，然后将latitude,longtitude,words,country写入一个列表里作为字典的值。 比对txt1中的venueID，相同则直接将txt1的此行写入txt3，同时将字典中的venueID对应的值——latitude,longtitude,words,country写入txt3 代码f1=open('f:\checkins.txt','r')f2=open('f:\pois.txt','r')fout=open('f:\dataset.txt','a+')dicc=dict()for line in f2: #将pois.txt截取出各个字段，写入字典中,key为venueID,value为[latitude,longitutde,words,country] line=line.strip().split('\t') values=[] latitude=line[1] longitutde=line[2] words=line[3] country=line[4] values.append(latitude) values.append(longitutde) values.append(words) values.append(country) dicc[line[0]]=values #venueID:[latitude,longitutde,words,country]#venueID_list=[]for line1 in f1: venueID=line1.split('\t')[1] if(dicc.get(venueID) != None): #if(venueID not in venueID_list): #去掉重复，不需要则注释掉 #venueID_list.append(venueID) fout.write(line1.strip('\n')+'\t'+dicc[venueID][0]+'\t'+dicc[venueID][1]+'\t'+dicc[venueID][2]+'\t'+dicc[venueID][3]) fout.write('\n')f1.close()f2.close()fout.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++编译、运行Java]]></title>
    <url>%2Fnotepad-java%2F</url>
    <content type="text"><![CDATA[Plugins--&gt;Plugin Manager--&gt;Show Plugin Manager 安装NppExec Plugins--&gt;NppExec 输入以下参数 NPP_SAVE cd "$(CURRENT_DIRECTORY)" javac.exe "$(FILE_NAME)" java.exe "$(NAME_PART)" 1234 5.定义快捷键5.1 Plugins--&gt;NppExec--&gt;Advanced Options5.2 Associated script选择保存的脚本名5.3 点击Add/Modify5.4 勾选Place to the Macros submenu5.5点击OK 重启Notepad++ Run--&gt;Modify Shortcut/Delete Command--&gt;Plugin Command7.1找到自定的脚本名，更改快捷键]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera解决无法播放视频问题]]></title>
    <url>%2Fcoursera-video%2F</url>
    <content type="text"><![CDATA[打开文件C:\Windows\System32\drivers\etc\hosts 添加内容52.84.246.72 d3c33hcgiwev3.cloudfront.net 打开cmd,输入ipconfig/flushdns。刷新dns即可]]></content>
      <categories>
        <category>工具教程</category>
      </categories>
      <tags>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS yum install Another app is currently holding the yum lock解决方法]]></title>
    <url>%2Fyum-lock%2F</url>
    <content type="text"><![CDATA[centos在yum install报错：Another app is currently holding the yum lock解决方法 Another app is currently holding the yum lock，这个意思很明显就是说，有另外一个应用在使用yum，被占用锁定了，所以咋办呢，直接结束掉,可以通过强制关掉yum进程： sudo rm -f /var/run/yum.pid]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础语法备忘]]></title>
    <url>%2FC-backup%2F</url>
    <content type="text"><![CDATA[常量整型常量（Integer）整形常量的表示形式 整型常量的表示形式 特点 举例 十进制 0-9的数字序列组成，数字前可带正负号 256,-128,0,+7 八进制 以0开头，后跟0-7的数字序列组成，0前可带正负号 021，-017 十六进制 以0x开头，后跟0-9,a-f的数字序列组成 0x12,-0x1F 整型常量的类型 长整形：l，如：-256L，1024l 无符号整形：u，如：30u，256U，不能表示成小于0的数，如-30u非法 无符号长整形：lu，30lu 实型常量（Float） 指数形式0.345e-5=0.00000345 实型常量的类型 实型常量隐含按双精度型（double） 单精度：f 长双精度(long double)：l 字符常量转义字符 字符 含义 \n 换行(new line) \r 回车（不换行）(carriage return) \0 空字符，代表ASCII码值为0的字符 \t 水平制表(horizontal tabulation) \b 退格(backspace) \&quot; 双引号(double quotation mark) \&#39; 单引号(single quotation mark) \\ 反斜线(backslash) \? 问号 变量局部变量 局部变量定义时不会自动初始化，若未赋初值，则取随机值 全局变量*全局变量定义时未赋初值则初始化为0 静态变量 静态变量会保持上一次的值 若未赋初值，则初始化为0 const类型修饰符 const常量只能在定义时赋初值，不能再程序中改变其值。 char类型与int类型的关系 char型可看作一种特殊的int型。 在C语言中，只要在ASCII码取值范围内，char型数据和int型数据可以相互转换，即char型数据可以参与任何int型数据的运算例：一个char型变量既可以以字符格式输出，也可以以整形格式输出，以整形格式输出即输出其ASCII码的十进制值。 char ch='a';printf("%c,%d\n",ch,ch);--&gt;a,971234 变量Tips char型数据在内存中只占1个字节int型与程序执行环境的字长有关。16位下占16位，即2个字节；32位下占32位，即4个字节。可以使用sizeof计算类型的字节数 对于实数，无论是小数表示形式还是指数表示形式，在计算机内部都是采用浮点数方式来存储。 * 运算符算术运算符 两个整数相除的结果仍为整数，舍去小数部分的值。 整数与实数原酸的结果为double型 求余运算限定参与运算的两个操作数为整数。余数的符号与被除数的符号相同。 常用的标准数学函数 函数名 功能 sqrt(x) 计算平方根 fabs(x) 计算绝对值 log(x) 计算lnX的值 log10(x) 计算lgX的值 exp(x) 计算e^x的值 pow(x,y) 计算x^y的值 赋值运算符 =左侧只能是变量名 位运算符 位运算符的操作对象只能是char和int类型 &amp;：按位与，一种对某位清零的手段，即两个操作数中任意一位为0，则结果置0 |:按位或，一种对某位置1的手段，即两个操作数中任意一位为1，则置1 ^：按位异或，两个操作数位不同，则置1 &lt;&lt;：左移位，每左移一位相当于乘2 &gt;&gt;：右移位，每右移一位相当于除2 类型转换赋值中的类型转换 C语言支持类型自动转换机制 表达式中的类型转换 表达式中若混有不同类型的常量及变量，则先要全部转换为同一类型，再进行运算。 类型提升(Type Promotion)：把所有操作数都转换成占内存字节数最大的操作数类型。 输入/输出printf() 格式转换符 格式转换符 用法 %d 带符号的十进制整数 %u 无符号的十进制整数 %o 无符号的八进制整数，不输出前导符0 %x 无符号的十六进制整数（小写），不输出前导符0x %c 输出一个字符 %s 输出字符串 %% 百分号% * 格式修饰符 格式修饰符 用法 英文字母l 输出long型数据 最小域宽m 指定输出项输出时所占的列数。若m为正整数，向右靠齐。若m为负整数，向左靠齐。 显示精度.n 对于浮点数，指定输出的浮点数的小数位数。对于字符串，指定输出截取的子串字符个数 scanf() 格式转换符 格式转换符 用法 %d 十进制整数 %o 八进制整数 %x 十六进制整数 %c 字符，空白字符（空格、回车、制表符）也作为有效输入 %s 字符串，遇到第一个空白字符输入结束 %f 实数 %% 百分号 * 格式修饰符 格式修饰符 用法 忽略输入修饰符* 表示对应的输入项在读入后不赋给相应的变量 域宽m 指定输入的数据的宽度，按此宽度截取所需数据 函数 宏是预处理阶段替换，函数是运行时调用。 数组 定义数组的大小必须使用整型常量或整型常量表达式。如int score[100]合法，而int score[n]非法 C语言的数组在内存中是按行存放的。 数组名代表数组的首地址 数组不能整体引用，每次只能引用数组的一个元素 不能用赋值表达式对数组元素进行整体赋值。如score={1,2,3,4,5};非法 数组的初始化 引用数组前，必须保证数组的元素被赋以确定的 二维数组，既可以按元素初始化，也可以按行初始化如：int matrix[3][2]={(1,2,3,4),{5,6,7,8}};//按行初始化int matrix[3][2]={1,2,3,4,5,6,7,8};//按元素初始化 当初始化列表中提供的初值个数少于数组元素个数时，自动给后面的元素赋值为0如 int matrix[1][2]=&#123;0&#125;;等价于int matrix[1][2]=&#123;0,0&#125;;123 当数组被声明为static(静态)类型或外部存储类型（即在所有函数外部定义时），则在不显式给出初值的情况下，数组元素将在程序编译阶段自动初始化为0。 向函数传递一维数组 可以用数组名作为函数参数 在接收一维数组的函数中，在声明一维数组的形参时，可以省略数组的长度如： void sort(int arr[10]);等价于void sort(int arr[]);123 向函数传递二维数组 在接收二维数组的函数中，在声明二维数组形参时，不能省略数组第二维的长度。如: void func(int arr[4][3]);void func(int arr[][3]);都合法，但void func(int arr[][]);非法12345 字符数组字符数组与字符串关系 字符串由若干有效字符及字符&#39;\0&#39;作为结束标志的一个字符序列。 字符串借助字符型一维数组存储。 最后一个&#39;\0&#39;占用一字节的存储单元，但是不计入字符串的实际长度。 每个字符串在内存中占用一串连续的存储空间，而且这段连续的存储空间有唯一的首地址。 如果一个字符串只是字符串常量，则这个字符串常量本身代表的是该字符串在内存中所占连续存储空间的首地址，是一个地址常量。 一维字符数组可存放一个字符串，二维字符数组可存放多个字符串。 字符串赋值给字符数组1.用char数据对数组初始化char str[6]={&#39;C&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;,&#39;\0&#39;};此种方式赋初值，必须人为的加入&#39;\0&#39; 2.用字符串常量对数组初始化char str[]=&quot;China&quot;;* 对于二维字符数组存放多个字符串，第二维的长度不能省略，应该按最长的字符串长度设定。char weekday[][10]={&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;}; 字符数组的输入/输出1.以c格式字符一个个单独输入/输出for(i=0;i&lt;10;i++)&#123; scanf("%c",&amp;str[i]);&#125;for(i=0;str[i]!='\0';i++)&#123; printf("%c",str[i]);&#125;123456 2.以s格式作为字符串整体输入/输出scanf("%s",str);printf("%s",str);12 【注】space、enter、tab作为以%s格式输入字符串的分隔符，因而不能被读入，遇到这些字符即结束输入。 3.用gets()或puts()输出/输出 gets()从键盘读入一个字符串（包括空格符） puts()输出一个字符串，当遇见第一个&#39;\0&#39;时输出结果，并自动输出一个换行符 字符串处理函数 需要#include 指针 指针：是一种特殊的数据类型，只存放地址型数据 直接寻址：按变量名来存取变量内容的访问方式 间接寻址：通过指针变量间接存取指向的变量的访问方式 指针Tips a=*p++;，其中++与*优先级相同，且是右结合的。相当于a=*(p++);,而++又位于变量p之后，即相当于 a=*p;p=p+1;12 a=(*p)++相当于 a=*p;*p=*p+1;12 字符指针字符指针与字符数组的区别1. 初始化含义不同 char str[10]=&quot;China&quot;;表示定义一个字符数组str,数组名str代表字符串&quot;China&quot;在内存中存放的首地址。 char *ptr=&quot;China&quot;;表示定义一个字符指针ptr，并在定义时用字符串&quot;China&quot;在内存中的首地址为指针变量ptr赋初值。 2. 赋值方法和含义不同。 指针赋值 char *ptr;ptr="China"; //正确12 字符串中的一个字符的地址赋给ptr，相当于用地址值对ptr赋初值。* 字符数组赋值 char str[10];str="China";//错误12 以上方法是错误的，数组名是数组元素的首地址，是一个常量值，无法被改变。将一个字符串赋值给字符数组必须使用strcpystrcpy(str,&quot;China&quot;); 3. 输入方式不同 字符数组输入 char str[10];scanf("%s",str);12 字符指针必须保证字符指针事先已经指向一个数组的首地址 char *ptr,str[10];ptr=str;scanf("%s",ptr);123 4.类型不同* 字符数组的数组名是一个地址常量，值不能改变* 字符指针是一个变量，值可以被改变 【注】由于数组名作函数形参与指针变量作函数形参的等价性。因此，在用数组名作函数形参的函数体内部可以对该声明为形参的数组名进行和指针一样的自增、自减运算。除此之外的数组名都是一个指针常量，不能进行自增、自减的运算。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中C编程编译与调试]]></title>
    <url>%2Flinux-C%2F</url>
    <content type="text"><![CDATA[gcc编译器gcc编译流程【Tips】* Linux的可执行文件没有Windows那么明显的.exe扩展名，只需向其分配x权限即可。sudo chmod u+x filename* gcc可以在编译的任何阶段结束，以便检查或使用该阶段的输出。 gcc支持编译的扩展名 扩展名 源文件 .c C语言源代码文件 .C .cc .cpp C++源代码文件 .h 头文件 .a 存档文件 .i 经过预处理的C源代码文件 .ii 经过预处理的C++源代码文件 .s 汇编语言源代码文件 .S 经过预编译的汇编语言源代码文件 .o 编译后的目标文件 gcc参数 参数 作用 -o 指定生成的输出文件 -s 将C代码转换为汇编代码 -c 仅执行编译操作，不进行链接操作 应用无参数编译gcc a.c将a.c预处理、汇编、编译、链接成可执行文件。未指定输出则默认a.out 指定输出的文件gcc a.c -o do指定a.c输出为do可执行文件gcc a.c -o /tmp/do指定输出为/tmp目录下的do文件 多源文件的编译 多个文件一起编译gcc a.c b.c -o do将a.c和b.c分别编译后链接成do文件 分别编译各个源文件，对编译后输出的目标文件链接 gcc -c a.c #将a.c编译成a.ogcc -c b.c #将b.c编译成b.ogcc -o a.o b.o -o do #将a.o 和 b.o 链接成do123 以上两个方法，第一个方法编译时需要重新编译所有文件，第二个只重新编译修改的文件，未修改的文件不用重新编译。 查看编译过程gcc -v a.c查看编译过程和显示调用的库。 C程序的编译编写C程序使用VIM编写简单的C程序。\1. 打开终端\2. 在用户家目录下新建一个c文件夹mkdir ~/c\3. 打开VIM。vim\4. 编写C程序 #include&lt;stdio.h&gt;int main()&#123; printf("hello"); return 0;&#125;12345 编写完成后，按Esc返回到普通模式，保存文件到家目录下的c文件夹，保存为a.c:wq ~/c/a.c 使用gcc编译 打开终端，进入上文创建的~/c文件夹。cd ~/c 使用gcc编译gcc a.c -o a 执行编译出的可执行文件./a 编译过程详解* 预处理：对预编译语句（如宏定义define）和文件包含进行处理。需要完成的工作室对预编译指令进行替换，把包含文件放置到需要编译的文件中。最终生成一个非常完整的C源文件。* 编译：对预处理后的文件编译，生成.s的汇编语言文件。* 汇编：处理汇编语言。调用汇编处理程序将汇编语言汇编成二进制代码。最终生成.o目标文件。* 链接：将多个汇编生成的目标文件以及引用的库文件进行模块链接生成一个完整的可执行文件。 gdb调试器gdb简介主要使用gdb进行下面5个方面的操作：* 启动程序：在启动程序时，可以设置程序运行环境。* 设置断点：这里的断点可以使行数、程序名称或条件表达式。* 查看信息：断点停止后，可以查看程序的运行信息和显示程序变量的值。* 分步运行：使程序一个个语句的执行。* 改变环境：可以在程序运行时改变程序的运行环境和程序变量。 在程序中加入调试信息为了使用gdb进行调试，需要在编译程序中加入供gdb使用的调试信息。使用-g参数gcc -g -o a.debug a.c编译a.c生成一个a.debug的可执行程序，其中加入了供调试所用的信息。 gdb的使用启动gdb在终端输入gdb 加载需要调试的程序file a.debug运行结果如下，证明已加载此文件。Reading symbols from /home/tian/a.debug ...done 在gdb中查看代码用gcc -g编译后的a.debug程序加入了断点。可以用list查看程序的源代码和断点。1.list 1，会显示第一个断点前的代码。以上文a.c为例，会显示以下:2.按Enter键会显示下一个断点前的代码。 加入断点break命令可以增加断点。如在上文的例程第3行增加一个断点。break 3 查看断点info break 运行程序 run运行程序 next在下一行停下 continue在下一个断点位置停下 step单步运行。 step与next类似，都可以实现单步运行。不同的是，在遇上函数调用时，step可以进入函数内部，next跳过函数的调用 变量的查看print 退出调试q gdb常用命令 backtrace：显示程序中的当前位置和表示如何到达当前位置的栈跟踪 cd：改变当前工作目录 clear：删除刚才停止处的断点 delete：删除一个断点 display：程序停止时显示变量和表达式 info files：显示被调试文件的信息 info func：显示所有的函数名称 info local:显示所有的局部信息变量 info var：显示所有的全局和静态变量名称 whatis：显示变量或函数类型]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim简明教程]]></title>
    <url>%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中sudo命令详解]]></title>
    <url>%2Fsudo%2F</url>
    <content type="text"><![CDATA[sudo命令详解su、su-和sudo区别Linux中许多操作需要具有root用户权限才能执行，因此提供了su、su-、sudo命令使得用户具有root权限。 su与su-区别su命令用于切换当前用户身份到其他用户身份，切换时需要被切换用户的密码格式：su [参数] username【注】如果只是su命令，不带有username，则默认切换到root用户，su-同上。su与su-区别： su切换到其他用户，但是不切换环境变量 su -完整的切换一个用户环境,退出需要使用exit命令 如果使用以上两个命令，建议使用su- su与sudo区别由于Linux是多人多任务系统，而某些操作需要root用户权限，但不可能每个用户都有权力知道root用户密码，因此root用户便于管理，即相当于权力下放，允许某些用户能够拥有root用户权限，因此产生sudo命令。 su与sudo区别： su需要被切换用户的密码，sudo只需要本用户密码 su所有用户只要知道root用户密码就可以切换，sudo只有root用户在/etc/sudoers文件中配置了才能够拥有root权限 sudo命令特性 能够限制用户在某台主机上运行某些命令，允许管理员集中管理 提供丰富日志，详细记录了用户行为 使用时间戳文件限制用户的使用时间，默认5分钟，超时需要重新登录。（值可以在编译时更改） sudo命令配置某用户能够执行sudo命令需要事先root用户授权，即在/etc/sudoers文件中配置。\1. 切换root用户。su -\2. 添加文件的写权限。chmod u+w /etc/sudoers\3. 编辑/etc/sudoers。vim /etc/sudoers找到root ALL=(ALL) ALL在下面添加xxx ALL=(ALL) ALL,其中xxx为用户名，保存退出。4.撤销文件的写权限。chmod u-w /etc/sudoers]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下yum命令出现Loaded plugins fastestmirror]]></title>
    <url>%2Fcentos-yum-fastestmirror%2F</url>
    <content type="text"><![CDATA[fastestmirror是yum的一个加速插件，这里是插件提示信息是插件不能用了。步骤： 1.修改插件的配置文件# vi /etc/yum/pluginconf.d/fastestmirror.conf【Tips】：用Tab可补全将enabled=1改为enabled=0 2.修改yum的配置文件# vi /etc/yum.conf将plugins=1改为plugins=0 【注】以上操作需要切换到root用户下，否则会出现vim e505:read only 和vim e212错误 3.reboot]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS在Virtual Box上的安装——安装增强包]]></title>
    <url>%2Fcentos-virtualbox%2F</url>
    <content type="text"><![CDATA[【注】执行命令时先进入root1.安装需要的环境sudo yum groupinstall "Development Tools"sudo yum install kernel-devel 【注】如果出现yum Loaded plugins:fastestmirror问题，请参考CentOS下yum命令出现Loaded plugins: fastestmirror2.重启系统sudo reboot 【注】若点击virtualbox中的设备中的安装增强功能，出现自动运行可直接点击。3.挂载并安装VBoxGuestAdditions.iso3.1点击virtualbox的设备中的安装增强功能 3.1.1若使用GNome，挂载VBoxGuestAdditions.iso后出现Run界面，直接点击运行即可，后续步骤无需执行。3.2新建目录sudo mkdir /home/vbtools 3.3挂载到CD/DVD虚拟光驱sudo mount -t auto /dev/cdrom /home/vbtools （这里的cdrom是cd的，有时是dvd1，具体有什么光驱需要到/dev下查看） 3.4转到目录查看挂载cd /home/vbtoolsls 如果列表中出现VBoxLinuxAdditions.run证明挂载成功 sudo sh ./VBoxLinuxAdditions.run 出现下图安装成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2Flinux-bash%2F</url>
    <content type="text"><![CDATA[提示符 $为一般账户，#为root账号快捷键 tab可作为（1）命令补齐（2）档名补齐（3）参数项补齐 ctrl+z暂停正在运行的程序 ctrl+c终止正在运行的程序 ctrl+r搜索输入过的命令 ctrl+s停止滚屏 ctrl+q恢复滚屏 命令通配符 * 匹配零个或多个 ? 匹配任意一个字符 [0-9] 匹配一个数字范围 [abc] 匹配离别里任何字符 [^abc]匹配列表外字符常用命令切换用户 su - 切换到root用户，并新建一个新环境 exit 退出当前用户 id 显示当前用户信息 passwd 修改当前用户密码查看命令history 列出输入过的命令作业管理 命令后加&amp;表示后台运行。如firefox &amp;代表后台打开一个火狐 jobs查看所有后台运行的程序 bg将程序放到后台运行 如：bg 1将任务号为1的任务放到后台运行 【注】若前台任务只有一个，可省略任务号参数 fg将后台程序放到前台运行 网络命令wget用于下载网络文件.格式:wget [参数] 下载地址| 参数 | 作用 | || —- | —————– | —- || -b | 后台下载 | || -O | 下载到指定目录 | || -t | 最大尝试次数 | || -c | 断点续传 | || -p | 下载页面内所有资源，包括图片、视频 | || -r | 递归下载 | | elinks用于实现一个纯文本界面的浏览器格式:elinks [参数] 网址 文件目录命令pwd(print working directory)显示当前的工作目录格式:pwd [参数]| 参数 | 作用 | || —- | —————– | —- || -p | 显示真实路径（即非快捷链接的地址） | | touch 创建空白文件 修改文件时间对于Linux中的文件有三种时间： 更改时间(mtime):内容修改时间（不包括权限的） 更改权限(ctme):更改权限与属性的时间 读取时间(atime):读取文件内容的时间 参数 作用 -a 修改“访问时间”(atime) -m 修改“更改时间”(mtime) -d 同时修改atime和mtime mkdir创建文件夹格式：mkdir [参数] 目录| 参数 | 作用 | || —- | ——————- | —- || -m | 默认的文件目录权限，如-m 755 | || -p | 连续创建多层目录（若文件夹已存在则忽略 | || -v | 显示创建的过程 | | cp复制文件或目录格式：cp [参数] 源文件 目标文件三种情况： 目标文件是一个目录，将源文件复制到该目录中 目标文件是一个文件，将源文件覆盖该文件 目标文件不存在，将会复制源文件并修改为目标文件的名称（重命名）| 参数 | 作用 | || —- | ——————– | —- || -p | 保留原始文件的属性 | || -d | 若对象为链接文件，则保留该链接文件的属性 | || -i | 若目标文件存在则询问是否覆盖 | || -a | 相当于上述-pdr参数 | |mv 移动文件 对文件或目录重命名格式：mv [参数] 源文件 [目标路径|目标文件名] 如果目标文件是到某一目录文件的路径，则源文件会移动到此目录下，且文件名不变。如，将目录/usr/men中所有的文件移动到当前目录（.表示）mv /usr/men/* . 如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。 如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。 当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。如将文件ex2改为new1mv ex2 new1 参数 作用 -b 若需覆盖文件，则覆盖前先备份 -f 若目标文件或目录与现有文件或目录重复，则直接覆盖现有的文件或目录 rm(remove)删除文件或目录 删除普通文件并提示确认信息rm 文件名 删除普通文件或目录文件rm -rf 文件名或目录名cd(change directory)切换工作路径格式：cd [目录]| 参数 | 作用 | || ——— | ———————————— | —- || - | 切换到上次的目录，如cd - | || ~ | 切换到家目录，直接cd也可以回到家目录 | || ~username | 切换到其他用户的家目录,如cd ~teak切换到teak用户的家目录 | || .. | 切换到上级目录，如cd .. | |ls查看目录中有哪些文件格式：ls [参数] [文件]| 参数 | 作用 | || ——- | ——————- | —- || -a | 查看全部文件（包括隐藏文件） | || -d | 仅显示目录名，而不显示目录下的内容列表 | || -l | 显示文件的详细信息 | || –color | 使用不同颜色高亮不同的文件类型 | |文本文件编辑命令cat(concatenate)查看纯文本文件（较短的）格式：cat [参数][文件]| 参数 | 作用 | || —- | —————– | —- || -n | 显示行号 | || -b | 显示行号（不包括空行） | || -A | 显示不可见的符号，如空格，tab键 | |more查看纯文本文件（较长的）,一般用more分屏显示| 快捷键 | 作用 | || ——- | ———– | —- || space | 显示下一屏 | || enter | 只显示文本的下一行内容 | || b | 显示上一屏 | || q | 退出more命令 | | 参数 作用 -d 显示提示语句与信息 less查看纯文本文件，与more类似，但是less可以向上向下翻页，more只能向下翻页 tail显示文件的末尾几行| 参数 | 作用 | || —- | ————————————– | —- || -f | 追踪显示文件更新。（一般用于查看日志，该命令不会退出，持续显示先加入的文本） | | 系统状态检测命令ifconfig(interfaceconfig)用于获取网卡配置与网络状态等信息。格式：ifconfig [网络设备] [参数] uname(Unix name)查看系统内核版本信息格式：uname [-a]如果想查看系统详细版本信息查看redhat-release文件# cat /etc/redhat-release who查看当前登入主机的用户情况格式：who [参数] last查看所有系统的登入记录格式:last [参数] uptime查看系统的负载情况watch -n l uptime 每秒刷新一次获得当前的系统负载情况，输出内容分别为系统当前时间、系统已运行时间、当前在线用户、平均负载值 free显示当前系统中内存的使用情况格式:free [-m/-g]以MB为单位或以GB为单位显示 查看硬件信息命令lspci查看PCI设备| 参数 | 作用 | || —- | ——— | —- || -v | 查看详细信息 | || -b | 以总线为中心的视图 | | lsusb查看USB设备| 参数 | 作用 | || —- | —— | —- || -v | 查看详细信息 | | lsmod查看加载的模块（驱动） ###归档解压命令 tar对文件压缩或解压格式：tar [参数] [文件名]| 参数 | 作用 | || —- | ———- | —- || -c | 创建压缩文件 | || -x | 解压缩文件 | || -t | 查看压缩包内的内容 | || -z | 用Gzip压缩或解压 | || -v | 显示压缩或解压的过程 | || -f | 目标文件名 | || -C | 制定解压到的目录 | | 【例】 将/etc目录内文件打包并通过gzip压缩 tar -czvf etc.tar.gz /etc 将etc.tar.gz文件解压到/root/etc目录中 mkdir /root/etctar -xzvf etc.tar.gz -C /root/etc zip压缩文件格式：zip 目标文件 源文件 unzip 解压缩zip文件 格式：unzip 文件 查找命令find查找指定目录下的文件。格式:find 查找位置 参数| 参数 | 作用 | || ———— | ——————- | —- || -name&lt;范本样式&gt; | 指定字符串作为查找文件或目录的范本样式 | || -perm&lt;权限数值&gt; | 查找符合指定的权限数值的文件或目录 | || -user&lt;拥有者名称&gt; | 查找符合指定的拥有者名称的文件或目录 | || -type&lt;文件类型&gt; | 查找符合指定的文件类型的文件 | |【例】 在/home目录下查找以.txt结尾的文件名 find /home -name *.txt 2.当前目录及子目录下查找所有以.txt和.pdf结尾的文件 find . -name *.txt -o -name *.pdf 3.根据文件类型搜索find . -type 类型参数| 参数 | 说明 | || —- | —- | —- || f | 普通文件 | || l | 符号链接 | || d | 目录 | || c | 字符设备 | || b | 块设备 | || s | 套接字 | | 4.找出/home下不是以.txt结尾的文件find /home ! -name *.txt 基于目录深度搜索 向下最大深度限制为3find . -maxdepth 3 -type f 搜索出深度距离当前目录至少2个子目录的所有文件find . -mindepth 2 -type f 6.根据文件时间搜索 搜索最近七天内被访问过的所有文件find . -type f -atime -7 搜索恰好在七天前被访问过的所有文件find . -type f -atime 7 搜索超过七天内被访问过的所有文件find . type f -atime +7 搜索访问时间超过10分钟的所有文件find . -type f -amin +10 7.根据文件大小搜索| 参数 | 说明 | || —- | ——– | —- || c | 字节 | || w | 字（2字节） | || b | 块（512字节） | || k | 千字节 | || M | 兆字节 | || G | G字节 | | 搜索大于10kb的文件find . -type f -size +10k 搜索小于10kb的文件find . -type f -size -10k 搜索10kb的文件find . type f -size 10k 8.删除匹配文件删除当前目录下所有的.txt文件find . -type f -name *.txt -delete 9.根据权限或所有者搜索 搜索当前目录下权限为777的文件find . -perm 777 搜索当前目录下权限不是644的php文件find . -name *.php ! -perm 644 搜索当前目录用户 tom 拥有的所有文件find . -user tom 搜索当前目录用户组sunk拥有的所有文件find . -group sunk 10.搜索所有长度为0的文件find . -empty]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux帮助说明]]></title>
    <url>%2Flinux-help%2F</url>
    <content type="text"><![CDATA[##指令的–help选项--help选项显示命令的大致用法 ##man命令man xxx man page常用键| 按键 | 说明 | || ———– | —————————————- | —- || 空格键 | 向下翻页 | || [page down] | 向下翻页 | || [page up] | 向上翻页 | || [home] | 去到第一页 | || [end] | 去到最后一页 | || /string | 向下搜索string这个字符串 | || ?string | 向上搜索string这个字符串 | || n,N | 利用/或?来搜寻字符串时，可以用n继续下一个搜寻（不论是/或?，用N反向搜寻 | || q | 退出此次man page | | 可以使用man man命令获得更详细的说明 可以使用man -f命令查找更多信息，如man -f man。【注】此命令只能查找完整名称的命令。 也可以使用man -k命令查找更多信息，如man -k man。【注】此命令可以查找关键词，即模糊查找。 man查询后的数字含义| 代号 | 含义 || —– | —————————————- || 1 | 用户在shell环境中可以操作的指令或可执行文件，即一般用户可用 || 2 | 系统核心可呼叫的函数与工具 || 3 | 一些常用的函数（function）与函数库（library），大部份分为c的函数库（lib从） || 4 | 装置文件的说明，通常在/dev下的文件 || 5 | 配置文件或某些文件的格式 || 6 | 游戏 || 7 | 惯例与协议，如Linux文件系统、网络协议、ASCII code等的说明 || 8 | 系统管理员可用的管理指令 || 9 | 跟kernel有关的文件 | man page 构成| 代号 | 说明 | || ———— | ————————- | —- || NAME | 简短的指令，数据说明 | || SYNOPSIS（大纲） | 简短的指令语法（syntax）简介 | || DESCRIPSION | 较为完整的说明 | || OPTIONS | 针对SYNOPSIS部分中，列举所有可用的选项说明 | || SEE ALSO | 可以参考的，跟这个指令或数据有关的其他说明 | |##info page与man page的区别：info page将文件数据拆成一个个的段落，每个段落用自己的页面来编写，并且在每个页面中还有类似网页的超链接跳到各个不同的页面中，每个独立的页面被称为一个节点(node)| 按键 | 说明 | || ———– | —————————- | —- || 空格键 | 向下翻页 | || [page down] | 向下翻页 | || [page up] | 向上翻页 | || [tab] | 在node之间移动，有node的地方，通常会以*显示 | || [enter] | 当光标在node上面时，进入该node | || b | 移动光标到该info画面中的第一个node处 | || e | 移动光标到该info画面中的最后一个node处 | || n | 前往下一个node处 | || p | 前往上一个node处 | || u | 向上移动一层 | || s(/) | 在info page中搜寻 | || h,? | 显示求助选单 | || q | 结束这次info page | |]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA破解 2017 IDEA license server 激活]]></title>
    <url>%2FIdea2017-license%2F</url>
    <content type="text"><![CDATA[【注】 Idea 2017.3以后版本无法使用该网址激活，该网址支持2017.3以下版本，如2017.2.4等 进入ide主页面，help-register-license server,然后输入 http://idea.iteblog.com/key.php（注意：php要小写）即可~如下图，]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Intellij</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua的一种continue实现]]></title>
    <url>%2Flua-continue%2F</url>
    <content type="text"><![CDATA[Lua中没有continue，通过另一种方式实现了continue的功能for var=exp1,exp2 do while true do if condition expressions do break end other statements ... ... break endend]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua基础语法]]></title>
    <url>%2Flua%2F</url>
    <content type="text"><![CDATA[注释 单行注释两个减号，-- 多行注释--[[ 内容 --]] 数据类型 Lua是动态类型语言，变量不需要类型定义，只需为变量赋值 数据类型 描述 nil 只有值”nil”属于该类，表示一个无效值(在条件表达式里相当于false) boolean false 和 true number 双精度类型的实浮点数 string 由一对双引号&quot; &quot;或单引号&#39; &#39;表示 function 由C或Lua编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 nil nil类型表示一种没有任何有效值,它只有一个值”nil” 对于全局变量和table,nil的另外一个作用为删除，给全局变量或table表里的变量赋值nil,等于把它们删掉boolean Lua把false和nil看作“假”，其余为“真”number Lua默认只有一种number类型，即double(双精度)类型，默认类型可以修改luaconf.h里的定义。以下几种写法都是number类型&gt;print(type(2))&gt;print(type(2.2))&gt;print(type(0.2))&gt;print(type(2e+1))&gt;print(type(0.2e-1))&gt;print(type(7.8263692594256e-06))numbernumbernumbernumbernumbernumber string 由一对双引号&quot; &quot;或单引号&#39; &#39;表示 两个方括号[[ ]]表示一块字符串 &gt;html = [[&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.w3cschool.cc/"&gt;w3cschool菜鸟教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]print(html)&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.w3cschool.cc/"&gt;w3cschool菜鸟教程&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在对一个数字字符串上进行算术操作时，Lua会将数字字符串转成一个数字 &gt; print("2" + 6)8.0&gt; print("2" + "6")8.0&gt; print("2 + 6")2 + 6&gt; print("-2e2" * "6")-1200.0&gt; print("error" + 1)stdin:1: attempt to perform arithmetic on a string valuestack traceback: stdin:1: in main chunk [C]: in ?&gt; 字符串连接需要用..,需加上空格 &gt;print('a' .. 'b')ab&gt;print(157 .. 333)157333 使用#计算字符串的长度，放在字符串前面 &gt;len='www.w3cshool.cc'&gt;print(#len)16&gt;print(#'www.w3cschool.cc')16 table--创建一个空表local table1=&#123;&#125;--初始表local table2=&#123;'apple','pear','orange','grape'&#125; Lua中的table是一个”关联数组”,数组的索引可以数字或字符串【注】Lua中table 默认初始索引从1开始a=&#123;&#125;a['key']='value'key=10a[key]=22a[key]=a[key]+11for k,v in ipairs(a) do print(k .. ':' .. v)end结果key:value10:33 function 在Lua中，function被看作是”第一类值(First-Class Value)”,函数可以存在变量里 function factorial1(n) if n==0 then return 1 else return n*factorial1(n-1) endendprint(factorial1(5))factorial2=factorial1print(fatorial2(5))结果120120 userdatauserdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。 变量 变量在使用前，必须在代码中进行声明，即创建该变量。 Lua 变量有三种类型：全局变量、局部变量、表中的域 变量的默认值均为 nil。 标识符 一般用下划线加大写字母的标识符，为Lua的保留字。如：_VERSION 为保留用于Lua内部全局变量 区分大小写全局变量 默认是全局变量 全局变量无需声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，得到的结果为：nil print(b)&gt;nilb=10print(b)&gt;10 删除一个全局变量，将变量赋值为nil即可 b=nilprint(b)&gt;nil 局部变量使用local声明应该尽可能的使用局部变量，有两个好处： 避免命名冲突。 访问局部变量的速度比全局变量更快。赋值语句 Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。 a, b = 10, 2*x &lt;--&gt; a=10; b=2*x 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值： x, y = y, x -- swap 'x' for 'y'a[i], a[j] = a[j], a[i] -- swap 'a[i]' for 'a[j]' 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： 变量个数 &gt; 值的个数 按变量个数补足nil 变量个数 &lt; 值的个数 多余的值会被忽略 &gt;a, b, c = 0, 1&gt;print(a,b,c) 0 1 nil &gt;a, b = a+1, b+1, b+2 -- value of b+2 is ignored&gt;print(a,b) &gt;1 2 &gt;a, b, c = 0&gt;print(a,b,c) 0 nil nil 多值赋值经常用来交换变量，或将函数调用返回给变量：a,b=fun() f()返回两个值，第一个赋给a，第二个赋给b。 循环whilewhile(condition)do statementsend forLua中for语句有两大类: 数值for循环 泛型for循环 数值for循环for var=exp1,exp2,exp3 do statementsend var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次”执行体”。exp3是可选的，如果不指定，默认为1 for的三个表达式在循环开始前一次性求值，以后不再进行求值。泛型for循环用过一个迭代器遍历所有值--打印数组a 的所有值for i,v in ipairs(a) do print(v)end i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。 days=&#123;"Suanday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;for i,v in ipairs(days) do print(v)end结果SuandayMondayTuesdayWednesdayThursdayFridaySaturday repeat…untilLua 编程语言中 repeat…until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断。 repeat statementsuntil(contidion) 我们注意到循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。 函数函数作为参数 Lua 中我们可以将函数作为参数传递给函数myprint = function(param) print("这是打印函数 - ##",param,"##")endfunction add(num1,num2,functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result)endmyprint(10)-- myprint 函数作为参数传递add(2,5,myprint)结果这是打印函数 - ## 10 ##这是打印函数 - ## 7 ## 多返回值 Lua可以返回多个结果值，如string.find，返回匹配串“开始和结束的下标”（如果不存在匹配串返回nil） &gt;s,e=string.find('www.runoob.com','runoob')&gt;print(s,e)5 10 Lua函数中，在return后列出要返回的值得列表即可返回多值 function maximum(a) local mi=1 --最大值索引 local m=a[mi] --最大值 for i,val in ipairs(a) do if val &gt; m then mi=i m=val end end return m,miendprint(maximum(&#123;8,10,23,12,5&#125;))结果23 3 return f()这种形式，则返回“f()的返回值”： function foo0() endfunction foo1() return 'a' endfunction foo2() return 'a','b' endfunction foo(i) if i==0 then return foo0() elseif i==1 then return foo1() elseif i==2 then return foo2() endend&gt;print(foo(1))a&gt;print(foo(2))a b&gt;print(foo(0)) --(no result)&gt;print(foo(3)) --(no result) 可以使用圆括号( )强制使调用返回一个值 &gt;print((foo0()))nil&gt;print((foo1()))a&gt;print((foo2()))a 函数多值返回的特殊函数unpack，接受一个数组作为输入参数，返回数组的所有元素。unpack被用来实现范型调用机制，在C语言中可以使用函数指针调用可变的函数，可以声明参数可变的函数，但不能两者同时可变。在Lua中如果你想调用可变参数的可变函数只需要这样：f(unpack(a))unpack返回a所有的元素作为f()的参数 f=string.finda=&#123;'hello','ll'&#125;print(f(unpack(a)))--&gt;3 4 预定义的unpack函数是用C语言实现的，也可以用Lua实现function unpack(t,i) i= i or 1 if t[i] then return t[i],unpack(t,i+1) endend 可变参数 Lua函数可以接受可变数目的参数，和C语言类似在函数参数列表中使用三点（…) 表示函数有可变的参数。 Lua将函数的参数放在一个叫arg的表中，#arg 表示传入参数的个数。function average(...) result = 0 local arg=&#123;...&#125; for i,v in ipairs(arg) do result = result + v end print('总共传入' .. #arg .. '个数') return result/#argendprint('平均值为',average(10,5,3,4,5,6))结果总共传入 6 个数平均值为 5.5 再论函数Lua中的函数是带有词法定界(lexical scoping)的第一类值(first-class value) 第一类值在Lua中函数和其他值（数值、字符串）一样，函数可以被存放在变量中，也可以存放在table中，可以作为函数的参数，还可以作为函数的返回值 词法定界嵌套的函数可以访问它外部函数中的变量 Lua中关于函数难以理解的地方时函数也可以是匿名的。函数名（如print）实际上是一个指向函数的变量，像具有其他类型值的变量一样a=&#123;p=print&#125;a.p('hello world') --&gt;hello worldprint=math.sin -- print now refers to the sin functiona.p(print(1)) --&gt;0.841470sin=a.p --sin now refers to the print functionsin(10,20) --&gt;10 20 闭包当一个函数内部嵌套另一个函数定义时，内部的函数体可以访问外部的函数的局部变量，这种特征我们称作词法定界。虽然这看起来很清楚，事实并非如此，词法定界加上第一类函数在编程语言里是一个功能强大的概念，很少语言提供这种支持。下面看一个简单的例子，假定有一个学生姓名的列表和一个学生名和成绩对应的表；现在想根据学生的成绩从高到低对学生进行排序，可以这样做：names=&#123;'Peter','Paul','Mary'&#125;grades=&#123;Mary=10,Paul=7,Peter=8&#125;table.sort(names,function (n1,n2) return grades[n1]&gt;grades[n2]end) 假定创建一个函数实现此功能function sortByGrade(names,grades) table.sort(names,function(n1,n2) return grades[n1]&gt;grades[n2] end)end 例子中包含在sortbygrade函数内部的sort中的匿名函数可以访问sortbygrade的参数grades，在匿名函数内部grades不是全局变量也不是局部变量，我们称作外部的局部变量（external local variable）或者upvalue。（upvalue意思有些误导，然而在Lua中他的存在有历史的根源，还有他比起external local variable简短）。 function newCounter() local i = 0 return function() -- anonymous function i = i + 1 return i endend c1 = newCounter()print(c1()) --&gt; 1print(c1()) --&gt; 2 匿名函数使用upvalue i保存他的计数，当我们调用匿名函数的时候i已经超出了作用范围，因为创建i的函数newCounter已经返回了。然而Lua用闭包的思想正确处理了这种情况。简单的说，闭包是一个函数以及它的upvalues。如果我们再次调用newCounter，将创建一个新的局部变量i，因此我们得到了一个作用在新的变量i上的新闭包。c2 = newCounter()print(c2()) --&gt; 1print(c1()) --&gt; 3print(c2()) --&gt; 2 c1、c2是建立在同一个函数上，但作用在同一个局部变量的不同实例上的两个不同的闭包。技术上来讲，闭包指值而不是指函数，函数仅仅是闭包的一个原型声明；尽管如此，在不会导致混淆的情况下我们继续使用术语函数代指闭包。闭包在上下文环境中提供很有用的功能，如前面我们见到的可以作为高级函数（sort）的参数；作为函数嵌套的函数（newCounter）。这一机制使得我们可以在Lua的函数世界里组合出奇幻的编程技术。闭包也可用在回调函数中，比如在GUI环境中你需要创建一系列button，但用户按下button时回调函数被调用，可能不同的按钮被按下时需要处理的任务有点区别。具体来讲，一个十进制计算器需要10个相似的按钮，每个按钮对应一个数字，可以使用下面的函数创建他们：function digitButton (digit) return Button&#123; label = digit, action = function () add_to_display(digit) end &#125;end 这个例子中我们假定Button是一个用来创建新按钮的工具， label是按钮的标签，action是按钮被按下时调用的回调函数。（实际上是一个闭包，因为他访问upvalue digit）。digitButton完成任务返回后，局部变量digit超出范围，回调函数仍然可以被调用并且可以访问局部变量digit。闭包在完全不同的上下文中也是很有用途的。因为函数被存储在普通的变量内我们可以很方便的重定义或者预定义函数。通常当你需要原始函数有一个新的实现时可以重定义函数。例如你可以重定义sin使其接受一个度数而不是弧度作为参数：oldSin = math.sinmath.sin = function (x) return oldSin(x*math.pi/180)end 更清楚的方式do local oldSin = math.sin local k = math.pi/180 math.sin = function (x) return oldSin(x*k) endend 这样我们把原始版本放在一个局部变量内，访问sin的唯一方式是通过新版本的函数。利用同样的特征我们可以创建一个安全的环境（也称作沙箱，和java里的沙箱一样），当我们运行一段不信任的代码（比如我们运行网络服务器上获取的代码）时安全的环境是需要的，比如我们可以使用闭包重定义io库的open函数来限制程序打开的文件。do local oldOpen = io.open io.open = function (filename, mode) if access_OK(filename, mode) then return oldOpen(filename, mode) else return nil, "access denied" end endend 非全局函数Lua中函数可以作为全局变量也可以作为局部变量，我们已经看到一些例子： 函数作为table的域（大部分Lua标准库使用这种机制来实现的比如io.read、math.sin）。这种情况下，必须注意函数和表语法： 表和函数放在一起 Lib=&#123;&#125;Lib.foo=function (x,y) return x+y endLib.foo=function (x,y) return x-y end 使用表构造函数 Lib=&#123; foo = function (x,y) return x+y end, goo = function (x,y) return x-y end&#125; Lua提供另一种语法方式 Lib=&#123;&#125;function Lib.foo (x,y) return x+yendfunction Lib.goo (x,y) return x-yend 当我们将函数保存在一个局部变量内时，我们得到一个局部函数，也就是说局部函数像局部变量一样在一定范围内有效。这种定义在包中是非常有用的：因为Lua把chunk当作函数处理，在chunk内可以声明局部函数（仅仅在chunk内可见），词法定界保证了包内的其他函数可以调用此函数。下面是声明局部函数的两种方式：1.方式一local f=function() ...endlocal g=function() ... f() -- external loca 'f' is visible here ...end 2.方式二local funciton f() ...end 有一点需要注意的是在声明递归局部函数的方式：local fact=function (n) if n==0 then return 1 else return n*fact(n-1) -- buggy endend 上面这种方式导致Lua编译时遇到fact(n-1)并不知道他是局部函数fact，Lua会去查找是否有这样的全局函数fact。为了解决这个问题我们必须在定义函数以前先声明：local factfact=function (n) if n==0 then return 1 else return n*fact(n-1) endend 这样在fact内部fact(n-1)调用是一个局部函数调用，运行时fact就可以获取正确的值了。但是Lua扩展了他的语法使得可以在直接递归函数定义时使用两种方式都可以。在定义非直接递归局部函数时要先声明然后定义才可以：local f,g --forward declarationsfunction g() ... f() ...endfunction f() ... g() ...end 运算符关系运算符 ~= 不等于逻辑运算符Lua中false 和 nil 是假，其余为真，0也是true and 逻辑与 or 逻辑或 not 逻辑非 and优先级比or高 and 和 or 的运算结果不是true和false，而是和它的两个操作数有关。a and b --如果a为false，返回a，否则返回ba or b --如果a为true，则返回a，否则返回b &gt;print(4 and 5)5&gt;print(nil and 13)nil&gt;print(false and 13)false&gt;print(4 or 5)4&gt;print(false or 5)5 一个实用的技巧：如果x为false或nil，则给x赋值初始值v x = x or v&lt;==&gt;if not x then x=vend C语言中的三元运算符a?b:c在Lua中可以如此实现(a and b) or c not的结果只返回false或true 其他运算符 .. 连接两个字符串 # 返回字符串或table 的长度 字符串常用操作 函数 用途 string.upper(arg) 转为大写字母 string.lower(arg) 转为小写字母 string.gsub(mainString,findString,replaceString,num) 在字符串中替换，mainString为要替换的字符串,findString为被替换的字符,replaceString为要替换的字符,num为替换次数(可忽略，则全部替换) string.find(str,subStr,[init,end]) 在一个指定的目标字符串中搜索指定的内容，第三个参数为索引，返回具体位置,不存在返回nil string.reverse(arg) 字符串反转 string.format(…) 返回一个类似print的格式化字符串 string.char(arg)和string.byte(arg,[int]) char将整形数字转成字符并连接,byte将字符转为整数值（可以指定某个字符，默认第一个字符） string.len(arg) 计算长度 string.rep(string,n) 返回字符串的n个拷贝 table table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 table 是不固定大小的，你可以根据自己需要进行扩容。 Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。 table的构造--初始表myTable=&#123;&#125;--指定值myTable[1]='Lua'--移除引用myTable=nil --Lua垃圾回收会释放内存 当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。 -- 简单的 tablemytable = &#123;&#125;print("mytable 的类型是 ",type(mytable))mytable[1]= "Lua"mytable["wow"] = "修改前"print("mytable 索引为 1 的元素是 ", mytable[1])print("mytable 索引为 wow 的元素是 ", mytable["wow"])-- alternatetable和mytable的是指同一个 tablealternatetable = mytableprint("alternatetable 索引为 1 的元素是 ", alternatetable[1])print("mytable 索引为 wow 的元素是 ", alternatetable["wow"])alternatetable["wow"] = "修改后"print("mytable 索引为 wow 的元素是 ", mytable["wow"])-- 释放变量alternatetable = nilprint("alternatetable 是 ", alternatetable)-- mytable 仍然可以访问print("mytable 索引为 wow 的元素是 ", mytable["wow"])mytable = nilprint("mytable 是 ", mytable)结果mytable 的类型是 tablemytable 索引为 1 的元素是 Luamytable 索引为 wow 的元素是 修改前alternatetable 索引为 1 的元素是 Luamytable 索引为 wow 的元素是 修改前mytable 索引为 wow 的元素是 修改后alternatetable 是 nilmytable 索引为 wow 的元素是 修改后mytable 是 nil 构造函数可以使用任何表达式初始化 tab=&#123;sin(1),sin(2),sin(3),sin(4),sin(5)&#125; 在构造函数中域分隔符逗号（”,”）可以用分号（”;”）替代，通常我们使用分号用来分割不同类型的表元素。 tab=&#123;x=10, y=45; "one", "two", "three"&#125; 常用操作 函数 用途 table.concat(table,sep,start,end) concat是concatenate(连接)的缩写.table.concat()列出指定table从strat位置到end位置的所有元素，元素间以指定分隔符（sep）隔开 table.insert(table,pos,value) 在table的指定位置pos插入值为value的元素 table.remove(table,pos) 返回table位于pos未知的元素，其余元素前移 table.sort(table,comp) 对table升序排序 模块与包创建模块 模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。 Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。--定义一个名为module的模块module=&#123;&#125;--定义一个常量module.constant='这是一个常量'--定义一个函数function module.func1() io.write('这是一个公有函数')endlocal funtion func2() print('这是一个私有函数')endfunction module.func3() func2()endreturn module 由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用. require函数 require函数用来加载模块require(&#39;模块名&#39;) 也可以给加载的模块定义一个别名变量,如local m=require('module') C包 Lua和C是很容易结合的，使用C为Lua写包。 与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。 Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下: local path = "/usr/local/lua/lib/libluasocket.so"local f = loadlib(path, "luaopen_socket") loadlib函数加载指定的库并且连接到Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为Lua的一个函数，这样我们就可以直接在Lua中调用他。 如果加载动态库或者查找初始化函数时出错，loadlib将返回nil和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：local path = "/usr/local/lua/lib/libluasocket.so"-- 或者 path = "C:\\windows\\luasocket.dll"，这是 Window 平台下local f = assert(loadlib(path, "luaopen_socket"))f() -- 真正打开库 一般情况下我们期望二进制的发布库包含一个与前面代码段相似的stub文件，安装二进制库的时候可以随便放在某个目录，只需要修改stub文件对应二进制库的实际路径即可。将stub文件所在的目录加入到LUA_PATH，这样设定后就可以使用require函数加载C库了。 迭代器在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型： 无状态的迭代器 多状态的迭代器无状态迭代器无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是ipairs，他遍历数组的每一个元素。以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：function square(iteratorMaxCount,currentNumber) if currentNumber&lt;iteratorMaxCount then currentNumber=currentNumber+1 return currentNumber,currentNumber*currentNumber endendfor i,n in square,3,0 do print(i,n)end结果1 12 43 9 迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs和迭代函数都很简单，我们在Lua中可以这样实现：function iter (a, i) i = i + 1 local v = a[i] if v then return i, v endend function ipairs (a) return iter, a, 0end 当Lua调用ipairs(a)开始循环时，他获取三个值：迭代函数iter、状态常量a、控制变量初始值0；然后Lua调用iter(a,0)返回1,a[1]（除非a[1]=nil）；第二次迭代调用iter(a,1)返回2,a[2]……直到第一个nil元素。 多状态迭代器很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。以下实例我们创建了自己的迭代器：array=&#123;'Lua','Tutorial'&#125;function elementIterator(collection) local index=0 local count=#collection --闭包函数 return function() index=index+1 if index&lt;=count then --返回迭代器当前元素 return collection[index] end endendfor element in elementIterator(array) do print(element)end结果LuaTutorial pairs和ipairs异同 同：都能遍历集合(table,数组) 异： ipairs仅能遍历值,按照索引升序遍历，索引中断停止遍历。即不能返回nil，只能返回数字0.如果遇到nil则退出，只能遍历到集合中出现的第一个不是整数的key pairs能遍历集合的所有元素。即pairs可以遍历集合中所有的key，并除了迭代器本身以及遍历表本身还可以返回nil 例1local tabFiles=&#123; [1]='test2' [6]='test3' [4]='test1'&#125;for k,v in ipairs(tabFiles) do print(k,v)end--[[结果为1 test2，在key为2时断开--]] 例2local tabFiles=&#123; [2]='test2' [6]='test3' [4]='test1'&#125;for k,v in ipairs(tabFiles) do print(k,v)end--[[什么都没输出，因为控制变量初始值按升序遍历，当key为1时，value值为nil，便停止遍历，所以无结果输出--]] 例3local tabFiles = &#123; [2] = "test2", [6] = "test3", [4] = "test1"&#125;for k, v in pairs(tabFiles) do print(k, v)end--输出2 test2, 6 test3, 4 test1 例4local tabFiles=&#123; 'alpha', 'beta', [3]='no', ['two']='yes'&#125;for k,v in ipairs(tabFiles) do print(tabFiles[i])end--输出前三个，因为第四个key不是整数for i,v in pairs(tabFiles) do print(tabFiles[i])end--全部输出 协同程序(coroutine)什么是coroutine?coroutine与线程类似，拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。 coroutine与线程区别 一个具有多线程的可以同时运行几个线程，coroutine则需要彼此协作运行 在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。常用操作函数|描述|—|—|coroutine.create()|创建coroutine,返回coroutine|coroutine.resume()|重启coroutine|coroutine.yield()|挂起coroutine|coroutine.statues()|查看coroutine的状态，有三种：dead，suspend，running|coroutine.wrap()|创建corountine，返回一个函数，一旦调用这个函数，进入coroutine，和create功能重复|corountine.running()|返回正在运行的coroutine，一个coroutine是一个线程，当使用running时，返回一个coroutine的线程号|]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2Fmarkdown-tutorial%2F</url>
    <content type="text"><![CDATA[前言几年前就听说Markdown的便利，但是懒于去记忆语法，一直拖到现在才去尝试。我想，一个善于学习的人应该“拥抱变化”，人生也应该多去尝试，固守陈规是不可取的。 ##简易语法注：本文以马克飞象为例 1. 标题#，#的个数表示级数 2. 列表 创建无序列表，* 创建有序列表，直接使用 1.、2.、3 符号与文本之间用空格分开 多级列表用Tab键 3. 引用&gt;，可嵌套使用，可通过空行结束4. 分割线连续至少三个*，如***5. 目录[toc],注：前面须有空行6. 脚注[^脚注名]:脚注内容7. 斜体*内容*8.粗体**内容**9. 加粗的斜体***内容***10. 删除线~~内容~~ 11. 图片![图片名称](链接) 12. 链接[链接名](链接) [链接名][链接名]:链接 13. 代码块 Tab 行内代码一个反引号` 区块代码三个反引号``` ,后面加上语言类型 14.表格通过管线图方式表示 ####15.样式Markdown本身只是一个书写工具，其样式是通过CSS改变，支持HTML标签。【例】 改变字体颜色&lt;font color=red&gt;字体颜色为红色&lt;/font&gt;用法总结1. 不显示html代码使用html类型的代码块,如```html 内 容 ``` 2.自动链接使用&lt;&gt;包含住一段链接,如&lt;http://www.baidu.com&gt; 3.转义反引号内的反引号，也可用于转义其他字符最外层连续两个反引号,效果如图git archive master --format=zip ＞ `git describe master`.zip 4. 缩进 &amp;emsp;,一个中文字符 &amp;ensp;,半个中文字符 &amp;nbsp;,1/4个中文字符]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
