<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="算法," />





  <link rel="alternate" href="/rss2.xml" title="Wenyu's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="[TOC] 位运算371.两整数之和【题目描述】 不使用运算符 + 和-，计算两整数a 、b之和。 示例：若 a = 1 ，b = 2，返回 3。 【思路】 使用位运算，异或+移位。 【题解】 int getSum(int a, int b) &amp;#123;    while (b != 0) &amp;#123;        int c = a ^ b;        b = (a &amp;amp; b) &amp;">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法】LeetCode总结">
<meta property="og:url" content="https://tianwenyu.github.io/algorithm-leetcode/index.html">
<meta property="og:site_name" content="Wenyu&#39;s Blog">
<meta property="og:description" content="[TOC] 位运算371.两整数之和【题目描述】 不使用运算符 + 和-，计算两整数a 、b之和。 示例：若 a = 1 ，b = 2，返回 3。 【思路】 使用位运算，异或+移位。 【题解】 int getSum(int a, int b) &amp;#123;    while (b != 0) &amp;#123;        int c = a ^ b;        b = (a &amp;amp; b) &amp;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.blog.csdn.net/20140120222734218">
<meta property="og:image" content="http://p15qizl76.bkt.clouddn.com/blog/180417/A5Bh2CCjbj.png?imageslim">
<meta property="og:image" content="http://p15qizl76.bkt.clouddn.com/blog/180417/GceD8cC5h8.jpg?imageslim">
<meta property="og:image" content="http://p15qizl76.bkt.clouddn.com/blog/180417/e3Lif2Jj99.png?imageslim">
<meta property="og:updated_time" content="2018-04-30T06:35:32.225Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【算法】LeetCode总结">
<meta name="twitter:description" content="[TOC] 位运算371.两整数之和【题目描述】 不使用运算符 + 和-，计算两整数a 、b之和。 示例：若 a = 1 ，b = 2，返回 3。 【思路】 使用位运算，异或+移位。 【题解】 int getSum(int a, int b) &amp;#123;    while (b != 0) &amp;#123;        int c = a ^ b;        b = (a &amp;amp; b) &amp;">
<meta name="twitter:image" content="http://img.blog.csdn.net/20140120222734218">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://tianwenyu.github.io/algorithm-leetcode/"/>

  <title> 【算法】LeetCode总结 | Wenyu's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  <div style="display: none;">
    <script src="//s6.cnzz.com/stat.php?id=1271854965&web_id=1271854965" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader" style="background-image: url('/images/home_bg.jpg');">
      <div class="header-inner"><a class="site-home" href="/">Wenyu's Blog</a>

<div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <div href="/"  class="brand">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wenyu's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </div>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            博文归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签云
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <input type="text" id="local-search-input">
 <span class="search-icon fa fa-search"></span>
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
      <div class="header-post"> 
  <div class="post-header">
      <div class="tags">
      
        <a href="/tags/算法/" rel="tag" title="算法">算法</a>
      
      </div>
      <h1>【算法】LeetCode总结</h1>
      <h2 class="subtitle"></h2>
      <div class="post-time">
        <span class="post-meta-item-text">发表于 </span>
        <time itemprop="dateCreated" datetime="2018-03-21T19:29:36+08:00" content="2018-03-21" title="2018-03-21 19:29:36">
          2018-03-21
        </time>
      </div>
  </div>
 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【算法】LeetCode总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-21T19:29:36+08:00" content="2018-03-21">
              2018-03-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          <!-- 
            
           -->

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371.两整数之和"></a>371.两整数之和</h3><p>【题目描述】</p>
<p><strong>不使用</strong>运算符 <code>+</code> 和<code>-</code>，计算两整数<code>a</code> 、<code>b</code>之和。</p>
<p><strong>示例：</strong><br>若 <em>a</em> = 1 ，<em>b</em> = 2，返回 3。</p>
<p>【思路】</p>
<p>使用位运算，异或+移位。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(um.find(target-nums[i]) != um.end())&#123;</span><br><span class="line">                result.push_back(um[target-nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                um[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="7-反转整数"><a href="#7-反转整数" class="headerlink" title="7.反转整数"></a>7.反转整数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        sign=<span class="number">-1</span>;</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret&gt;INT_MAX || ret&lt;INT_MIN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sign*ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> isPositive=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        isPositive=<span class="literal">false</span>;</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result&gt;INT_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isPositive)</span><br><span class="line">        <span class="keyword">return</span> -result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><p>【题目描述】</p>
<p>判断一个数是否是回文数</p>
<p>【思路】</p>
<ul>
<li>直接判断不是回文数的情况<ul>
<li>负数</li>
<li>个位为0（0这个数除外，如果是0也返回true）</li>
</ul>
</li>
<li>否则用一个数字记录它逆转的一半，与其另一半做比较，查看是否相等。</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>))	<span class="comment">//负数或者个位数为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;	<span class="comment">//记录逆转的一半</span></span><br><span class="line">    <span class="keyword">while</span>(x&gt;sum)&#123;</span><br><span class="line">        sum=sum*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x==sum || x==(sum/<span class="number">10</span>); <span class="comment">//包含数字位数是奇数和偶数两种情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><p>【题目描述】</p>
<p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><p>【题目描述】</p>
<p>给定一个 <em>n </em> n* 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[4,5,6]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[7,8,9]</span></span></span><br><span class="line"><span class="comment">]</span>,</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[7,4,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[8,5,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[9,6,3]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>通过两个步骤的元素交换</p>
<ul>
<li>按照副对角线翻转一次</li>
<li>按照水平中线翻转一次</li>
</ul>
<p><img src="http://img.blog.csdn.net/20140120222734218" alt="img"></p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//按副对角线旋转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n<span class="number">-1</span>-j][n<span class="number">-1</span>-i];</span><br><span class="line">            matrix[n<span class="number">-1</span>-j][n<span class="number">-1</span>-i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按水平中心旋转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n<span class="number">-1</span>-i][j];</span><br><span class="line">            matrix[n<span class="number">-1</span>-i][j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="118-帕斯卡三角形"><a href="#118-帕斯卡三角形" class="headerlink" title="118.帕斯卡三角形"></a>118.帕斯卡三角形</h3><p>【题目描述】</p>
<p>给定 <em>numRows</em>, 生成帕斯卡三角形的前 <em>numRows </em>行。</p>
<p>例如, 给定 <em>numRows</em> = 5,</p>
<p>返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<ul>
<li>n行有n个数</li>
</ul>
<ul>
<li>每个数字等于上一行的左右两个数字之和，即第n+1行的第i个数等于第n行的第i-1个数和第i个数之和。</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//初始化1个值为1的元素</span></span><br><span class="line">        ret.push_back(last);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=numRows;i++)&#123;</span><br><span class="line">            last.push_back(<span class="number">0</span>);<span class="comment">//补齐下一位</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur=last;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)<span class="comment">//第一位都为1，因此从第二位开始</span></span><br><span class="line">                cur[j]=cur[j]+last[j<span class="number">-1</span>];</span><br><span class="line">            ret.push_back(cur);</span><br><span class="line">            last=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169.求众数"></a>169.求众数</h3><p>【题目描述】</p>
<p>给定一个大小为 n的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [3,2,3]</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [2,2,1,1,1,2,2]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。</p>
<p>在遍历数组的时候保存两个值</p>
<ul>
<li>一个是数组中的数字，一个是次数</li>
<li>如果下一个数字和我们之前保存的数字相同，则次数加1</li>
<li>如果下一个数字和我们之前保存的数字不同，则次数减1</li>
<li>如果次数为0，则保存下一个数字，并把次数设为1。</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret==nums[i])</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            times--;</span><br><span class="line">        <span class="keyword">if</span>(times==<span class="number">0</span>)&#123;</span><br><span class="line">            ret=nums[i];</span><br><span class="line">            times=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    times=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==ret)</span><br><span class="line">            times++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (times&gt;len/<span class="number">2</span>)?ret:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h3><p>【题目描述】</p>
<p>将包含n 个元素的数组向右旋转 k 步。</p>
<p>例如，如果  <em>n</em> = 7 ,  <em>k</em> = 3，给定数组  <code>[1,2,3,4,5,6,7]</code>  ，向右旋转后的结果为 <code>[5,6,7,1,2,3,4]</code>。</p>
<p>【思路】</p>
<ul>
<li>旋转左部分</li>
<li>旋转右部分</li>
<li>整体旋转</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    k=k%len;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,len-k<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,len-k,len<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(from&lt;to)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=nums[from];</span><br><span class="line">        nums[from++]=nums[to];</span><br><span class="line">        nums[to--]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="233-数字1的个数"><a href="#233-数字1的个数" class="headerlink" title="233.数字1的个数"></a>233.数字1的个数</h3><p>【题目描述】</p>
<p>给定一个整数 n，计算所有小于等于 n 的非负数中数字1出现的个数。</p>
<p>例如：</p>
<p>给定 n = 13，</p>
<p>返回 6，因为数字1出现在下数中出现：1，10，11，12，13。</p>
<p>【思路】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628.三个数的最大乘积"></a>628.三个数的最大乘积</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h3><p>【题目描述】</p>
<p>给定两个有序整数数组 <em>nums1 </em>和 <em>nums2</em>，将 <em>nums2 </em>合并到 <em>nums1 </em>中<em>，</em>使得 <em>num1 </em>成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li>
<li>你可以假设 <em>nums1 </em>有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line"><span class="section">输出: [1,2,2,3,5,6]</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>两个数组从后往前比较。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=m<span class="number">-1</span>;<span class="comment">//nums1数字长度最后一位</span></span><br><span class="line">    <span class="keyword">int</span> j=n<span class="number">-1</span>;<span class="comment">//nums2最后一位</span></span><br><span class="line">    <span class="keyword">int</span> k=m+n<span class="number">-1</span>;<span class="comment">//nums1+nums2数字长度</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">            nums1[k--]=nums2[j--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[k--]=nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//如果nums2还没结束，则把剩下的直接复制到nums1，因为剩下的nums2已经有序</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        nums1[k--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p>【题目描述】</p>
<p>给定一个数组 <code>nums</code>, 编写一个函数将所有 <code>0</code> 移动到它的末尾，同时保持非零元素的相对顺序。</p>
<p>例如， 定义 <code>nums = [0, 1, 0, 3, 12]</code>，调用函数之后， <code>nums</code> 应为 <code>[1, 3, 12, 0, 0]</code>。</p>
<p><strong>注意事项</strong>:</p>
<ol>
<li>必须在原数组上操作，不要为一个新数组分配额外空间。</li>
<li>尽量减少操作总数。</li>
</ol>
<p>【思路】</p>
<ul>
<li>对原数组进行遍历，把非零值放在前面，空出后面的位置存放0。</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i])</span><br><span class="line">            nums[index++]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;len;i++)</span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414.第三大的数"></a>414.第三大的数</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>【思路】</p>
<ul>
<li>用set，避免同一元素出现多次</li>
<li>定义反向迭代器，之后判断set中有多少个元素，小于三个时直接返回最大值，否则反向迭代就可以找到第三大的值了</li>
<li>时间复杂度是O(n)</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it=num.rbegin();</span><br><span class="line">        <span class="keyword">if</span>(num.size()&lt;<span class="number">3</span>)</span><br><span class="line">           <span class="keyword">return</span> *it; </span><br><span class="line">           </span><br><span class="line">        it++;</span><br><span class="line">        it++;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>【思路】</p>
<p>设置n1=第3大的数，n2=第2大的数，n3=最大数，最后返回n1，遍历一次即可。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> n=nums.size();  </span><br><span class="line">       <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];  </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);  </span><br><span class="line">       <span class="keyword">int</span> n1=min(nums[<span class="number">0</span>],min(nums[<span class="number">1</span>],nums[<span class="number">2</span>])),n2=max(nums[<span class="number">0</span>],min(nums[<span class="number">1</span>],nums[<span class="number">2</span>])),n3=max(nums[<span class="number">0</span>],max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]));  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">if</span>(nums[i]&gt;n3)   </span><br><span class="line">           &#123;  </span><br><span class="line">               n1=n2;  </span><br><span class="line">               n2=n3;  </span><br><span class="line">               n3=nums[i];  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;=n2)   </span><br><span class="line">           &#123;  </span><br><span class="line">              n2=nums[i];  </span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;n1)  </span><br><span class="line">           n1=nums[i];  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> n1;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><p>【思路】</p>
<p>动态规划方法。</p>
<p>动态规划问题的特点：</p>
<ul>
<li>大问题拆解为小问题</li>
<li>重复利用之前的计算结果</li>
</ul>
<p>根据回文的特性，一个大回文按比例缩小之后的字符串必定也是回文。</p>
<p>具体的递归方法有多种，这里选取两种递归方法。</p>
<hr>
<p><strong>解法1</strong></p>
<ul>
<li><code>dp[i][j]</code>表示字符串区间<code>[i,j]</code>是否为回文串<ul>
<li>当j=i时，只有一个字符，肯定是回文串</li>
<li>当j=i+1时，说明是相邻字符，需要判断s[i]是否等于s[j]</li>
<li>当j&gt;i+1时，说明是不相邻字符，除了判断s[i]和s[j]相等之外，<code>dp[i+1][j-1]</code>若为真，则是回文串，即字符串区间左侧+1，右侧-1。</li>
</ul>
</li>
<li>根据以上分析，写出状态转移方程</li>
</ul>
<p>$$<br>\begin{equation}<br>dp[i][j]=\left{<br>\begin{aligned}<br>1&amp; &amp; (i=j) \<br>=(s[i]==s[j]) &amp;  &amp; (j=i+1) \<br>=(s[i]==s[j] \&amp;\&amp;dp[i+1][j-1]) &amp;&amp;(j&gt;i+1)<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p>
<p>【题解】</p>
<p><strong>（未理解）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()][s.size()]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;<span class="comment">//最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//最长回文子串的起点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">              	dp[j][j]=<span class="number">1</span>;<span class="comment">//边界条件</span></span><br><span class="line">              	<span class="comment">//状态转移方程的二三个情况合写</span></span><br><span class="line">                dp[i][j]=(s[i]==s[j] &amp;&amp; (j-i&lt;=<span class="number">1</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]));</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; len&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                    len=j-i+<span class="number">1</span>;</span><br><span class="line">                    start=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,len);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>解法2</p>
<p>【思路】</p>
<ul>
<li><p><code>dp[i][j]</code>表示s[i]到s[j]所表示的子串是否为回文子串，是则为1，不是为0.</p>
<ul>
<li>若s[i]==s[j]，<ul>
<li>若s[i+1]到s[j-1]是回文子串，s[i]到s[j]就是回文子串。</li>
<li>若s[i+1]到s[j-1]不是回文子串，s[i]到s[j]则不是回文子串。</li>
</ul>
</li>
<li>若s[i]!=s[j]，则s[i]到s[j]一定不是回文子串。</li>
</ul>
</li>
<li><p>状态转移方程<br>$$<br>\begin{equation}<br>dp[i][j]=\left{<br>\begin{aligned}<br>dp[i+1][j-1]&amp; &amp; s[i]==s[j] \<br>0 &amp;  &amp; s[i]!=s[j]\</p>
<p>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>​</p>
</li>
<li><p>边界：<code>dp[i][i]=1</code>，<code>dp[i][i+1]=(s[i]==s[i+1]?1:0)</code></p>
<p>​</p>
</li>
</ul>
<h3 id="8-字符串转整数（atoi）"><a href="#8-字符串转整数（atoi）" class="headerlink" title="8.字符串转整数（atoi）"></a>8.字符串转整数（atoi）</h3><p>【思路】</p>
<ul>
<li>字符串格式的合法判断<ul>
<li>空格不计入计算，从第一个非空字符开始判断，</li>
<li>首字母只能是<code>+</code>、<code>-</code>或数字</li>
</ul>
</li>
<li>转换结果的溢出判断<ul>
<li><code>Int类型</code>范围是<code>INT_MIN(-2147482648)</code>到<code>INT_MAX(2147483647)</code>，超出范围则返回最大与最小值。因此使用long long 类型变量储存结果。</li>
<li>如果正确的值超过的可表示的范围，则返回 <code>INT_MAX（2147483647）</code>或 <code>INT_MIN（-2147483648）</code>。</li>
<li>如果不能执行有效的转换，则返回 0。</li>
<li>字符串可以在形成整数的字符后包括多余的字符，将这些字符忽略，这些字符对于函数的行为没有影响。</li>
</ul>
</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(str[index]==<span class="string">' '</span>)</span><br><span class="line">        index++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str[index]==<span class="string">'+'</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[index]==<span class="string">'-'</span>)&#123;</span><br><span class="line">        sign=<span class="number">-1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;index&lt;str.length();index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[index]&gt;=<span class="string">'0'</span> &amp;&amp; str[index]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            result=result*<span class="number">10</span>+(str[index]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(result&gt;INT_MAX)</span><br><span class="line">                <span class="keyword">return</span> sign&gt;<span class="number">0</span>?INT_MAX:INT_MIN;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result*=sign;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h3><p>【题目描述】</p>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<p>【思路】</p>
<h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h3><p>【题目描述】</p>
<p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="string">"11"</span>, <span class="selector-tag">b</span> = <span class="string">"1"</span></span><br><span class="line">输出: <span class="string">"100"</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="string">"1010"</span>, <span class="selector-tag">b</span> = <span class="string">"1011"</span></span><br><span class="line">输出: <span class="string">"10101"</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>用0补齐较短字符串左侧至两字符串相等，然后相加即可。</p>
<p>【题解】</p>
<p>未通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len1=a.size();</span><br><span class="line">        <span class="keyword">int</span> len2=b.size();</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len1&gt;len2)&#123;</span><br><span class="line">            b=<span class="string">'0'</span>+b;</span><br><span class="line">            len2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(len2&gt;len1)&#123;</span><br><span class="line">            a=<span class="string">'0'</span>+b;</span><br><span class="line">            len1++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len1)&#123;</span><br><span class="line">            len1--;</span><br><span class="line">            <span class="keyword">int</span> tmp=(a[len1]-<span class="string">'0'</span>)+(b[len1]-<span class="string">'0'</span>)+carry;</span><br><span class="line">            result=to_string(carry%<span class="number">2</span>)+result;</span><br><span class="line">            carry=tmp/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后一位有进位，单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            result[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">            result=<span class="string">'1'</span>+result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">int</span> aSize = a.size();  </span><br><span class="line">        <span class="keyword">int</span> bSize = b.size();  </span><br><span class="line">        <span class="keyword">while</span>(aSize&gt;bSize)&#123;  </span><br><span class="line">            b = <span class="string">'0'</span> + b;  </span><br><span class="line">            bSize++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(bSize&gt;aSize)&#123;  </span><br><span class="line">            a = <span class="string">'0'</span> + a;  </span><br><span class="line">            aSize++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;  </span><br><span class="line">        <span class="keyword">while</span>(aSize)&#123;  </span><br><span class="line">            aSize--;  </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">                <span class="keyword">if</span>((a[aSize] - <span class="string">'0'</span>)^(b[aSize]-<span class="string">'0'</span>))&#123;  </span><br><span class="line">                    result = <span class="string">'0'</span> + result;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((a[aSize]-<span class="string">'0'</span>)&amp;&amp;(b[aSize]-<span class="string">'0'</span>))&#123;  </span><br><span class="line">                    result = <span class="string">'1'</span> + result;  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                    result = <span class="string">'1'</span> + result;  </span><br><span class="line">                    flag = <span class="literal">false</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">if</span>((a[aSize]-<span class="string">'0'</span>)^(b[aSize]-<span class="string">'0'</span>))  </span><br><span class="line">                    result = <span class="string">'1'</span> + result;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((a[aSize]-<span class="string">'0'</span>)&amp;&amp;(b[aSize]-<span class="string">'0'</span>))&#123;  </span><br><span class="line">                    flag = <span class="literal">true</span>;  </span><br><span class="line">                    result = <span class="string">'0'</span> + result;  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                    result = <span class="string">'0'</span> + result;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag) result = <span class="string">'1'</span> + result;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="125-验证回文字符串"><a href="#125-验证回文字符串" class="headerlink" title="125.验证回文字符串"></a>125.验证回文字符串</h3><p>【思路】</p>
<p>使用一头一尾两个指针，反方向判断是否一一满足即可。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlphanumeric</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">toLower</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a'</span> + c - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; s.size() &amp;&amp; !isAlphanumeric(s[begin]))</span><br><span class="line">            begin++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; !isAlphanumeric(s[end])) </span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= begin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (toLower(s[begin]) != toLower(s[end]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###242.有效的字母异位词</p>
<p>【问题描述】</p>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的一个字母异位词。</p>
<p>例如，<br><em>s</em> = “anagram”，<em>t</em> = “nagaram”，返回 true<br><em>s</em> = “rat”，<em>t</em> = “car”，返回 false</p>
<p>【思路】</p>
<p>求每个字符个数判别是否相等。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len1=s.size();</span><br><span class="line">    <span class="keyword">int</span> len2=t.size();</span><br><span class="line">  	<span class="comment">//如果两个字符串长度不同，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(len1!=len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//词频统计</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        count[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)</span><br><span class="line">        count[t[i]-<span class="string">'a'</span>]--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h3><p>【问题描述】</p>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>案例:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"leetcode"</span></span><br><span class="line">返回 0.</span><br><span class="line"></span><br><span class="line">s = <span class="string">"loveleetcode"</span>,</span><br><span class="line">返回 2.</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<ul>
<li>字频统计</li>
<li>找出第一个出现次数为1的字符</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">        count[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[s[i]-<span class="string">'a'</span>]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="409-Longest-Palindrome"><a href="#409-Longest-Palindrome" class="headerlink" title="409 Longest Palindrome"></a>409 Longest Palindrome</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>【题目描述】</p>
<p>给定两个<strong>非空</strong>链表来表示两个非负整数。位数按照<strong>逆序</strong>方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<ul>
<li>遍历两个链表。<ul>
<li>将两个结点的值相加，大于10的值进位，放入结果链表中。记录除数和余数。</li>
</ul>
</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1 || !l2 )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 || l2 || carry)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=(l1?l1-&gt;val:<span class="number">0</span>)+(l2?l2-&gt;val:<span class="number">0</span>)+carry;</span><br><span class="line">        p-&gt;next=<span class="keyword">new</span> ListNode(tmp%<span class="number">10</span>);<span class="comment">//tmp%10用来记录相加后的数。</span></span><br><span class="line">        carry=tmp/<span class="number">10</span>;<span class="comment">//carry的范围最大不超过18，因此可用来记录进位。</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        l1=l1?l1-&gt;next:l1;</span><br><span class="line">        l2=l2?l2-&gt;next:l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       ListNode *result;</span><br><span class="line">       <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">           result=l1;</span><br><span class="line">           result-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           result=l2;</span><br><span class="line">           result-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-两两交换链表中的结点"><a href="#24-两两交换链表中的结点" class="headerlink" title="24.两两交换链表中的结点"></a>24.两两交换链表中的结点</h3><p>【题目描述】</p>
<p><img src="http://p15qizl76.bkt.clouddn.com/blog/180417/A5Bh2CCjbj.png?imageslim" alt="mark"></p>
<p>【思路】</p>
<p><img src="http://p15qizl76.bkt.clouddn.com/blog/180417/GceD8cC5h8.jpg?imageslim" alt="mark"></p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *dummy=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode *pre=dummy;</span><br><span class="line">    ListNode *cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur&amp;&amp;cur-&gt;next)&#123;</span><br><span class="line">        pre-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        pre-&gt;next-&gt;next=cur;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h3><p>【题目描述】</p>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k个位置，其中k是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">3</span> 步: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">4</span> 步: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>先计算链表长度，然后从头遍历链表直到倒数第k个点，即原链表倒数k个元素成为新链表的前部分，原链表的前(len-k)个元素成为新链表的后部分。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    k%=len;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;<span class="comment">//记录新链表的位置</span></span><br><span class="line">    p=head;</span><br><span class="line">    <span class="comment">//寻找右旋k个位置后，新链表的首个结点</span></span><br><span class="line">    <span class="keyword">while</span>(index&lt;(len-k) &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *ret=p-&gt;next;</span><br><span class="line">    ListNode *q=p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//原链表寻找尾结点，将其链接到head</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    p-&gt;next=head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前部分尾结点设为NULL</span></span><br><span class="line">    q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="82-删除排序链表中的重复元素Ⅱ"><a href="#82-删除排序链表中的重复元素Ⅱ" class="headerlink" title="82.删除排序链表中的重复元素Ⅱ"></a>82.删除排序链表中的重复元素Ⅱ</h3><p>【题目描述】</p>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现 </em>的数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *dummy=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *p=dummy;</span><br><span class="line">    ListNode *q=head;</span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;next &amp;&amp; q-&gt;next-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = q-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; q-&gt;val==tmp)</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(q)</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83.删除排序链表中的重复元素"></a>83.删除排序链表中的重复元素</h3><p>【题目描述】</p>
<p>给定一个排序链表，删除所有重复的元素使得每个元素只留下一个。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val == p-&gt;next-&gt;val)</span><br><span class="line">            p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86.分隔链表"></a>86.分隔链表</h3><p>【题目描述】</p>
<p>给定一个链表和一个特定值x<em>，对链表进行分隔，使得所有小于 </em>x<em> 的节点都在大于或等于 </em>x* 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: head = <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>, x = <span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<ul>
<li>在数组partition中，一般是通过首尾两个指针来进行前后遍历以及交换；</li>
<li>而在链表中，不需要进行元素的交换，可以通过创建两个新的头结点指针，来分别指向小于x的结点和大于等于x的结点，遍历结束之后，再将两个新的链表重新连接起来。</li>
</ul>
<p>【题解】</p>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><p>【题目描述】</p>
<p>给定一个链表，判断链表中否有环。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode *slowP=head;</span><br><span class="line">    ListNode *fastP=head;</span><br><span class="line">    <span class="keyword">while</span>(fastP&amp;&amp;fastP-&gt;next)&#123;</span><br><span class="line">        fastP=fastP-&gt;next-&gt;next;</span><br><span class="line">        slowP=slowP-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slowP==fastP)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h3><p>【题目描述】</p>
<p>给一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isCycle=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *slowP=head;</span><br><span class="line">    ListNode *fastP=head;</span><br><span class="line">    <span class="keyword">while</span>(fastP-&gt;next!=<span class="literal">NULL</span>&amp;&amp;fastP-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        fastP=fastP-&gt;next-&gt;next;</span><br><span class="line">        slowP=slowP-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slowP==fastP)&#123;</span><br><span class="line">            isCycle=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isCycle)&#123;</span><br><span class="line">        fastP=head;</span><br><span class="line">        <span class="keyword">while</span>(slowP!=<span class="literal">NULL</span>&amp;&amp;fastP!=<span class="literal">NULL</span>&amp;&amp;fastP!=slowP)&#123;</span><br><span class="line">            slowP=slowP-&gt;next;</span><br><span class="line">            fastP=fastP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowP;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143.重排链表"></a>143.重排链表</h3><p>【题目描述】</p>
<p><img src="http://p15qizl76.bkt.clouddn.com/blog/180417/e3Lif2Jj99.png?imageslim" alt="mark"></p>
<p>【思路】</p>
<ul>
<li>使用快慢指针将链表从中间分割成两段</li>
</ul>
<ul>
<li>后半段就地逆置</li>
<li>合并插入到前半段链表即可。</li>
</ul>
<p>时间复杂度O(n).</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    ListNode *slow=head;</span><br><span class="line">    ListNode *fast=head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        pre=slow;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next=<span class="literal">NULL</span>;<span class="comment">//从中间切分</span></span><br><span class="line">    </span><br><span class="line">    ListNode *rHead=reverse(slow);<span class="comment">//rHead是逆置后的头结点</span></span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//合并两个链表</span></span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = rHead;</span><br><span class="line">        rHead= rHead-&gt;next;</span><br><span class="line">        cur-&gt;next-&gt;next = tmp;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = rHead; <span class="comment">//链接上最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        next=head-&gt;next;</span><br><span class="line">        head-&gt;next=pre;</span><br><span class="line">        pre=head;</span><br><span class="line">        head=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147.链表插入排序"></a>147.链表插入排序</h3><p>【题目描述】</p>
<p>用插入排序对链表进行排序。</p>
<p>【思路】</p>
<p>插入排序的链表实现版。</p>
<p>新建一个头结点，来保存排序后的链表。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//边界条件判断</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">  	<span class="comment">//创建一个新的链表头部</span></span><br><span class="line">    ListNode *sortedHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//排序后的链表当前结点</span></span><br><span class="line">  	ListNode *cur=sortedHead;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur=sortedHead;</span><br><span class="line">        <span class="comment">//寻找插入点</span></span><br><span class="line">      	<span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val&lt;p-&gt;val)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        <span class="comment">//保存原链表当前结点的next域</span></span><br><span class="line">      	ListNode *tmp=p-&gt;next;</span><br><span class="line">        <span class="comment">//插入结点</span></span><br><span class="line">      	p-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=p;</span><br><span class="line">      	<span class="comment">//移动到原链表的下一个位置</span></span><br><span class="line">        p=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h3><p>【题目描述】</p>
<p>找到两个单链表相交的起始结点</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    ListNode *s=head;</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        s=s-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA||!headB)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len1=GetLength(headA);</span><br><span class="line">    <span class="keyword">int</span> len2=GetLength(headB);</span><br><span class="line">    <span class="keyword">int</span> diff=len1-len2;</span><br><span class="line">    ListNode *fast=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *slow=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(diff&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        fast=headA;</span><br><span class="line">        slow=headB;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fast=headB;</span><br><span class="line">        slow=headA;</span><br><span class="line">        diff=-diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;diff;i++)&#123;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; slow &amp;&amp; fast!=slow)&#123;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="203-删除链表中的元素"><a href="#203-删除链表中的元素" class="headerlink" title="203.删除链表中的元素"></a>203.删除链表中的元素</h3><p>【题目描述】</p>
<p>删除链表中等于给定值 <strong>val </strong>的所有元素。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==head &amp;&amp; p-&gt;val==val)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            head=p;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val==val)&#123;</span><br><span class="line">            pre-&gt;next=p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p=pre-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>【思路】</p>
<p>即链表逆置</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        next=head-&gt;next;</span><br><span class="line">        head-&gt;next=pre;</span><br><span class="line">        pre=head;</span><br><span class="line">        head=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><h4 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h4><p>【思路】</p>
<ul>
<li>将链表后半段翻转<ul>
<li>寻找链表中分界点的方法是：快慢指针法，fast指针一次走两步，slow指针一次走一步</li>
<li>当遍历结束时，如果链表长度是奇数，则slow刚好在中间，若链表长度是偶数，则slow在中间前一个。</li>
</ul>
</li>
<li>将前半段与后半段比较</li>
<li>时间复杂度O(n)</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空或者是只有一个，必定是回文链表，返回true</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow=head;</span><br><span class="line">        ListNode *fast=head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rHead是逆转后的头结点</span></span><br><span class="line">        </span><br><span class="line">        ListNode *rHead=slow;</span><br><span class="line">        <span class="comment">//如果链表长度是奇数，则rHead在中间；如果链表长度是偶数，则rHead在中间前一个。</span></span><br><span class="line">        <span class="comment">//不论链表长度是奇数还是偶数，只需要一种情况处理。</span></span><br><span class="line">        <span class="comment">//如1234321，slow在4上，只需要判断123和321相同即可。</span></span><br><span class="line">        <span class="comment">//如123321，长度是偶数，slow在第一个3上，判断123和321是否相同即可。</span></span><br><span class="line">        rHead=reverse(rHead-&gt;next);</span><br><span class="line">        <span class="keyword">while</span>(rHead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rHead-&gt;val != head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            rHead=rHead-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            next=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h4><p>【思路】</p>
<ul>
<li>用一个vector把链表里的值一次性push进去。</li>
<li>遍历vector，判断v[i]与v[v.size()-i-1]是否相等<ul>
<li>不相等，直接返回false</li>
<li>遍历结束，返回true</li>
</ul>
</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            v.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size() / <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] != v[v.size() - i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328.Odd Even Linked List"></a>328.Odd Even Linked List</h3><p>【题目描述】</p>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p><strong>Example:</strong><br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>return <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.</p>
<p><strong>Note:</strong><br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<p>【思路】</p>
<ul>
<li>定义两个链表，奇数链表和偶数链表</li>
<li>用两个指针遍历链表，每次遍历两个结点（奇数结点和偶数结点），然后将偶数链表的头部接在奇数链表的尾部。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *oddHead=head;	<span class="comment">//奇数链表头</span></span><br><span class="line">    ListNode *evenHead=head-&gt;next;<span class="comment">//偶数链表头</span></span><br><span class="line">    ListNode *curOdd=oddHead;<span class="comment">//当前奇数指针</span></span><br><span class="line">    ListNode *curEven=evenHead;<span class="comment">//当前偶数指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curEven &amp;&amp; curEven-&gt;next)&#123;</span><br><span class="line">        curOdd-&gt;next=curEven-&gt;next;</span><br><span class="line">        curOdd=curOdd-&gt;next;</span><br><span class="line">        curEven-&gt;next=curOdd-&gt;next;</span><br><span class="line">        curEven=curEven-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    curOdd-&gt;next=evenHead;<span class="comment">//偶数链表的头部接在奇数链表的尾部</span></span><br><span class="line">    <span class="keyword">return</span> oddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94.中序遍历二叉树"></a>94.中序遍历二叉树</h3><p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode *p=root;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><p>【题目描述】</p>
<p>给定一个二叉树，返回其按层次遍历的节点值。 </p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelResult;        </span><br><span class="line">        q.push(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            </span><br><span class="line">            levelResult.clear();</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                p=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">                levelResult.push_back(p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(levelResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><h4 id="解法1-2"><a href="#解法1-2" class="headerlink" title="解法1"></a>解法1</h4><p>DFS方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth=maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth=maxDepth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (leftDepth&gt;rightDepth)?(leftDepth+<span class="number">1</span>):(rightDepth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法2-2"><a href="#解法2-2" class="headerlink" title="解法2"></a>解法2</h4><p>BFS方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;<span class="comment">//记录队列中每一层的元素个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">                count=q.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="107-二叉树的层次遍历Ⅱ"><a href="#107-二叉树的层次遍历Ⅱ" class="headerlink" title="107.二叉树的层次遍历Ⅱ"></a>107.二叉树的层次遍历Ⅱ</h3><p>【题目描述】</p>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回其自自底向上的层次遍历为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>在102题的基础上，将输出的结果逆序即可。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    TreeNode *p=root;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(p);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelResult;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        levelResult.clear();</span><br><span class="line">        <span class="keyword">int</span> size=q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            levelResult.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(levelResult);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(result.begin(),result.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>【题目描述】</p>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">给定有序数组: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>使用递归方法。</p>
<p>每次找到排序数组的中点，中点左边的子排序数组构成左子树，中点右边的子排序数组构成右子树,递归进行。</p>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> buildBST(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">buildBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    TreeNode *node=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    node-&gt;left=buildBST(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">    node-&gt;right=buildBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><p>【思路】</p>
<p>用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前就已经遍历了它的左右子树。</p>
<p>只要在遍历每个结点的时候记录它的深度，就可以一边遍历一边判断每个结点是否平衡。</p>
<ul>
<li>如果子树是平衡二叉树，则返回子树高度</li>
<li>如果子树不是平衡二叉树，直接停止遍历</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root,&amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root,<span class="keyword">int</span> *depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        *depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isBalanced(root-&gt;left,&amp;leftDepth) &amp;&amp; isBalanced(root-&gt;right,&amp;rightDepth))&#123;</span><br><span class="line">        <span class="keyword">int</span> diff=leftDepth-rightDepth;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(diff)&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            *depth=<span class="number">1</span>+(leftDepth&gt;rightDepth?leftDepth:rightDepth);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="111-二叉树最小深度"><a href="#111-二叉树最小深度" class="headerlink" title="111.二叉树最小深度"></a>111.二叉树最小深度</h3><p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth=minDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth=minDepth(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(leftDepth==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(rightDepth==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (leftDepth&lt;rightDepth)?leftDepth+<span class="number">1</span>:rightDepth+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h3><p>【题目描述】</p>
<p>给定一个二叉树，<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757" target="_blank" rel="external">原地</a>将它展开为链表。</p>
<p>例如，给定二叉树</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>将其展开为：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">       <span class="keyword">if</span>(!root)</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       TreeNode* p=root;</span><br><span class="line">       <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">       <span class="keyword">while</span>(p||!s.empty())&#123;</span><br><span class="line">           <span class="keyword">while</span>(p)&#123;</span><br><span class="line">               result.push_back(p-&gt;val);</span><br><span class="line">               s.push(p);</span><br><span class="line">               p=p-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">               p=s.top();</span><br><span class="line">               s.pop();</span><br><span class="line">               p=p-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        TreeNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        s.push(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            <span class="keyword">if</span>((!p-&gt;left &amp;&amp; !p-&gt;right)||(pre &amp;&amp; (pre==p-&gt;left || pre==p-&gt;right)))&#123;</span><br><span class="line">                result.push_back(p-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">                pre=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    s.push(p-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    s.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="230-二叉搜素树第k小的元素"><a href="#230-二叉搜素树第k小的元素" class="headerlink" title="230.二叉搜素树第k小的元素"></a>230.二叉搜素树第k小的元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||k&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                p=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count==k)</span><br><span class="line">                    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h3><p>【题目描述】</p>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素x推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">M<span class="keyword">in</span>Stack <span class="keyword">min</span>Stack = new M<span class="keyword">in</span>Stack();</span><br><span class="line"><span class="keyword">min</span>Stack.push(-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">min</span>Stack.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">min</span>Stack.push(-<span class="number">3</span>);</span><br><span class="line"><span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line"><span class="keyword">min</span>Stack.pop();</span><br><span class="line"><span class="keyword">min</span>Stack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line"><span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure>
<p>【思路】</p>
<p>使用两个栈，一个栈是正常的栈s，另一个栈是存最小值的栈sm。</p>
<ul>
<li>push时，判断sm是否为空，以下两种情况在sm中插入x<ul>
<li>为空</li>
<li>非空但栈顶元素大于插入值的</li>
</ul>
</li>
<li>pop时，s的元素删除，若sm中的元素与s的元素相等，则一同删除。</li>
</ul>
<p>【题解】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        <span class="keyword">if</span>(sm.empty() || (!sm.empty() &amp;&amp; sm.top()&gt;=x))</span><br><span class="line">            sm.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.top()==sm.top())</span><br><span class="line">            sm.pop();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sm.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag">#算法</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/algorithm-offer/" rel="next" title="【算法】剑指Offer总结">
                <i class="fa fa-chevron-left"></i> 【算法】剑指Offer总结
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/centos-install-python/" rel="prev" title="CentOS7安装python3">
                CentOS7安装python3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">84</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">标签云</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/rss2.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/tianwenyu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算"><span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#371-两整数之和"><span class="nav-text">371.两整数之和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数"><span class="nav-text">数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-两数之和"><span class="nav-text">1.两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-反转整数"><span class="nav-text">7.反转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-回文数"><span class="nav-text">9.回文数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-三数之和"><span class="nav-text">15.三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-旋转图像"><span class="nav-text">48.旋转图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#118-帕斯卡三角形"><span class="nav-text">118.帕斯卡三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#169-求众数"><span class="nav-text">169.求众数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#189-旋转数组"><span class="nav-text">189.旋转数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#233-数字1的个数"><span class="nav-text">233.数字1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#628-三个数的最大乘积"><span class="nav-text">628.三个数的最大乘积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#88-合并两个有序数组"><span class="nav-text">88.合并两个有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-移动零"><span class="nav-text">283.移动零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#414-第三大的数"><span class="nav-text">414.第三大的数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法1"><span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法2"><span class="nav-text">解法2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-最长回文子串"><span class="nav-text">5.最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-字符串转整数（atoi）"><span class="nav-text">8.字符串转整数（atoi）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-text">14.最长公共前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-二进制求和"><span class="nav-text">67.二进制求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-验证回文字符串"><span class="nav-text">125.验证回文字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#387-字符串中的第一个唯一字符"><span class="nav-text">387.字符串中的第一个唯一字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#409-Longest-Palindrome"><span class="nav-text">409 Longest Palindrome</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两数相加"><span class="nav-text">2.两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-text">21.合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-两两交换链表中的结点"><span class="nav-text">24.两两交换链表中的结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-旋转链表"><span class="nav-text">61.旋转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-删除排序链表中的重复元素Ⅱ"><span class="nav-text">82.删除排序链表中的重复元素Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83-删除排序链表中的重复元素"><span class="nav-text">83.删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-分隔链表"><span class="nav-text">86.分隔链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-环形链表"><span class="nav-text">141.环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-环形链表Ⅱ"><span class="nav-text">142.环形链表Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#143-重排链表"><span class="nav-text">143.重排链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#147-链表插入排序"><span class="nav-text">147.链表插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-相交链表"><span class="nav-text">160.相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#203-删除链表中的元素"><span class="nav-text">203.删除链表中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-反转链表"><span class="nav-text">206.反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234-回文链表"><span class="nav-text">234.回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法1-1"><span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法2-1"><span class="nav-text">解法2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#328-Odd-Even-Linked-List"><span class="nav-text">328.Odd Even Linked List</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#94-中序遍历二叉树"><span class="nav-text">94.中序遍历二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-二叉树的层序遍历"><span class="nav-text">102.二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-二叉树的最大深度"><span class="nav-text">104.二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法1-2"><span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法2-2"><span class="nav-text">解法2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-二叉树的层次遍历Ⅱ"><span class="nav-text">107.二叉树的层次遍历Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-将有序数组转换为二叉搜索树"><span class="nav-text">108.将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-平衡二叉树"><span class="nav-text">110.平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-二叉树最小深度"><span class="nav-text">111.二叉树最小深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-二叉树展开为链表"><span class="nav-text">114.二叉树展开为链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-二叉树的前序遍历"><span class="nav-text">144.二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-二叉树的后序遍历"><span class="nav-text">145.二叉树的后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#230-二叉搜素树第k小的元素"><span class="nav-text">230.二叉搜素树第k小的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#155-最小栈"><span class="nav-text">155.最小栈</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/BearD01001/hexo-theme-nextd">
    NexTD
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




    <link rel='stylesheet' href='https://imsun.github.io/gitment/style/default.css'>
    <style>
        .gitment-editor-avatar {
            border-bottom: none !important;
        }
        .gitment-container a:hover {
            text-decoration: none !important;
        }
        .gitment-markdown a,
        .gitment-footer-project-link {
            color: #555 !important;
        }
        .gitment-footer-project-link:hover,
        .gitment-editor-logout-link:hover,
        .gitment-editor-footer-tip:hover,
        .gitment-header-issue-link:hover,
        .gitment-comment-name:hover,
        .gitment-markdown a:hover {
            color: #222 !important;
        }
    </style>
    <script src='https://imsun.github.io/gitment/dist/gitment.browser.js'></script>
    <script type='text/javascript'>
        (function() {
            var id = window.location.pathname.replace(/(\/$)/g, '');
            var owner = 'tianwenyu';
            var repo = 'tianwenyu.github.io';
            var clientId = '7e6796bf4bd74a25333f';
            var clientSecret = 'd190223868b2175fbce4094e6485195cef7d3e8a';

            var gitment = new Gitment({
                id: id,
                owner: owner,
                repo: repo,
                oauth: {
                    client_id: clientId,
                    client_secret: clientSecret,
                },
            });
            gitment.render('comments');
        })();
    </script>



	





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').fadeToggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ decodeURIComponent(data_url) +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').fadeOut(function() {
          $(".popoverlay").remove();
          $('body').css('overflow', '');
      });
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
