<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenyu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianwenyu.github.io/"/>
  <updated>2018-08-05T10:17:14.218Z</updated>
  <id>https://tianwenyu.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概率图模型：HMM和CRF</title>
    <link href="https://tianwenyu.github.io/graph-model/"/>
    <id>https://tianwenyu.github.io/graph-model/</id>
    <published>2018-04-25T11:29:36.000Z</published>
    <updated>2018-08-05T10:17:14.218Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="结构化学习-Structured-Learning"><a href="#结构化学习-Structured-Learning" class="headerlink" title="结构化学习(Structured Learning)"></a>结构化学习(Structured Learning)</h3><a id="more"></a><p>概率图模型属于结构化学习的一种，把$F(x,y)$换成了概率。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180802/0iH3DCfcmh.png?imageslim" alt="mark"></p><p>结构化学习中有三个问题：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180802/Aif9mc0bEh.png?imageslim" alt="mark"></p><h3 id="概率图模型-Graphical-Model"><a href="#概率图模型-Graphical-Model" class="headerlink" title="概率图模型(Graphical Model)"></a>概率图模型(Graphical Model)</h3><p><img src="https://pic3.zhimg.com/80/v2-714c1843f78b6aecdb0c57cdd08e1c6a_hd.jpg" alt="img"></p><h2 id="隐马尔科夫模型-Hidden-Markov-Model"><a href="#隐马尔科夫模型-Hidden-Markov-Model" class="headerlink" title="隐马尔科夫模型(Hidden Markov Model)"></a>隐马尔科夫模型(Hidden Markov Model)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>【定义】</p><ul><li><p>HMM(Hidden Markov Model)是一个概率模型，用来描述一个系统隐藏状态的转移概率和观测状态（隐藏状态的表现）的发射概率。</p></li><li><p>HMM是关于时序的概率模型,描述由一个隐藏的马尔科夫链生成不可观测的状态随机序列,再由各个状态生成观测随机序列的过程.</p><ul><li><p><code>Hidden</code>：说明状态的不可见性，即隐藏状态。</p></li><li><p><code>Markov</code>：说明状态和状态之间是Markov Chain。</p><p>Markov Chain服从Markov性质——无记忆性：任一时刻的状态只依赖于前一时刻，而不受更往前时刻的状态的影响。</p></li><li><p><code>隐藏状态</code>：指一些外界不便于观察（或观察不到）的状态。</p></li><li><p><code>观测状态</code>：指可以观察到的，由隐藏状态产生的外在表现特点。</p></li></ul></li></ul><p>【五个要素】</p><ul><li>观测状态</li><li>隐藏状态</li><li>初始概率</li><li>转移概率</li><li>发射概率</li></ul><p><strong>注：概率都可以用矩阵表示出</strong></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180731/EBKEcdjI4L.png?imageslim" alt="mark"></p><p><img src="https://wenlongshen.github.io/img/post/2016_12_18_hmm_1.jpg" alt="img"></p><p>【三个假设】</p><ul><li>齐次马尔可夫假设：又叫一阶马尔可夫假设，即任意时刻的状态只依赖前一时刻的状态，与其他时刻无关。</li><li>观测独立性假设：任意时刻的观测只依赖于该时刻的状态，与其他状态无关。</li><li>参数不变性假设：五个要素不随时间的变化而改变，即在整个训练过程中一直保持不变。</li></ul><p>【三个问题】</p><ul><li><p>Scoring（概率计算问题）</p><ul><li>问题描述：在已知模型参数和观测序列的条件下，求给定观测序列出现的概率。即得到概率公式。</li><li><p>解决算法</p><ul><li><p>暴力算法：O($T*N^T$)</p><p>I的遍历个数为$N^T$，加和符号中有$2^T$,T是观测状态的数目</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180802/GAeimIBcKl.png?imageslim" alt="mark"></p><p>​</p></li><li><p>前向算法：O($T*N^2$)</p></li><li><p>后向算法：O($T*N^2$)</p></li></ul></li></ul></li><li><p>Matching(Decoding)：</p><ul><li><p>问题描述：已知模型参数和观测序列，求观测序列对应的最可能的状态序列。即计算概率最大的状态序列。</p></li><li><p>解决算法</p><ul><li><p>近似算法$\to$贪心思想$\to$局部最优</p><p>此算法思想是在观测O的前提下每个时刻t选择该时刻概率最大的状态。</p></li><li><p>维特比算法$\to$动态规划</p></li></ul></li></ul></li><li><p>Training：Baum-Welch算法</p><ul><li>问题描述：已知观测序列，估计模型参数。</li><li>解决算法<ul><li>监督学习算法</li><li>非监督学习算法：Baum-Welch算法(EM)算法</li></ul></li></ul></li></ul><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180802/h27F8h2DJa.png?imageslim" alt="mark"></p><p>【资料】</p><ul><li><a href="https://www.cnblogs.com/liuwu265/p/4732797.html" target="_blank" rel="external">隐马尔可夫模型（HMM）原理</a></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180802/Igm6kgaJ9g.png?imageslim" alt="mark"></p><h3 id="三个基本问题求解算法"><a href="#三个基本问题求解算法" class="headerlink" title="三个基本问题求解算法"></a>三个基本问题求解算法</h3><h4 id="概率计算问题"><a href="#概率计算问题" class="headerlink" title="概率计算问题"></a>概率计算问题</h4><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/bGih4aH209.png?imageslim" alt="mark"></p><ul><li>第一行是隐藏状态序列</li><li>第二行是观测状态序列</li></ul><h5 id="前向算法"><a href="#前向算法" class="headerlink" title="前向算法"></a>前向算法</h5><p>【定义】</p><p>给定隐马尔科夫模型$\lambda$,当第t个时刻的状态为i时，前面的时刻分别观测到$y_1,y_2,…,y_t$的概率称为前向概率。 $\alpha_t(i)=P(y_1,y_2,…,y_t,q_t=i|\lambda)$。</p><p>【输入输出】</p><ul><li>输入：隐马尔科夫模型$\lambda$，观测序列$Y$</li><li>输出：观测序列概率$p(Y|\lambda)$</li></ul><p>【步骤】</p><ol><li><p><strong>初值</strong></p><script type="math/tex; mode=display">\alpha_1(i)=\pi_i b_{iy_1}\qquad i=1,2,...,N</script><p>其中，$\pi$是初始状态概率向量，$b_{iy_1}$是观测概率矩阵（即发射概率矩阵）$B$的对应第i个隐藏状态观测到观测状态$y_1$的概率。</p></li><li><p><strong>递推</strong></p><script type="math/tex; mode=display">对于t=1,2,...,T-1\\\alpha_{t+1}(i)=(\sum_{j=1}^N\alpha_t(j)a_{ji}){b_{iy_{t+1}}}</script><p>注：t+1时刻的前向概率$\alpha_{t+1}(i)$的求法是：所有t时刻的隐藏状态转移到t+1时刻的隐藏状态的概率之和与t时刻的发射概率的乘积。</p><p>解：</p><ul><li>t时刻的状态为j的前向概率是$\alpha<em>t(j)$，现在时刻t状态为j的概率已知，乘上状态j转移到状态i的转移概率就是t+1时刻的状态为i的概率，即$\alpha_t(j)a</em>{ji}$</li><li>由状态到观测，乘上状态i得到观测$y<em>{t+1}$的概率$b</em>{iy_{t+1}}$</li></ul></li><li><p><strong>最终</strong></p><script type="math/tex; mode=display">P(Y|\lambda)=\sum_{i=1}^N \alpha_T(i)</script><p>注：</p><ul><li>如果令前向概率中的t=T,即$\alpha_i(T)=P(y_1,y_2,…,y_T,q_T=i|\lambda)$，即最后一个时刻位于第i个状态时，观测到$y_1,y_2,…,y_T$的概率，即$P(Y,I|\lambda)$</li><li>因此，如果对$\alpha<em>T(i)$的<code>i</code>求和，即$\alpha_T(1)+\alpha_T(2)+…+\alpha_T(N)$，则是观测序列的概率$P(Y|\lambda)$，因此则可以求得观测序列的概率$P(Y|\lambda)=\sum</em>{i=1}^T\alpha_T(i)=\alpha_T(1)+\alpha_T(2)+…+\alpha_T(N)$</li></ul></li></ol><h5 id="后向算法"><a href="#后向算法" class="headerlink" title="后向算法"></a>后向算法</h5><p>【定义】</p><p>给定隐马尔科夫模型$\lambda$,当第t个时刻的状态为i时，后面的时刻分别观测到$y<em>{t+1},y</em>{t+2},…,y<em>T$的概率称为后向概率。 $\beta_t(i)=P(y</em>{t+1},y_{t+2},…,y_T|q_t=i,\lambda)$。</p><p>【输入输出】</p><ul><li>输入：隐马尔科夫模型$\lambda$，观测序列$Y$</li><li>输出：观测序列概率$p(Y|\lambda)$</li></ul><p>【步骤】</p><ol><li><p><strong>初值</strong></p><script type="math/tex; mode=display">\beta_T(i)=1</script><p>注：因为T时刻之后已经没有任何时刻，不需要观测任何序列，因此概率为1.</p></li><li><p><strong>递推</strong></p><script type="math/tex; mode=display">对于t=T-1,T-2,...,1\\\beta_t(i)=\sum_{j=1}^N(a_{ij} {b_{jy_{t+1}}} {\beta_{t+1}(j)})</script><p>注：根据t+1时刻的后向概率计算t时刻的后向概率$\beta_t(i)$。</p><p>$\beta<em>t(i)$=$\sum$(第t时刻位于第i个状态转移到第t+1时刻位于第j个状态的概率$a</em>{ij}$ <em> 第t+1个时刻第j个状态的发射概率$b<em>jy</em>{t+1}$ </em> 第t+1个时刻的后向概率)</p></li><li><p><strong>最终</strong></p><script type="math/tex; mode=display">P(Y|\lambda)=\sum_{i=1}^N{\pi_i}{b_iy_1}\beta_1(i)</script></li></ol><h5 id="前向后向概率的关系"><a href="#前向后向概率的关系" class="headerlink" title="前向后向概率的关系"></a>前向后向概率的关系</h5><p>拥有所有观测时，第t时刻第i个状态的概率=t时刻的前向概率*t时刻的后向概率,即</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/da4gbb89fL.png?imageslim" alt="mark"></p><h4 id="预测问题-解码问题"><a href="#预测问题-解码问题" class="headerlink" title="预测问题(解码问题)"></a>预测问题(解码问题)</h4><h5 id="Viterbi算法"><a href="#Viterbi算法" class="headerlink" title="Viterbi算法"></a>Viterbi算法</h5><p>【思想】</p><ol><li>先从前向后推出一步步路径的最大可能，最终会得到一个从起点连接每一个终点的m条路径（假设有m个终点）</li><li>确定终点之后反过来选择前面的路径</li><li>确定最优路径</li></ol><p>简言之：</p><p><strong>每个子部分只存储最优子路径，而不是暴力枚举所有路径来获得最优路径。</strong></p><ul><li>从开始状态之后每走一步，就记录下到达改状态的所有路径的概率的最大值。</li><li>然后以此最大值为基准继续向后推进。</li></ul><p>【输入输出】</p><p>输入：模型$\lambda=(A,B,\pi)$和观测$O=(o_1,o_2,…,o_T)$</p><p>输出：最优路径$I^<em>=(i_1^</em>,i_2^<em>,…,i_T^</em>)$</p><p>【定义】</p><ul><li><p>变量$\delta_t(i)$：在时刻t状态为i的所有路径中概率的最大值。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/dIC8iDA81b.png?imageslim" alt="mark"></p><p>由定义可得变量$\delta$的递推公式</p><script type="math/tex; mode=display">\delta_{t+1}(i)=\max_{i_1,i_2,...,i_t}P(i_{t+1}=i,i_t,...,i_1,o_{t+1},...,o_1|\lambda)\\=\max_{1\leq j \leq N}[\delta_t(j)a_{ji}]b_i(o_{t+1}), \qquad i=1,2,...,N;t=1,2,...,T-1</script></li></ul><ul><li><p>变量$\psi<em>t(i)$：在时刻t状态为i的所有单个路径$(i_1,i_2,…,i</em>{t-1},i)$中概率最大的路径的第t-1个结点。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/gc84BHlACd.png?imageslim" alt="mark"></p><p>​</p></li></ul><p>【步骤】</p><ol><li><p>初始化</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/GLm61bB03b.png?imageslim" alt="mark"></p></li><li><p>递推</p><p>对$t=2,3,…,T$</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/FE9bF1La6E.png?imageslim" alt="mark"></p></li><li><p>终止</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/KKjDga94ch.png?imageslim" alt="mark"></p></li><li><p>最优路径回溯</p><script type="math/tex; mode=display">对t=T-1,T-2,...,1\\i_t^*=\psi_{t+1}(i_{t+1}^*)</script></li></ol><p>求得最优路径$I^<em>=(i_1^</em>,i_2^<em>,…,i_T^</em>)$</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>标注偏好(Label Bias Problem)</li></ul><p>模型在为输入序列打标签的时候，会存在偏心问题，会倾向于选择某些标签，导致最终的序列并不是概率最大的序列。</p><p>【原因】</p><p>HMM的状态转移概率的计算方式对于每一步的状态转移都会进行归一化。</p><p>CRF对其改进，在全局进行归一化：</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="POS-Tagging"><a href="#POS-Tagging" class="headerlink" title="POS Tagging"></a>POS Tagging</h4><p>根据观察到的句子x，找到隐藏的词性序列$y$，即找到最大概率的词性序列$\hat{y}=argmaxP(x,y)$</p><p>通过穷举的方式找到最大序列并不现实，因此选用Viterbi算法。</p><h2 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li><code>条件</code>：指条件概率。</li></ul><ul><li><p><code>随机场</code>：</p><ul><li><p>随机场包含两个要素：位置和相空间。当给每一个位置中按照某种分布随机赋予相空间的一个值之后，其全体就叫做随机场。</p></li><li><p>由若干个位置组成的整体，当给每一个位置中按照某种分布随机赋予一个值之后，其全体就叫做随机场。</p><p>举词性标注的例子：假如有一个十个词形成的句子需要做词性标注。这十个词每个词的词性可以在已知的词性集合（名词，动词…)中去选择。当我们为每个词选择完词性后，这就形成了一个随机场。</p></li></ul></li><li><p><code>马尔科夫随机场</code>：<strong>马尔科夫随机场是随机场的特例，它假设随机场中某一个位置的赋值仅仅与和它相邻的位置的赋值有关，和与其不相邻的位置的赋值无关。</strong></p><p>举词性标注的例子：如果我们假设所有词的词性只和它相邻的词的词性有关时，这个随机场就特化成一个马尔科夫随机场。比如第三个词的词性除了与自己本身的位置有关外，只与第二个词和第四个词的词性有关。</p></li></ul><p>【三个问题】</p><ul><li>概率计算问题：前向-后向算法</li><li>学习问题：<ul><li>梯度下降法</li><li>拟牛顿法（BFGS算法）</li></ul></li><li>预测问题（解码问题）：Viterbi算法</li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180802/EhLc387L0m.png?imageslim" alt="mark"></p><p>【表示形式】</p><ul><li><p><strong>普通形式</strong></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/ljgl16F7Ja.png?imageslim" alt="mark"></p></li><li><p><strong>向量内积形式</strong></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/kJlFjHgId1.png?imageslim" alt="mark"></p></li></ul><p>其中，$Z(x)$是归一化因子。</p><h3 id="三个基本问题求解算法-1"><a href="#三个基本问题求解算法-1" class="headerlink" title="三个基本问题求解算法"></a>三个基本问题求解算法</h3><h4 id="计算概率问题：前向-后向算法"><a href="#计算概率问题：前向-后向算法" class="headerlink" title="计算概率问题：前向-后向算法"></a>计算概率问题：前向-后向算法</h4><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/A5mFm0DaFI.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/3m9Dg2m70A.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/h4c19DF97f.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/I9bD4mcid5.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180804/HAKF3cbKg7.png?imageslim" alt="mark"></p><h4 id="学习问题"><a href="#学习问题" class="headerlink" title="学习问题"></a>学习问题</h4><h4 id="预测问题（解码问题）：Viterbi算法"><a href="#预测问题（解码问题）：Viterbi算法" class="headerlink" title="预测问题（解码问题）：Viterbi算法"></a>预测问题（解码问题）：Viterbi算法</h4><p>预测问题就是从多个候选标注中挑选出来一种标注概率最高的。由于归一化因子不影响值的比较，所以只需要比较分子部分的『非规范化概率』。</p><p>【定义】</p><p>变量$\delta_i(l)$：到位置i的各个标记$l=1,2,…,m$的非规范化概率的最大值。</p><script type="math/tex; mode=display">\delta_i(l)=\max_{1 \leq j \leq m}\{\delta_{i-1}(j)+w \bullet F_i(y_{i-1}=j,y_i=l,x) \}, \qquad l=1,2,...,m</script><p>变量$\psi_i(l)$：非规范化概率最大值的路径</p><script type="math/tex; mode=display">\psi _i(l)=arg \max_{1 \leq j \leq m} \{ \delta_{i-1}+w \bullet F_i(y_{i-1}=j,y_i=l,x)\}, l=1,2,...,m</script><p>【输入输出】</p><p>输入：特征向量F(y,x)和权值向量w,观测序列$x=(x_1,x_2,…,x_n)$</p><p>输出：最优路径$y^<em>=(y_1^</em>,y_2^<em>,…,y_n^</em>)$</p><p>【步骤】</p><ol><li><p><strong>初始化</strong></p><script type="math/tex; mode=display">\delta_1(j)=w \bullet F_1(y_0=start,y_1=j,x), \qquad j=1,2,...,m</script><p>注：求出各位置1的各个标记j=1,2,…,m的非规范化概率</p></li><li><p><strong>递推</strong></p><script type="math/tex; mode=display">对i=2,3,...,n\\\delta_i(l)=\max_{1 \leq j \leq m}\{\delta_{i-1}(j)+w \bullet F_i(y_{i-1}=j,y_i=l,x) \}, \qquad l=1,2,...,m \\\psi _i(l)=arg \max_{1 \leq j \leq m} \{ \delta_{i-1}+w \bullet F_i(y_{i-1}=j,y_i=l,x)\}, l=1,2,...,m</script><p>注：</p><ul><li>$\delta_i(l)$：到位置i的各个标记$l=1,2,…,m$的非规范化概率的最大值</li><li>$\psi_i(l)$：非规范化概率最大值的路径</li></ul></li><li><p><strong>终止</strong></p><script type="math/tex; mode=display">\max_y(w \bullet F(y,x))=\max_{1\leq j \leq m}\delta_n(j) \\ y_n^*=arg \max_{i \leq j \leq m} \delta_n(j)</script><p>注：</p><ul><li>直到i=n时终止，求得非规范化概率的最大值为$\max<em>y(w \bullet F(y,x))=\max</em>{1\leq j \leq m}\delta_n(j) $</li><li>最优路径的终点：$y<em>n^*=arg \max</em>{i \leq j \leq m} \delta_n(j)$</li></ul></li><li><p><strong>返回路径</strong></p><script type="math/tex; mode=display">y_i^*=\psi_{i+1}(y_{i+1}^*), \qquad i=n-1,n-2,...,1 \\求得最优路径y^*=(y_1^*,y_2^*,...,y_n^*)</script></li></ol><p>其中</p><script type="math/tex; mode=display">w=(w1,w2,...,w_k)^T \\F(y,x)=(f_1(y,x),f_2(y,x),...,f_K(y,x))^T\\f_k(y,x)=\sum_{i=1}^n f_k(y_{i-1},y_i,x,i), \qquad k=1,2,...,K</script><h3 id="关系演变"><a href="#关系演变" class="headerlink" title="关系演变"></a>关系演变</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180731/gaD4FjE78m.png?imageslim" alt="mark"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>CRF是对序列建模，模型假设考虑了标签之间的依赖关系（转移特征），最终输出的条件概率是某条序列的条件概率。<ul><li>采用分类器的方法，建模时没有考虑标签之间的依赖关系，模型训练时的目标函数也是为了提高分类准确率。</li></ul></li><li>CRF着眼于局部最优解</li></ul><h2 id="线性链条件随机场"><a href="#线性链条件随机场" class="headerlink" title="线性链条件随机场"></a>线性链条件随机场</h2><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180731/L0fBmEHlDb.png?imageslim" alt="mark"></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><ol><li>对输入序列的每一个token，根据当前token和前一个token的特征计算状态函数得分和转移函数得分之和，这一步会产生多种可能的路径，每一步会得到一个矩阵</li><li>重复步骤1直到序列结束</li><li>利用维特比算法求得最优序列</li></ol><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>【特征函数】</p><p>特征函数接受四个参数：</p><ul><li>s：表示一个句子</li><li>i：表示句子s中的第i个单词</li><li>l_i：表示给第i个单词标注的词性</li><li>l_{i-1}：表示给第i-1个单词标注的词性</li></ul><p>输出值是0或1。</p><ul><li>0表示要评分的标注序列不符合这个特征。</li><li>1表示要评分的标注序列符合这个特征。</li></ul><p>【概率】</p><p>定义好一组特征函数后，给每个特征函数$f_j$赋予一个权重$\lambda_j$。</p><p>只要有一个句子$s$，一个标注序列$l$，则可以利用定义的特征函数集对$l$评分。</p><script type="math/tex; mode=display">score(l|s)=\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j(s,i,l_i,l_{i-1})</script><p>上式中有两个求和，外面的求和用来求每一个特征函数$f_j$评分值的和，里面的求和用来求句子中每个位置的单词的特征值的和。</p><p>对这个分数进行<strong>指数化</strong>和<strong>归一化</strong>，则可以得到标注序列$l$的概率值$p(l|s)$</p><p><img src="https://upload-images.jianshu.io/upload_images/1371984-2e1239ff7cbe21de.PNG?imageMogr2/auto-orient/" alt=""></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>HMM：生成式模型。CRF：判别式模型。</li><li>HMM：概率有向图。CRF：概率无向图。</li><li>HMM：局部最优。CRF：全局最优。</li><li>HMM：导致label bias问题。CRF：概率归一化合理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;结构化学习-Structured-Learning&quot;&gt;&lt;a href=&quot;#结构化学习-Structured-Learning&quot; class=&quot;headerlink&quot; title=&quot;结构化学习(Structured Learning)&quot;&gt;&lt;/a&gt;结构化学习(Structured Learning)&lt;/h3&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://tianwenyu.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://tianwenyu.github.io/tags/NLP/"/>
    
      <category term="序列标注" scheme="https://tianwenyu.github.io/tags/%E5%BA%8F%E5%88%97%E6%A0%87%E6%B3%A8/"/>
    
  </entry>
  
  <entry>
    <title>Match-LSTM和Pointer Net</title>
    <link href="https://tianwenyu.github.io/match-LSTM-Pointer-Network/"/>
    <id>https://tianwenyu.github.io/match-LSTM-Pointer-Network/</id>
    <published>2018-04-21T11:29:36.000Z</published>
    <updated>2018-08-05T17:02:43.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Match-LSTM"><a href="#Match-LSTM" class="headerlink" title="Match-LSTM"></a>Match-LSTM</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Match-LSTM是由(Wang &amp; Jiang,2016)发表在NAACL的论文提出，用于解决NLI(Natural Language Inference，文本蕴含)问题。</p><ul><li>premise：前提，代表上下文</li><li>hypothesis：假设，代表一个陈述性的结论<a id="more"></a>文本蕴含问题：给定一个premise（前提），根据这个premise去判断相应的hypothesis（假说）正确与否，如果从这个premise中能够推断出这个hypothesis，那么就判断为entailment（蕴含），否则就是contradiction（矛盾）。</li></ul><h3 id="Word-by-Word-Attention"><a href="#Word-by-Word-Attention" class="headerlink" title="Word-by-Word Attention"></a>Word-by-Word Attention</h3><p>Match-LSTM是在<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1509.06664v4.pdf" target="_blank" rel="external">Rocktaschel et al. (2015)</a>提出的word-by-word attention的基础上进行了改进，先解释一下<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1509.06664v4.pdf" target="_blank" rel="external">Rocktaschel et al. (2015)</a>提出的基本模型</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/fbfg5c47f3.png?imageslim" alt="mark"></p><ol><li><p>用LSTM处理premise和hypothesis，(用premise的最后一个输出初始化hypothesis的LSTM)，得到它们的隐层输出。</p><p>其中，</p><ul><li>$h_j^s(1 \le j \le M )$是premise的输入序列经过LSTM之后得到的隐层输出。</li><li>$h_{k}^{t}(1\leq k\leq N)$是hypothesis的隐层输出向量。</li></ul></li><li><p>word-by-word attention的意思是为每个hypothesis中的词引入一个 $a_k$ ,用于表示hypothesis，并称这个 $a_k$ 向量为attention向量，具体公式如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/I7idAFG3a9.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/fjDj5ghJBm.png?imageslim" alt="mark"></p><p>这里的attention权重$a_{kj}$表示hypothesis中第k个词和premise中第j个词之间的关系。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/kiIf0Aic5D.png?imageslim" alt="mark"></p><p>$h<em>j^s$ 是premise的隐层输出，$h_k^t$ 是hypothesis的隐层输出，$h</em>{k-1}^a$ 是将输入一个RNN之后得到的隐层状态。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/AajdC60agG.png?imageslim" alt="mark"></p></li><li><p>最后利用$h_N^a$和$h_N^t$来预测label：<code>y</code>，即判断premise和hypothesis之间的关系。</p></li></ol><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>以下为结构图：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/B4K8GaLLEH.png?imageslim" alt="mark"></p><ol><li><p>用两个LSTM处理premise和hypothesis序列。得到两个隐状态$h^s$和$h^t$(s对应前提，t对应假设)。</p></li><li><p>用下面的公式计算注意力向量$a_k$,这里计算得到的$e$经过归一化和加权求和得到假设$h^t$对前提$h^s$在每个时刻的注意力向量$a_k$，即attention过程。</p><p><img src="http://7xpqrs.com1.z0.glb.clouddn.com/FlgZlpVvlxyB5yFCsBr7QxGM8wSr" alt=""></p><p>上式中$h^m$的计算，用下面的公式计算，其中输入$m_k$是$[a_k,h_k^t]$的拼接，即把$m_k$输入到LSTM中。</p><p><img src="http://7xpqrs.com1.z0.glb.clouddn.com/Flel3Uqro1-XL15roShCUDOZkjdN" alt=""></p></li><li><p>把最后时刻的$h^m$即$h_N^m$作为输出以预测label。</p></li></ol><p>【简化版】</p><ol><li>将premise和hypothesis两句话输入到两个LSTM中，用对应LSTM的隐层输出premise和hypothesis中每个位置对应上下文信息的一种表示，分别对应图中的$H^s$和$h^t$</li><li>对于hypothesis中的某个词的表示$h^t_i$与premise中每个词的表示$H^s$计算得到一个权重向量，然后再对premise中的词进行加权求和，得到hypothesis的$h^t_i$在每个时刻对应的注意力向量$a_i$,即(attention过程)</li><li>把hypothesis中该词的表示$h^t_i$和其对应的attention的上下文向量$a_i$拼接在一起，输入到一个LSTM中，最后时刻的$h^m$即$h_N^m$作为输出以预测label。</li></ol><h3 id="与Word-to-Word-Attention区别"><a href="#与Word-to-Word-Attention区别" class="headerlink" title="与Word-to-Word Attention区别"></a>与Word-to-Word Attention区别</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/8LDBA8gm3j.png?imageslim" alt="mark"></p><p>两者的主要区别就是计算$e_{kj}$的不同。</p><ul><li><p>这里用$h^m$代替了$h^a$。</p><ul><li>之前的$h^m$是利用RNN得到的,$h^a$是用mLSTM得到的。</li></ul></li><li><p>为了得到premise跟hypothesis之间的matching关系，用LSTM对它们进行建模，作者认为LSTM能够将premise和hypothesis之间重要的match关系进行保留，忽略不重要的match关系。具体公式如下:</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/BfD0AiDH9d.png?imageslim" alt="mark"></p><p>​</p></li><li><p>最后利用$h_N^m$来预测。</p></li></ul><h2 id="Pointer-Net"><a href="#Pointer-Net" class="headerlink" title="Pointer Net"></a>Pointer Net</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Pointer Network是Vinyals et al.(2015)在NIPS发表的论文中提出的，是为了实现从输入序列中找到相应的tokens来作为输出，其他的阅读理解任务中，可能只需要用输入序列构建一个词典，再从这个候选词典中找到概率最大的一个词作为答案，然而SQuAD数据集的输出答案的长度是变化的，因而无法采用构建词典的方式，而pointer net是利用attention作为pointer，从输入序列中选择一个位置，并将这个位置所指向的词作为输出。对pointer net有兴趣的话，可以参看这个链接进行学习:<a href="https://link.zhihu.com/?target=https%3A//github.com/vshallc/PtrNets" target="_blank" rel="external">Pointer net</a>。AS-Reader、AoA-Reader和R-Net等模型都用了PtrNet作为输出层的结构。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Pointer是从一个输入序列中选点的一种方法，是Attention的变体。它不像Attention那样把输入信息编码成一个context vector,而是将attention转化为一个pointer，来选择输入序列中的元素。</p><h4 id="与Attention区别"><a href="#与Attention区别" class="headerlink" title="与Attention区别"></a>与Attention区别</h4><ul><li><p>Attention：公式如下，前两个公式是整合encoder和decoder的隐式状态，学出来encoder、decoder隐式状态与当前输出的权重关系a，然后根据权重关系a和隐式状态e得到context vector用来预测下一个输出。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180806/dhhK9mbj4J.png?imageslim" alt="mark"></p></li><li><p>Pointer Net：公式如下，Pointer没有最后一个公式，即将权重关系a和隐式状态整合为context vector，而是直接通过softmax，指向输入序列选择中最有可能是输出的元素。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180806/a9GCEbE9ID.png?imageslim" alt="mark"></p></li></ul><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/4gHACA8k69.png?imageslim" alt="mark"></p><p>论文中提出了两个模型，且都包含以下三个部分：</p><ul><li>用LSTM对question和passage进行预处理。</li><li>用match-LSTM对question和passage进行match。</li><li>利用Pointer Net从passage中选择tokens作为答案。</li></ul><p>两个模型的区别在于在于第三部分，由于pointer net没有限定所指向的位置必须是连续的，所以第一个模型sequence model直接将答案在passage中出现的位置序号作为答案序列$a=( a<em>{1} ,a</em>{2},… ) $，第二个模型只预测答案的起始位置跟终止位置，即$a=(a<em>{s} ,a</em>{e})$。</p><h4 id="LSTM-Preprocessing-Layer"><a href="#LSTM-Preprocessing-Layer" class="headerlink" title="LSTM Preprocessing Layer"></a>LSTM Preprocessing Layer</h4><p>用单向LSTM对passage和question进行预处理。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/H8F4LCdkkb.png?imageslim" alt="mark"></p><h4 id="Match-LSTM-Layer"><a href="#Match-LSTM-Layer" class="headerlink" title="Match-LSTM Layer"></a>Match-LSTM Layer</h4><p>这里将question当做premise，将passage当做hypothesis，用标准的word-by-word attention得到attention向量，具体公式如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/L3ge3E42aC.png?imageslim" alt="mark"></p><p>其中，</p><ul><li><p>$\vec{h}_{i-1}^r \in R^l$是经过单向m-LSTM得到的隐层输出。</p></li><li><p>$\vec{\alpha_{i,j}}$表示passage中的第i个词和question中的第j个词之间的匹配关系。然后用$\overline{\alpha}$对question的隐层输出进行加权，并将其跟passage的隐层输出进行拼接，得到一个新的向量，并输入到m-LSTM中，得到$\bar{H^r}$，具体公式如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/mGFcc1am4j.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/hG7IGEfjBg.png?imageslim" alt="mark"></p></li></ul><p>再从另一个方向进行相同的处理,将两者进行合并，得到最后的输出向量$H^{r} $</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/GlJBjKbJ2f.png?imageslim" alt="mark"></p><h4 id="Answer-Pointer-Layer"><a href="#Answer-Pointer-Layer" class="headerlink" title="Answer Pointer Layer"></a>Answer Pointer Layer</h4><h5 id="The-Sequence-Model"><a href="#The-Sequence-Model" class="headerlink" title="The Sequence Model"></a>The Sequence Model</h5><ul><li><p>由于这个模型是生成答案的位置序列$a=(a<em>{1} ,a</em>{2},…)$，每个元素表示的是这个词在passage中位置，其取值范围在1到P+1之间，当出现了P+1时，则答案生成终止。因此在$H^{r}$的最后中加入了一列0向量，用来表示终止词，得到$\bar{H} ^{r} $。</p></li><li><p>这里再次用到了attention方法去得到向量$\beta<em>k \in R^{(P+1)}$,$\beta</em>{k,j}$表示选择passage中的第j个词作为答案序列的第k个词的概率，$\beta_{k,(P+1)}$表示在第k个位置停止答案生成的概率。公式如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/Ei52lCjHej.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/jIkbfL3B7b.png?imageslim" alt="mark"></p><p>其中，$h_k^a$也是经过一个LSTM的输出。</p></li><li><p>模型生成答案的概率公式如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/3LcCBb438h.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/eb26ikFe4l.png?imageslim" alt="mark"></p></li><li><p>损失函数如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/mkC2al6bIK.png?imageslim" alt="mark"></p></li></ul><h5 id="The-Boundary-Model"><a href="#The-Boundary-Model" class="headerlink" title="The Boundary Model"></a>The Boundary Model</h5><p>因为boundary model只需要生成答案的起始和终止位置，因此不用在$H^{r}$最后加入一个零向量来表示答案生成结束。生成答案序列的概率模型如下：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180726/g81CbgI0LE.png?imageslim" alt="mark"></p><p>其余部分与上个模型相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Match-LSTM&quot;&gt;&lt;a href=&quot;#Match-LSTM&quot; class=&quot;headerlink&quot; title=&quot;Match-LSTM&quot;&gt;&lt;/a&gt;Match-LSTM&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Match-LSTM是由(Wang &amp;amp; Jiang,2016)发表在NAACL的论文提出，用于解决NLI(Natural Language Inference，文本蕴含)问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;premise：前提，代表上下文&lt;/li&gt;
&lt;li&gt;hypothesis：假设，代表一个陈述性的结论
    
    </summary>
    
      <category term="NLP" scheme="https://tianwenyu.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://tianwenyu.github.io/tags/NLP/"/>
    
      <category term="阅读理解" scheme="https://tianwenyu.github.io/tags/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>任务型多轮对话系统概述</title>
    <link href="https://tianwenyu.github.io/task-oriented-dialog-system/"/>
    <id>https://tianwenyu.github.io/task-oriented-dialog-system/</id>
    <published>2018-04-20T11:29:36.000Z</published>
    <updated>2018-07-26T09:36:24.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><p>任务型机器人核心模块主要包括三个模块：</p><ul><li>自然语言理解模块（NLU）</li><li>对话管理模块</li><li>自然语言生成模块（NLG）<a id="more"></a></li></ul><p><img src="https://pic1.zhimg.com/80/v2-b70539cc9a32d7f2711a086f0fbbda4f_hd.jpg" alt="img"></p><h3 id="自然语言理解模块"><a href="#自然语言理解模块" class="headerlink" title="自然语言理解模块"></a>自然语言理解模块</h3><p>该模块一般包含以下三个模块：</p><ul><li>领域识别：即识别该语句是不是属于这个任务场景，一般有多个机器人集成时，如闲聊机器人，问答机器人等，领域识别应当在进入任务型机器人之前做判断与分发</li><li>意图识别：即识别用户意图，细分该任务型场景下的子场景、</li><li>语义槽填充：用于对话管理模块的输入</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设Text=“人民币对美元的汇率是多少”；经过自然语言理解模块会解析为 act ( slot1 = value1, slot2 = value2 ……) 的形式，即意图，槽位，槽位信息三元组形式，即 Text会解析为“查询（槽位1=人民币，槽位2=美元)”这样的形式。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="基于规则理解方法"><a href="#基于规则理解方法" class="headerlink" title="基于规则理解方法"></a>基于规则理解方法</h5><p>【优点】</p><ul><li>不需要大量训练数据</li></ul><p>【缺点】</p><ul><li>容易出错</li><li>调整规则费时费力，难以维护</li></ul><h5 id="统计方法（对齐）"><a href="#统计方法（对齐）" class="headerlink" title="统计方法（对齐）"></a>统计方法（对齐）</h5><p>基于词对齐数据的自然语言理解通常被看做一个序列标注问题。主要有以下两类方法：</p><ul><li>基于生成式模型<ul><li>随机有限状态机（FST）</li><li>统计机器翻译（SMT）</li><li>动态贝叶斯网络（DBN）</li></ul></li><li>基于判别式模型<ul><li>CRF</li><li>SVM</li><li>MEMM</li></ul></li></ul><h5 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h5><ul><li>BiLSTM+CRF</li><li>CNN：用于序列标注</li><li>Seq2Seq</li></ul><h3 id="对话管理模块"><a href="#对话管理模块" class="headerlink" title="对话管理模块"></a>对话管理模块</h3><p>自然语言理解模块的三元组输出将作为对话管理系统的输入。它主要包括两部分：</p><ul><li>状态追踪模块</li><li>对话策略模块</li></ul><p>【状态追踪模块】</p><p>该模块在对话的每一轮次对用户的目标进行预估，管理每个回合的输入和对话历史，输出当前对话状态。</p><p><img src="https://pic1.zhimg.com/80/v2-b08e6cd63a89448e47f4576ae3603067_hd.jpg" alt="img"></p><p>【对话策略模块】</p><p>该模块的主要功能是根据前面的对话状态决策采取的最优动作（如：提供结果，询问特定限制条件，澄清或确认需求等）从而最有效的辅助用户完成信息或服务获取的任务。该模块基于用户输入的语义表达和当前对话状态输出下一步的系统行为和更新的对话状态。</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>text=“人民币对美元的汇率是多少”。“查询（槽位1=人民币，槽位2=美元)”这样的形式将作为对话管理模块的输入，这时候状态追踪模块就要根据前几轮的信息，结合该输入判断该轮的查询状态，确定查询的槽位，以及与数据库的交互。如得到想要查询的确实是人民币对美元的汇率信息。这时候，根据现有的对话策略判断当前的槽位状态，最后给出对话管理模块的输出，如查询结果(源货币=人民币，目标货币=美元，汇率=1:0.16)</p><h3 id="自然语言生成模块"><a href="#自然语言生成模块" class="headerlink" title="自然语言生成模块"></a>自然语言生成模块</h3><p>该模块主要任务是将对话策略输出的语义表达生成流畅可读的自然语言句子，反馈给用户。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要模块&quot;&gt;&lt;a href=&quot;#主要模块&quot; class=&quot;headerlink&quot; title=&quot;主要模块&quot;&gt;&lt;/a&gt;主要模块&lt;/h2&gt;&lt;p&gt;任务型机器人核心模块主要包括三个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然语言理解模块（NLU）&lt;/li&gt;
&lt;li&gt;对话管理模块&lt;/li&gt;
&lt;li&gt;自然语言生成模块（NLG）
    
    </summary>
    
      <category term="NLP" scheme="https://tianwenyu.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://tianwenyu.github.io/tags/NLP/"/>
    
      <category term="多轮对话" scheme="https://tianwenyu.github.io/tags/%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装python3</title>
    <link href="https://tianwenyu.github.io/centos-install-python/"/>
    <id>https://tianwenyu.github.io/centos-install-python/</id>
    <published>2018-04-01T11:29:36.000Z</published>
    <updated>2018-04-14T13:27:22.576Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>下载安装包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -xvJf Python-3.6.2.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>进入到解压后的<code>Python-3.6.2</code>文件夹</p></li><li><p>编译安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./configure --prefix=xxxx</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>【注】<code>prefix</code>后是<code>Python-3.6.2</code>的解压路径的父目录</p></li><li><p>添加软连接到执行目录<code>/usr/bin</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s xxx/bin/python3 /usr/bin/python3</span><br><span class="line">ln -s xxx/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>【注】<code>xxx</code>代表python的安装路径，即步骤四的<code>prefix</code>后的路径</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载安装包&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo wget https://www.python.org/ft
      
    
    </summary>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://tianwenyu.github.io/tags/CentOS/"/>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>无Root权限中Ubuntu安装Python</title>
    <link href="https://tianwenyu.github.io/no-root-install-python/"/>
    <id>https://tianwenyu.github.io/no-root-install-python/</id>
    <published>2018-03-18T11:29:36.000Z</published>
    <updated>2018-07-26T09:37:57.697Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>下载Python</p><p><code>wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz</code></p></li><li><p>解压</p><p><code>tar -xvf Python-3.6.3.tar.zx</code></p></li><li><p>进入到解压后的文件夹</p><p><code>cd Python-3.6.3</code></p></li><li><p><code>./configure --prefix=&#39;Your Install Director&#39;</code></p></li><li><p><code>make &amp;&amp; make install</code></p></li><li><p>添加路径,编辑<code>~/.bashrc</code></p><p><code>vim ~/.bashrc</code></p></li><li><p>在文件最后添加</p><p><code>export PATH=/Your Install Path:$PATH</code>，如<code>export PATH=/usr/local/bin/:$PATH</code></p></li><li><p>创建别名，编辑<code>~/.bashrc</code></p><p><code>vim ~/.bashrc</code></p></li><li><p>在文件最后添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> python=<span class="string">'Your python path'</span></span><br><span class="line"><span class="built_in">alias</span> pip=<span class="string">'Your pip path'</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载Python&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;&lt;code&gt;t
      
    
    </summary>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://tianwenyu.github.io/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://tianwenyu.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>安装Docker CE for Windows后VirtualBox无法启动问题解决</title>
    <link href="https://tianwenyu.github.io/docker-virtualbox-problem/"/>
    <id>https://tianwenyu.github.io/docker-virtualbox-problem/</id>
    <published>2018-03-10T11:29:36.000Z</published>
    <updated>2018-03-12T08:08:48.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在Windows上运行Docker需要借助虚拟机来运行一个简化的Linux系统，Docker CE for Windows使用的是Windows系统自带的<code>Hyper-V</code>（从Win8开始）虚拟机组件。</p><p>因此在安装Docker CE for Windows时，会打开<code>Hyper-V</code>组件（默认是关闭的），会和Virtual Box冲突。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="关闭Hyper-V组件"><a href="#关闭Hyper-V组件" class="headerlink" title="关闭Hyper-V组件"></a>关闭<code>Hyper-V</code>组件</h3><p><code>控制面板-程序和功能-启用或关闭Windows功能</code>，去掉<code>Hpyer-V</code>功能。重启。</p><p><img src="http://img.blog.csdn.net/20171127124402922" alt="img"></p><p>打开Virtualbox依然报错</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180312/EkIhhCAAbd.png?imageslim" alt="mark"></p><p>这是因为<code>vboxdrv</code>服务没有安装或成功启动，在Virtualbox安装目录下的<code>drivers\vobxdrv</code>文件夹下，右击<code>VBoxDrv.inf</code>，选择安装，然后重启。</p><p>如果还是失败，则直接重新安装即可。</p><h2 id="安装老版Docker-Toolbox"><a href="#安装老版Docker-Toolbox" class="headerlink" title="安装老版Docker Toolbox"></a>安装老版Docker Toolbox</h2><p>老版Docker Toolbox使用的时Virtualbox虚拟机。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;在Windows上运行Docker需要借助虚拟机来运行一个简化的Linux系统，Docker CE for Windows使用的是Windo
      
    
    </summary>
    
      <category term="运维技术" scheme="https://tianwenyu.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="Docker" scheme="https://tianwenyu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下Docker简明教程</title>
    <link href="https://tianwenyu.github.io/windows-docker/"/>
    <id>https://tianwenyu.github.io/windows-docker/</id>
    <published>2018-03-01T11:29:36.000Z</published>
    <updated>2018-03-12T07:23:26.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、<a href="http://www.whatis.com.cn/word_5275.htm" target="_blank" rel="external">bare metal</a>、OpenStack 集群和其他的基础应用平台。 </p><p>Docker通常用于如下场景：</p><ul><li>web应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li></ul><a id="more"></a><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/Cg78lC6082.png?imageslim" alt="mark"></p><p>Docker使用C/S架构模式，Docker客户端会与Docker守护进程通信。Docker守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。</p><p>Docker分为三种部件：</p><ul><li>Docker镜像-Docker Images</li><li>Docker容器-Docker Containers</li><li>Docker仓库-Docker Registeries</li></ul><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker运行容器前需要本地存在对应的镜像。Docker镜像可以用来创建Docker容器，一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序。</p><p>Docker镜像是只可读的，一个镜像可以创建多个容器。</p><p>通俗说，Images是已经打包好的环境文件，我们运行的时候把Images加载运行在本地容器中，你在这个容器中可以进行一些修改重新打包成新镜像上传。</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>因为镜像包含操作系统完整的root文件系统，其体积往往是巨大的，因此Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。</p><p>分层存储的特征使得镜像并非像一个ISO类似的打包文件，而是由一组文件系统组成。</p><h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><p>Docker利用容器来开发、运行应用。容器是镜像创建的实例，可以被开始、启动、停止、删除。每个容器都是相互隔离的。</p><h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>仓库是集中存放镜像文件的场所。每个仓库中包含了多个镜像，每个镜像有不同的标签。</p><p>最大的公开仓库是<a href="[https://**hub**.**docker**.com/](http://www.baidu.com/link?url=XXjI7ksUwIGyOeeGLj18zm9wnXFolGgd4ZTPbEZ65zamM5dwMUF9m7lS930XC8z4">DockerHub</a>)，因为墙的原因，可以使用<a href="http://get.daocloud.io/" target="_blank" rel="external">DaoCloud</a>、<a href="[https://j0andt2p.mirror.aliyuncs.com](https://j0andt2p.mirror.aliyuncs.com/">阿里云</a>)加速下载。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>Win10版本Docker安装以下版本<a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="external">Docker Community Edition 17.12.0-ce</a></li><li>Win10之前版本安装<a href="https://download.docker.com/win/stable/DockerToolbox.exe" target="_blank" rel="external">Docker ToolBox</a>，<a href="https://docs.docker.com/toolbox/overview/#whats-in-the-box" target="_blank" rel="external">官方文档</a></li></ul><ol><li><p>安装之前，需要开启Windows10的<code>Hpyer-V</code>。</p><p><code>控制面板-程序-启用或关闭Windows功能</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/G8GkJmK19j.png?imageslim" alt="mark"></p></li></ol><ol><li><p>本文以<code>Docker Community Edition</code>为例，开启<code>Hpyer-V</code>后直接安装<code>Docker Community Edition</code>即可。</p><p>安装成功后，运行<code>cmd</code>,执行<code>docker version</code>，安装成功则显示下图</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/kGIA8d4j2f.png?imageslim" alt="mark"></p></li></ol><h2 id="设置Docker"><a href="#设置Docker" class="headerlink" title="设置Docker"></a>设置Docker</h2><p><code>任务栏鲸鱼图标右键-Settings</code>打开设置界面</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180306/m2dbjkDeKm.png?imageslim" alt="mark"></p><ul><li><code>Shared Drivers</code>：可以将主机（即Windows）中的驱动器共享到Docker Container中</li><li><code>Advanced</code>：用于配置运行Docker Daemon的虚拟机环境的CPU和内存和镜像路径</li><li><code>Network</code>：配置Docker的网络环境</li><li><code>Proxies</code>：代理的配置</li><li><code>Docker Daemon</code>：使用JSON格式的设置，对Docker Daemon进行设置，类似于在Linux中利用conf文件对Docker设置。</li></ul><h3 id="修改CPU数目及内存"><a href="#修改CPU数目及内存" class="headerlink" title="修改CPU数目及内存"></a>修改CPU数目及内存</h3><p>点击<code>Advanced</code>，如下图修改参数即可</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/7LH2Hkgika.png?imageslim" alt="mark"></p><h3 id="修改代理"><a href="#修改代理" class="headerlink" title="修改代理"></a>修改代理</h3><p><code>Docker Hub</code>速度较慢，修改为阿里云镜像。</p><p>登陆<a href="https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F%3Fspm%3Da2c4e.11153959.blogcont29941.9.520269d6tguzRb" target="_blank" rel="external">容器Hub服务</a>，找到以下链接</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/0kJ3JeB7fI.png?imageslim" alt="mark"></p><p>点击<code>Daemon</code>设置镜像，直接在<code>Registry mirrors</code>中填写阿里云的镜像地址，点击<code>Apply</code>重启应用即可。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/BH74glgG0L.png?imageslim" alt="mark"></p><h3 id="更改镜像默认存储路径"><a href="#更改镜像默认存储路径" class="headerlink" title="更改镜像默认存储路径"></a>更改镜像默认存储路径</h3><p>打开Docker的<code>Settings</code>，点击<code>Advanced</code>，在<code>Images and volumes VHD location</code>选择新的路径。重启后即可更新设置。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180306/32EJFIc6bB.png?imageslim" alt="mark"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看Docker版本"><a href="#查看Docker版本" class="headerlink" title="查看Docker版本"></a>查看Docker版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="查看本机已安装镜像"><a href="#查看本机已安装镜像" class="headerlink" title="查看本机已安装镜像"></a>查看本机已安装镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull Name:Tag</span><br></pre></td></tr></table></figure><p>【例】</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull sameersbn/redmine:latest</span><br></pre></td></tr></table></figure><h3 id="删除单个容器"><a href="#删除单个容器" class="headerlink" title="删除单个容器"></a>删除单个容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm Name/ID</span><br></pre></td></tr></table></figure><h3 id="删除所有的容器"><a href="#删除所有的容器" class="headerlink" title="删除所有的容器"></a>删除所有的容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm docker ps -a -q</span><br></pre></td></tr></table></figure><h3 id="停止、启动、杀死一个容器"><a href="#停止、启动、杀死一个容器" class="headerlink" title="停止、启动、杀死一个容器"></a>停止、启动、杀死一个容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop Name/ID</span><br><span class="line">docker start Name/ID</span><br><span class="line">docker <span class="built_in">kill</span> Name/ID</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.csdn.net/xiaoping0915/article/details/75094857" target="_blank" rel="external">【Docker】windows10 docker 使用</a></li><li><a href="http://blog.csdn.net/sb19931201/article/details/53838339" target="_blank" rel="external">Docker on Windows初体验</a></li><li><a href="https://www.cnblogs.com/daxnet/p/5788972.html" target="_blank" rel="external">Docker for Windows使用简介</a></li><li><a href="https://yq.aliyun.com/articles/62375" target="_blank" rel="external">Docker的Windows容器初体验</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、&lt;a href=&quot;http://www.whatis.com.cn/word_5275.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bare metal&lt;/a&gt;、OpenStack 集群和其他的基础应用平台。 &lt;/p&gt;
&lt;p&gt;Docker通常用于如下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web应用的自动化打包和发布；&lt;/li&gt;
&lt;li&gt;自动化测试和持续集成、发布；&lt;/li&gt;
&lt;li&gt;在服务型环境中部署和调整数据库或其他的后台应用；&lt;/li&gt;
&lt;li&gt;从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="运维技术" scheme="https://tianwenyu.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="Docker" scheme="https://tianwenyu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下Docker搭建深度学习框架</title>
    <link href="https://tianwenyu.github.io/docker-deeplearning/"/>
    <id>https://tianwenyu.github.io/docker-deeplearning/</id>
    <published>2018-03-01T11:29:36.000Z</published>
    <updated>2018-03-07T12:12:28.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="Deepo"><a href="#Deepo" class="headerlink" title="Deepo"></a>Deepo</h2><p><code>Deepo</code>是一个几乎包含所有流行深度学习框架的Docker映像，拥有一个完整的可复制的深度学习研究环境。它涵盖了</p><ul><li>theano</li><li>tensorflow</li><li>sonnet</li><li>pytorch</li><li>keras</li><li>lasagne</li><li>mxnet</li><li>cntk</li><li>chainer</li><li>caffe</li><li>torch</li></ul><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接从<code>Docker Hub</code>下载<code>Deepo</code>镜像。<a href="https://github.com/ufoym/deepo" target="_blank" rel="external">Github地址</a></p><ul><li>CPU版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ufoym/deepo:cpu</span><br></pre></td></tr></table></figure><ul><li>GPU版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ufoym/deepo</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>打开<code>powershell</code>执行以下命令，以bash方式运行该容器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ufoym/deepo:cpu bash</span><br></pre></td></tr></table></figure><h2 id="DL-docker"><a href="#DL-docker" class="headerlink" title="DL-docker"></a>DL-docker</h2><p>包含的框架及系统依赖</p><ul><li>Ubuntu 14.04</li><li>CUDA 7.5 (GPU version only)</li><li>cuDNN v4 (GPU version only)</li><li>Tensorflow</li><li>Caffe</li><li>Theano</li><li>Keras</li><li>Lasagne</li><li>Torch (includes nn, cutorch, cunn and cuDNN bindings)</li><li>iPython/Jupyter Notebook (including iTorch kernel)</li><li>Numpy, SciPy, Pandas, Scikit Learn, Matplotlib</li><li>A few common libraries used for deep learning</li></ul><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul><li>cpu版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull floydhub/dl-docker:cpu</span><br></pre></td></tr></table></figure><h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8888:8888 -p 6006:6006 -v /sharedfolder:/root/sharedfolder floydhub/dl-docker:cpu bash</span><br></pre></td></tr></table></figure><p>运行以上命令后，会连接到bash，执行<code>jupyter notebook</code>。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/E9gbbiD8dH.png?imageslim" alt="mark"></p><p>然后在Windows的浏览器中输入<code>localhost:8888</code>，会连接到该容器的<code>Jupyter notebook</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/0LLJg73D1G.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h2 id=&quot;Deepo&quot;&gt;&lt;a href=&quot;#Deepo&quot; class=&quot;headerlink&quot; title=&quot;Deepo&quot;&gt;&lt;/a&gt;Deepo&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Deepo&lt;/code&gt;是一个几乎包含所有流行深度学习框架的Docker映像，拥有一个完整的可复制的深度学习研究环境。它涵盖了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;theano&lt;/li&gt;
&lt;li&gt;tensorflow&lt;/li&gt;
&lt;li&gt;sonnet&lt;/li&gt;
&lt;li&gt;pytorch&lt;/li&gt;
&lt;li&gt;keras&lt;/li&gt;
&lt;li&gt;lasagne&lt;/li&gt;
&lt;li&gt;mxnet&lt;/li&gt;
&lt;li&gt;cntk&lt;/li&gt;
&lt;li&gt;chainer&lt;/li&gt;
&lt;li&gt;caffe&lt;/li&gt;
&lt;li&gt;torch&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://tianwenyu.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="Docker" scheme="https://tianwenyu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常见问题解决方法</title>
    <link href="https://tianwenyu.github.io/hexo-solve/"/>
    <id>https://tianwenyu.github.io/hexo-solve/</id>
    <published>2018-02-27T11:29:36.000Z</published>
    <updated>2018-02-27T07:52:36.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fatal-HttpRequestException-encountered"><a href="#fatal-HttpRequestException-encountered" class="headerlink" title="fatal: HttpRequestException encountered."></a>fatal: HttpRequestException encountered.</h2><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180227/B88KJ5L618.png?imageslim" alt="mark"></p><p>将<code>_config.yml</code>中的<code>repository: https://github.com:username/username.github.io.git</code></p><p>改成<code>repository: git@github.com:username/username.github.io.git</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fatal-HttpRequestException-encountered&quot;&gt;&lt;a href=&quot;#fatal-HttpRequestException-encountered&quot; class=&quot;headerlink&quot; title=&quot;fatal: HttpReque
      
    
    </summary>
    
      <category term="个人建站" scheme="https://tianwenyu.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="Hexo" scheme="https://tianwenyu.github.io/tags/Hexo/"/>
    
      <category term="GitPage" scheme="https://tianwenyu.github.io/tags/GitPage/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装Anaconda</title>
    <link href="https://tianwenyu.github.io/ubuntu-ancaconda/"/>
    <id>https://tianwenyu.github.io/ubuntu-ancaconda/</id>
    <published>2018-02-09T12:29:30.000Z</published>
    <updated>2018-02-27T07:29:31.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>使用<code>Python3.6</code>版本的<code>Anaconda 5.1</code>，<a href="https://repo.continuum.io/archive/Anaconda3-5.1.0-Linux-x86_64.sh" target="_blank" rel="external">点击下载</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>进入到下载后的文件目录，执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-5.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>根据提示输入回车</p><p><img src="http://img.blog.csdn.net/20170628223151678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p></li><li><p>查看注册信息，一直回车到输入<code>yes</code></p><p><img src="http://img.blog.csdn.net/20170628223509298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="http://img.blog.csdn.net/20170628223600909?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p></li><li><p>输入安装目录路径，默认回车即可</p><p><img src="http://img.blog.csdn.net/20170628223649697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p></li><li><p>是否加入环境变量，输入<code>yes</code></p><p><img src="http://img.blog.csdn.net/20170628223754787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p></li><li><p>安装成功后，新打开一个终端输入以下命令查看版本号</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anaconda -V</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用Jupyter-Notebook"><a href="#使用Jupyter-Notebook" class="headerlink" title="使用Jupyter Notebook"></a>使用Jupyter Notebook</h2><p>输入以下命令则能够使用<code>Jupyter Notebook</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipython notebook</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Anaconda安装&quot;&gt;&lt;a href=&quot;#Anaconda安装&quot; class=&quot;headerlink&quot; title=&quot;Anaconda安装&quot;&gt;&lt;/a&gt;Anaconda安装&lt;/h2&gt;&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;Python3.6&lt;/code&gt;版本的&lt;code&gt;Anaconda 5.1&lt;/code&gt;，&lt;a href=&quot;https://repo.continuum.io/archive/Anaconda3-5.1.0-Linux-x86_64.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入到下载后的文件目录，执行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash Anaconda3-5.1.0-Linux-x86_64.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://tianwenyu.github.io/tags/Ubuntu/"/>
    
      <category term="Anaconda" scheme="https://tianwenyu.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装Jupyter Notebook</title>
    <link href="https://tianwenyu.github.io/windows-jupyter-notebook/"/>
    <id>https://tianwenyu.github.io/windows-jupyter-notebook/</id>
    <published>2018-02-09T12:29:30.000Z</published>
    <updated>2018-02-27T07:36:03.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="文学编程"><a href="#文学编程" class="headerlink" title="文学编程"></a>文学编程</h3><p>文学编程(Literate Programming)是由Donald Knuth提出的编程方法。传统的结构化编程，人要按照计算机的逻辑顺序来编写代码，而文学编程则可以让人们按照自己的逻辑来开发程序。</p><h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><p><code>Jupyter Notebook</code>是一个交互式笔记本，支持运行40多种编程语言。它的本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和markdown。</p><p><code>Jupyter Notebook</code>优点：</p><ul><li>适合数据分析</li><li>支持多语言</li><li>分享便捷</li><li>远程运行</li><li>交互式展示<a id="more"></a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装Anaconda即自带，不需要安装</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>点击<code>Jupyter Notebook</code>即可启动，或在cmd中输入<code>jupyter notebook</code></p><p>默认地址为<code>http:localhost:8888</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/I4lBa3iCj3.png?imageslim" alt="mark"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="更改Jupyter-Notebook工作空间"><a href="#更改Jupyter-Notebook工作空间" class="headerlink" title="更改Jupyter Notebook工作空间"></a>更改Jupyter Notebook工作空间</h3><p>最新版<code>Ipython</code>和<code>Jupyter</code>配置文件是分开的，需要分别配置文件。</p><ol><li><p>打开cmd输入命令<code>jupyter notebook --generate-config</code></p><p>【注】<code>-config</code>之前没有空格</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/8DC86687KH.png?imageslim" alt="mark"></p></li><li><p>打开该目录下的文件，改文件夹路径</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/lea2G5JDa7.png?imageslim" alt="mark"></p><p>【注】若存在编码问题，可改成<code>f://file//jupyter_notebook</code></p></li><li><p>启动<code>Jupyter Notebook</code></p></li></ol><h3 id="新建Notebook"><a href="#新建Notebook" class="headerlink" title="新建Notebook"></a>新建Notebook</h3><p>点击<code>new</code>创建新的<code>Notebook</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/CKGCg8a3h8.png?imageslim" alt="mark"></p><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/K3eK1Lc3FH.png?imageslim" alt="mark"></p><p>菜单栏各项功能概述</p><ul><li><code>File</code><ul><li><code>Save and Checkpoint</code> 保存并记录点，类似于不同版本</li><li><code>Revert to Checkpoint</code>返回到某一记录点</li></ul></li><li><code>View</code><ul><li><code>Toggle Header</code>是否显示头部信息，包括文件名和上次保存时间</li><li><code>Toggle ToolBar</code>是否显示工具栏</li></ul></li><li><code>Kernel</code><ul><li><code>Change kernel</code>更换内核环境</li></ul></li></ul><p>Notebook文档由一系列<code>单元(cell)</code>,主要有两种形式的单元：</p><ul><li>代码状态单元：编写代码的区域，使用<code>Shift+Enter</code>运行代码，结果显示在本单元下方。代码单元左边有<code>In[1]：</code>类似的序列标记，方便人们查看代码的执行次序。</li><li>Markdown状态单元：编写文本的区域，使用<code>Shift+Enter</code>显示格式化的文本。</li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>编辑模式：编辑文本和代码。选中单元按<code>Enter</code>进入编辑模式，单元左侧显示绿色竖线</li><li>命令模式：执行输入的命令。按<code>Esc</code>进入命令模式，单元左侧显示蓝色竖线</li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ul><li>查看快捷键：<code>H</code></li></ul><ul><li>执行当前单元，并自动跳到下一个单元：<code>Shift+Enter</code></li><li>执行当前单元，不自动跳到下一个单元：<code>Ctrl+Enter</code></li><li>进入编辑模式：<code>Enter</code></li><li>进入命令模式：<code>Esc</code></li><li>删除当前单元：<code>双击D</code></li><li>变为代码状态：<code>Y</code></li><li>变为Markdown状态：<code>M</code></li><li>在下方插入新单元：<code>B</code></li><li>剪切选中单元：<code>X</code></li><li>复制选中单元：<code>C</code></li><li>粘贴到下方单元：<code>V</code></li><li>选中上方单元：<code>J</code></li><li>选中下方单元：<code>K</code></li><li>恢复删除的最后一个单元：<code>Z</code></li><li>保存当前Notebook：<code>Ctrl+S</code></li></ul><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><ul><li>代码缩进或补全：<code>Tab</code></li><li>代码提示：<code>Shift+Tab</code></li><li>注释：<code>Ctrl+/</code></li></ul><h3 id="Magic命令"><a href="#Magic命令" class="headerlink" title="Magic命令"></a>Magic命令</h3><p><code>Magic命令</code>以<code>%</code>或<code>%%</code>开头</p><ul><li><code>%</code>：行命令</li><li><code>%%</code>：单元命令。必须出现在单元第一行。</li></ul><p>以下为常用<code>Magic命令</code></p><ul><li><code>%lsmagic</code>：列举所有Magic命令</li><li><code>%magic</code>：查看Magic命令说明</li><li><code>%timeit</code>：代码运行时间</li><li><code>%matplotlib inline</code>：显示matplotlib包生成的图形</li></ul><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="运行Python文件"><a href="#运行Python文件" class="headerlink" title="运行Python文件"></a>运行Python文件</h3><p>运行以下命令</p><p><code>%run xxx.py</code></p><p>【注】<code>xxx.py</code>是当前工作空间下的一个python文件</p><h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><p>运行以下命令</p><p><code>%load xxx.py</code></p><p>【注】<code>xxx.py</code>是当前工作空间下的一个python文件 </p><h3 id="重置单元格序号"><a href="#重置单元格序号" class="headerlink" title="重置单元格序号"></a>重置单元格序号</h3><p>重置单元格<code>In[x]</code>序号</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180215/Ah0H7D7G9m.png?imageslim" alt="mark"></p><p>点击<code>Kernel-Restart</code>即可。</p><h3 id="使用Seaborn绘图"><a href="#使用Seaborn绘图" class="headerlink" title="使用Seaborn绘图"></a>使用<code>Seaborn</code>绘图</h3><p>需要使用<code>%matplotlib inline</code>命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;文学编程&quot;&gt;&lt;a href=&quot;#文学编程&quot; class=&quot;headerlink&quot; title=&quot;文学编程&quot;&gt;&lt;/a&gt;文学编程&lt;/h3&gt;&lt;p&gt;文学编程(Literate Programming)是由Donald Knuth提出的编程方法。传统的结构化编程，人要按照计算机的逻辑顺序来编写代码，而文学编程则可以让人们按照自己的逻辑来开发程序。&lt;/p&gt;
&lt;h3 id=&quot;Jupyter-Notebook&quot;&gt;&lt;a href=&quot;#Jupyter-Notebook&quot; class=&quot;headerlink&quot; title=&quot;Jupyter Notebook&quot;&gt;&lt;/a&gt;Jupyter Notebook&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Jupyter Notebook&lt;/code&gt;是一个交互式笔记本，支持运行40多种编程语言。它的本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和markdown。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Jupyter Notebook&lt;/code&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合数据分析&lt;/li&gt;
&lt;li&gt;支持多语言&lt;/li&gt;
&lt;li&gt;分享便捷&lt;/li&gt;
&lt;li&gt;远程运行&lt;/li&gt;
&lt;li&gt;交互式展示
    
    </summary>
    
      <category term="机器学习" scheme="https://tianwenyu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Notebook" scheme="https://tianwenyu.github.io/tags/Notebook/"/>
    
  </entry>
  
  <entry>
    <title>武大植物分布</title>
    <link href="https://tianwenyu.github.io/whu-plants/"/>
    <id>https://tianwenyu.github.io/whu-plants/</id>
    <published>2018-02-08T12:29:30.000Z</published>
    <updated>2018-02-27T07:51:22.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文理学部李达塑像"><a href="#文理学部李达塑像" class="headerlink" title="文理学部李达塑像"></a>文理学部李达塑像</h2><ul><li>樟树</li><li>蝴蝶花：4月，鸢尾科</li><li>鸢尾</li><li>吉祥草：百合科，秋花</li><li>南天竹：小檗科</li><li>锦绣杜鹃：杜鹃科</li><li>麦冬：百合科，6月开花</li><li>池衫</li><li>羊蹄：蓼科，酸模属</li><li>车前</li><li>蛇莓：蔷薇科，果不能吃</li><li>扬子毛茛</li><li>何首乌：蓼科</li><li>鸡矢藤：蓼科</li><li>海仙花</li><li>紫丁香</li><li>厚萼凌霄：位于亭子，6月开花</li><li>紫荆：苏木亚科，早春</li></ul><a id="more"></a><h2 id="工学部世纪广场"><a href="#工学部世纪广场" class="headerlink" title="工学部世纪广场"></a>工学部世纪广场</h2><ul><li>二球悬铃木</li><li>樟树</li><li>棕榈</li><li>复羽叶栾树</li><li>洋玉兰：常绿乔木，椭圆形革质叶</li><li>玉兰（白玉兰）：落叶乔木，先叶开花</li><li>结香：瑞香科，早春开花，先叶开花，花香久闻头疼</li><li>苏铁（铁树）：裸子植物，苏铁科</li><li>鹅观草：位于世纪广场草丛，下同</li><li>棒头草</li><li>雀麦</li><li>菵草</li><li>看麦娘</li><li>瓶尔小草：蕨类，此类是野生，不属于武大常规品种</li><li>绶草（盘龙参）：兰科，此类是野生，不属于武大常规品种</li></ul><h2 id="医学部广场"><a href="#医学部广场" class="headerlink" title="医学部广场"></a>医学部广场</h2><ul><li>雪松</li><li>桂花（木犀）</li><li>樟树</li><li>池衫</li><li>细叶结缕草：位于广场草地，下同</li><li>狗牙根</li><li>早熟禾：早春开花</li><li>救荒野豌豆：荚果，比下类野豌豆果长</li><li>四籽野豌豆：荚果，</li><li>匍茎通泉草：玄参科，通泉草属，二唇形花</li><li>直立婆婆纳：玄参科</li><li>垂丝海棠：，蔷薇科苹果亚科苹果属，不位于广场，下同</li><li>贴梗海棠：灌木状，木瓜属，结果</li><li>槐树：豆科</li><li>喜树：珙桐科</li></ul><h2 id="信部星湖园"><a href="#信部星湖园" class="headerlink" title="信部星湖园"></a>信部星湖园</h2><ul><li><p>孝顺竹：丛生，禾本科</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180210/2eCJgi70j3.png?imageslim" alt="mark"></p></li><li><p>君迁子（黑枣）：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180210/hI1lbKdGmI.png?imageslim" alt="mark"></p></li><li><p>旱柳：星湖周围，下同</p></li><li><p>垂柳</p></li><li><p>榔榆：榆科，秋花秋果</p></li><li><p>朴树：榔榆旁边</p></li><li><p>木瓜：蔷薇科，树皮类似迷彩服</p></li><li><p>臭椿：苦木科</p></li><li><p>侧柏：柏科</p></li><li><p>柏木</p></li></ul><h2 id="武大牌坊入口区"><a href="#武大牌坊入口区" class="headerlink" title="武大牌坊入口区"></a>武大牌坊入口区</h2><ul><li>金叶女贞</li><li>大叶黄杨</li><li>樟树</li></ul><h2 id="人文馆"><a href="#人文馆" class="headerlink" title="人文馆"></a>人文馆</h2><ul><li>桂花</li><li>圆柏</li><li>海桐</li><li>含笑</li><li>大叶黄杨</li><li>龙爪槐</li><li>桃花：距离人文馆稍远处，下同</li><li>梅花</li><li>山茶</li><li>紫薇</li></ul><h2 id="情人坡"><a href="#情人坡" class="headerlink" title="情人坡"></a>情人坡</h2><ul><li>池衫</li><li>山茶</li><li>垂丝海棠</li><li>贴梗海棠</li><li>湖北海棠</li><li>木瓜</li></ul><h2 id="茶港教工宿舍区小游园"><a href="#茶港教工宿舍区小游园" class="headerlink" title="茶港教工宿舍区小游园"></a>茶港教工宿舍区小游园</h2><ul><li><p>枇杷</p></li><li><p>桂树</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180210/EKgABe2Gmd.png?imageslim" alt="mark"></p></li></ul><h2 id="西区教工宿舍小游园"><a href="#西区教工宿舍小游园" class="headerlink" title="西区教工宿舍小游园"></a>西区教工宿舍小游园</h2><ul><li>广玉兰</li><li>桂树</li><li>雪松</li><li>棕榈</li><li>小叶女贞</li><li>大叶黄杨</li><li>紫藤</li></ul><h2 id="中心湖区"><a href="#中心湖区" class="headerlink" title="中心湖区"></a>中心湖区</h2><ul><li>秤锤树</li><li>杜仲</li><li>榔榆</li><li>朴树</li><li>小叶栎</li><li>皂荚</li><li>毛竹</li><li>紫叶李</li><li>绣球荚蒾</li><li>红继木</li><li>鸡爪槭</li><li>红枫</li><li>蝴蝶花</li><li>麦冬</li><li>酢浆草</li></ul><h2 id="珞珈山枫园路"><a href="#珞珈山枫园路" class="headerlink" title="珞珈山枫园路"></a>珞珈山枫园路</h2><ul><li>水杉</li><li>枫树</li><li>棕榈</li><li>桂树</li><li>石楠</li><li>柑橘</li><li>鸡爪槭</li><li>紫叶李</li></ul><h2 id="老图书馆"><a href="#老图书馆" class="headerlink" title="老图书馆"></a>老图书馆</h2><h3 id="王世杰塑像"><a href="#王世杰塑像" class="headerlink" title="王世杰塑像"></a>王世杰塑像</h3><ul><li>银杏</li><li>黑松</li><li>刺柏</li><li>黄连木</li><li>石榴</li><li>海桐</li></ul><h3 id="王星拱塑像"><a href="#王星拱塑像" class="headerlink" title="王星拱塑像"></a>王星拱塑像</h3><ul><li>女贞</li><li>棕榈</li><li>海桐</li><li>法国冬青</li></ul><h3 id="西侧入口"><a href="#西侧入口" class="headerlink" title="西侧入口"></a>西侧入口</h3><ul><li>石榴</li><li>南天竹</li><li>桂树</li></ul><ul><li>石榴</li><li>桑树</li><li>落木石楠</li><li>朴树</li></ul><h3 id="东侧入口"><a href="#东侧入口" class="headerlink" title="东侧入口"></a>东侧入口</h3><ul><li>石楠</li><li>英国梧桐</li><li>龙柏</li><li>棕榈</li><li>侧柏</li><li>广玉兰</li></ul><h3 id="大楼前与老斋舍接邻草地"><a href="#大楼前与老斋舍接邻草地" class="headerlink" title="大楼前与老斋舍接邻草地"></a>大楼前与老斋舍接邻草地</h3><ul><li>大叶黄杨</li><li>油茶</li><li>石榴</li><li>侧柏</li><li>棕榈</li><li>柑橘</li><li>黑松</li><li>红檵木</li><li>狗牙根</li></ul><h3 id="老斋舍顶从东到西的种植槽"><a href="#老斋舍顶从东到西的种植槽" class="headerlink" title="老斋舍顶从东到西的种植槽"></a>老斋舍顶从东到西的种植槽</h3><ul><li>龙柏</li><li>椤木石楠</li><li>竹</li><li>木槿</li><li>紫藤</li><li>圆柏</li><li>刺柏</li></ul><h2 id="行政楼"><a href="#行政楼" class="headerlink" title="行政楼"></a>行政楼</h2><h3 id="行政楼内左右两侧的绿化圃"><a href="#行政楼内左右两侧的绿化圃" class="headerlink" title="行政楼内左右两侧的绿化圃"></a>行政楼内左右两侧的绿化圃</h3><ul><li>龙柏</li><li>吉祥草</li></ul><h3 id="行政楼东侧"><a href="#行政楼东侧" class="headerlink" title="行政楼东侧"></a>行政楼东侧</h3><ul><li>对节白蜡</li></ul><h2 id="樱花"><a href="#樱花" class="headerlink" title="樱花"></a>樱花</h2><p>基于<code>《珞珈山原色植物图谱》</code></p><ul><li>240号红花高盆樱：2月底至三月初开花，位于梅园校医院</li><li>241号尾叶樱桃：3-4月开花，位于行政楼旁，即绿樱，橘黄色果</li><li>242号大岛樱：3-4月开花，鲲鹏广场后的花园有几株</li><li>243号东京樱花：4月开花，奥场周围，樱花大道，黑果</li><li>244号垂枝樱花：3月底至四月初开花，晚樱，位于枫园14舍，岔路口通往枫园食堂。枫园三舍南侧路边、樱园南坡绿地（即情人坡）</li><li>245号日本晚樱：4月开花，教五周围，樱花大道和梅操之间情人坡，鲲鹏广场</li></ul><p><img src="https://pic4.zhimg.com/80/292c4dcc4552b69c99aea8298c790f07_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/cc4ffe797dd7ee59230304b315ae7b1d_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/fea0820c2ca082386a4f5a92e73e4a2e_hd.jpg" alt="img"></p><ul><li>信部星湖东侧：</li></ul><p><img src="https://pic4.zhimg.com/80/v2-959da0b4f7bd6c6ec9348d713e3113ac_hd.jpg" alt="img"></p><ul><li>山樱花：又称福岛樱或青肤樱，4月初开花，花期15-20天，位于校医院前、教四前、樱园入口路旁、樱园南坡绿地（下沉花园）</li></ul><h2 id="绿线"><a href="#绿线" class="headerlink" title="绿线"></a>绿线</h2><h3 id="学府路"><a href="#学府路" class="headerlink" title="学府路"></a>学府路</h3><ul><li>樟树：行道树</li><li>金叶女贞：位于花坛</li><li>大叶黄杨：位于花坛</li></ul><h3 id="科技路"><a href="#科技路" class="headerlink" title="科技路"></a>科技路</h3><ul><li>广玉兰：生科院到教四楼行道树</li><li>银杏：生科院到教四楼行道树</li><li>大叶黄杨</li><li>英国梧桐：教四到樱园路行道树</li></ul><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="用途分类"><a href="#用途分类" class="headerlink" title="用途分类"></a>用途分类</h3><h4 id="行道树"><a href="#行道树" class="headerlink" title="行道树"></a>行道树</h4><ul><li>银杏</li><li>雪松</li><li>池衫</li><li>水杉</li><li>三角枫</li><li>枫树</li><li>梅树</li><li>桂树</li><li>女贞</li><li>樟树</li><li>广玉兰</li><li>英国梧桐</li><li>垂柳</li><li>石楠</li><li>樱树</li></ul><h4 id="园景树"><a href="#园景树" class="headerlink" title="园景树"></a>园景树</h4><ul><li>樱树</li><li>圆柏</li><li>龙柏</li><li>重阳木</li><li>拐枣</li><li>榉树</li><li>榔榆</li><li>朴树</li><li>三角枫</li><li>雪松</li><li>杜英</li><li>水杉</li><li>乌桕</li><li>复羽叶栾树</li><li>梧桐</li><li>国槐</li><li>石楠</li><li>白玉兰</li><li>棕榈</li><li>黄连木</li></ul><h4 id="花灌类"><a href="#花灌类" class="headerlink" title="花灌类"></a>花灌类</h4><ul><li>红枫</li><li>紫薇</li><li>卫矛</li><li>紫叶桃</li><li>紫叶李</li><li>海桐</li><li>金丝桃</li><li>八角金盘</li><li>南天竹</li><li>竹叶椒</li><li>杜鹃</li><li>云南黄馨</li><li>月季</li><li>火棘</li><li>枸骨</li></ul><h4 id="绿篱类"><a href="#绿篱类" class="headerlink" title="绿篱类"></a>绿篱类</h4><ul><li>马甲子</li><li>栀子</li><li>十大功劳</li><li>金心黄杨</li><li>雀舌黄杨</li><li>紫叶小檗</li><li>法国冬青</li></ul><h4 id="花坛花境类"><a href="#花坛花境类" class="headerlink" title="花坛花境类"></a>花坛花境类</h4><ul><li>月季</li><li>杜鹃</li><li>葱兰</li><li>一串红</li><li>一串蓝</li><li>火棘</li><li>重瓣棣棠</li><li>石蒜</li><li>大花马齿苋</li><li>夜来香</li><li>柳叶马鞭草</li><li>矮亚菊</li><li>山茶</li><li>夹竹桃</li><li>结香</li><li>木槿</li><li>中华绣线菊</li><li>凤尾鸡冠花</li><li>金盏菊</li><li>雏菊</li><li>金鸡菊</li><li>玉簪</li><li>萱草</li><li>美人蕉</li><li>锦带花</li><li>金钟花</li></ul><h3 id="观赏特性"><a href="#观赏特性" class="headerlink" title="观赏特性"></a>观赏特性</h3><h4 id="观形树"><a href="#观形树" class="headerlink" title="观形树"></a>观形树</h4><ul><li>樟树</li><li>桂花</li><li>银杏</li><li>池衫</li><li>水杉</li><li>马尾松</li><li>雪松</li><li>侧柏</li><li>龙柏</li><li>广玉兰</li><li>英国梧桐</li><li>石楠</li><li>椤木石楠</li><li>红檵木</li><li>垂柳</li><li>朴树</li><li>大叶黄杨</li><li>三角枫</li><li>鸡爪槭</li><li>女贞</li><li>白花泡棢</li><li>榔榆</li><li>日本冷杉</li><li>黑松</li><li>金钱松</li><li>杉木</li><li>日本柳杉</li><li>落羽杉</li><li>日本花柏</li><li>罗汉松</li><li>鹅掌楸</li><li>粗榧</li><li>润楠</li><li>合欢</li><li>黄杨</li><li>雀舌黄杨</li><li>交让木</li><li>旱柳</li><li>胡桃</li><li>化香</li><li>卫矛</li><li>珊瑚朴</li><li>榆树</li><li>榉树</li><li>乌桕</li><li>重阳木</li><li>南酸枣</li><li>黄连木</li><li>盐肤木</li><li>中华槭</li><li>金钟花</li><li>白蜡树</li><li>十大功劳</li><li>紫薇</li><li>毛泡桐</li><li>七叶树</li></ul><h4 id="观花树"><a href="#观花树" class="headerlink" title="观花树"></a>观花树</h4><h5 id="春"><a href="#春" class="headerlink" title="春"></a>春</h5><ul><li>含笑</li><li>白玉兰</li><li>桃</li><li>湖北海棠</li><li>李</li><li>梅</li><li>樱</li><li>麻叶绣线菊</li><li>中华绣线菊</li><li>重瓣棣棠</li><li>紫荆</li><li>瑞香</li><li>连翘</li><li>金钟花</li><li>探春花</li><li>云南黄馨</li><li>毛泡桐</li><li>白花泡桐</li></ul><h5 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h5><ul><li>广玉兰</li><li>金樱子</li><li>小果蔷薇</li><li>山合欢</li><li>合欢</li><li>绣球</li><li>山茱萸</li><li>荚蒾</li><li>红檵木</li><li>栾树</li><li>栀子</li><li>金丝桃</li><li>六月雪</li></ul><h5 id="春夏"><a href="#春夏" class="headerlink" title="春夏"></a>春夏</h5><ul><li>紫藤</li><li>锦鸡儿</li><li>忍冬</li><li>锦带花</li><li>芜花</li><li>石楠</li></ul><h5 id="夏秋"><a href="#夏秋" class="headerlink" title="夏秋"></a>夏秋</h5><ul><li>白兰</li><li>糯米条</li><li>六道木</li><li>木槿</li><li>木芙蓉</li><li>多花勾儿茶</li><li>夹竹桃</li><li>牡荆</li><li>石榴</li><li>锦葵</li></ul><h5 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h5><ul><li>决明</li></ul><h5 id="冬春"><a href="#冬春" class="headerlink" title="冬春"></a>冬春</h5><ul><li>腊梅</li><li>油茶</li></ul><h5 id="四季"><a href="#四季" class="headerlink" title="四季"></a>四季</h5><ul><li>月季</li><li>杜鹃</li><li>桂花</li></ul><h4 id="观叶树木"><a href="#观叶树木" class="headerlink" title="观叶树木"></a>观叶树木</h4><h5 id="春-1"><a href="#春-1" class="headerlink" title="春"></a>春</h5><ul><li>山麻秆</li><li>石楠</li></ul><h5 id="秋-1"><a href="#秋-1" class="headerlink" title="秋"></a>秋</h5><ul><li>金钱松</li><li>落羽杉</li><li>水杉</li><li>池衫</li><li>银杏</li><li>鹅掌楸</li><li>榔榆</li><li>朴树</li><li>榆树</li><li>榉树</li><li>美国地锦</li><li>三角枫</li><li>鸡爪槭</li><li>中华槭</li><li>英国梧桐</li><li>重阳木</li><li>七叶树</li></ul><h5 id="四季-1"><a href="#四季-1" class="headerlink" title="四季"></a>四季</h5><ul><li>紫叶桃</li><li>紫叶李</li></ul><h5 id="特殊叶形"><a href="#特殊叶形" class="headerlink" title="特殊叶形"></a>特殊叶形</h5><ul><li>紫荆</li><li>八角枫</li><li>八角金盘</li><li>黄杨</li><li>雀舌黄杨</li><li>锦熟黄杨</li><li>旱柳</li><li>垂柳</li><li>海桐</li><li>爬山虎</li><li>美国地锦</li><li>大叶黄杨</li><li>夹竹桃</li><li>苏铁</li></ul><h2 id="杂集"><a href="#杂集" class="headerlink" title="杂集"></a>杂集</h2><ul><li>秤锤树：位于未名湖畔东南角</li><li>大叶黄杨：位于梅园花坛</li><li>鹅掌楸：花期4-5月，枫园五舍、工学部网球场、珞珈广场</li><li>含笑：花期4-6月，位于标本馆前、校医院前花坛</li><li>红花酢浆草：校园花坛广布</li><li>红花石蒜：位于樱花大道至标本馆一带</li><li>海桐：花期4-5月，人文馆周边</li><li>合欢：珞珈山庄背面山坡、鲲鹏广场</li><li>花木兰：学校行道树</li><li>金丝桃：花期7-8月，梅园花坛</li><li>金银花：又名忍冬，花期4-6月，路旁、山坡灌丛、疏林中</li><li>鸡冠花：花期8-10月，花坛栽培</li><li>郁李：位于樱园</li><li>鸢尾：梅园花坛</li><li>棕榈：茶港教工生活区行道树</li><li>水杉：茶港教工生活区行道树</li><li>马尾松：南三区教工宿舍区</li><li>石榴：南三区教工宿舍区</li><li>女贞：狮子山、行政楼</li><li>枫树：枫园、奥场、珞珈广场</li><li>枫香树：枫园</li><li>桑树：信部、樱顶</li><li>樱花大道旁8棵银杏是20世纪30年代珞珈山建校初期栽植</li><li>罗汉松：育才路</li><li>绿樱：行政楼前</li><li>美人梅：梅园，梅和紫叶李杂交</li><li>阿拉伯婆婆纳：</li><li>柞树：武大附小花坛旁</li><li>南酸枣：武大梅园，名木</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文理学部李达塑像&quot;&gt;&lt;a href=&quot;#文理学部李达塑像&quot; class=&quot;headerlink&quot; title=&quot;文理学部李达塑像&quot;&gt;&lt;/a&gt;文理学部李达塑像&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;樟树&lt;/li&gt;
&lt;li&gt;蝴蝶花：4月，鸢尾科&lt;/li&gt;
&lt;li&gt;鸢尾&lt;/li&gt;
&lt;li&gt;吉祥草：百合科，秋花&lt;/li&gt;
&lt;li&gt;南天竹：小檗科&lt;/li&gt;
&lt;li&gt;锦绣杜鹃：杜鹃科&lt;/li&gt;
&lt;li&gt;麦冬：百合科，6月开花&lt;/li&gt;
&lt;li&gt;池衫&lt;/li&gt;
&lt;li&gt;羊蹄：蓼科，酸模属&lt;/li&gt;
&lt;li&gt;车前&lt;/li&gt;
&lt;li&gt;蛇莓：蔷薇科，果不能吃&lt;/li&gt;
&lt;li&gt;扬子毛茛&lt;/li&gt;
&lt;li&gt;何首乌：蓼科&lt;/li&gt;
&lt;li&gt;鸡矢藤：蓼科&lt;/li&gt;
&lt;li&gt;海仙花&lt;/li&gt;
&lt;li&gt;紫丁香&lt;/li&gt;
&lt;li&gt;厚萼凌霄：位于亭子，6月开花&lt;/li&gt;
&lt;li&gt;紫荆：苏木亚科，早春&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="https://tianwenyu.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="杂七杂八" scheme="https://tianwenyu.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>【Python Trick】Python中字典常用方法</title>
    <link href="https://tianwenyu.github.io/python-dict/"/>
    <id>https://tianwenyu.github.io/python-dict/</id>
    <published>2018-02-08T12:29:30.000Z</published>
    <updated>2018-02-27T07:28:34.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典常用操作"><a href="#字典常用操作" class="headerlink" title="字典常用操作"></a>字典常用操作</h2><h3 id="定义空字典"><a href="#定义空字典" class="headerlink" title="定义空字典"></a>定义空字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="键值对的添加"><a href="#键值对的添加" class="headerlink" title="键值对的添加"></a>键值对的添加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic[<span class="string">'name'</span>]=<span class="string">'zhangsan'</span></span><br></pre></td></tr></table></figure><h2 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h2><p>通过<code>items()</code>方法返回的元组列表进行序列解包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(key,value))</span><br><span class="line">    <span class="comment">#print('%s:%s' %(key,value))</span></span><br></pre></td></tr></table></figure><h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><h3 id="字典按键排序"><a href="#字典按键排序" class="headerlink" title="字典按键排序"></a>字典按键排序</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">print(key,dic[key] <span class="keyword">for</span> key <span class="keyword">in</span> sorted(dic.keys))</span><br></pre></td></tr></table></figure><h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#升序排序</span></span><br><span class="line">dic=dict(sorted(dic.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#降序排序</span></span><br><span class="line">dic=dict(sorted(dic.itmes(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>))</span><br></pre></td></tr></table></figure><p><code>sorted(iterable,key,reverse)</code></p><ul><li><code>iterable</code>参数代表可以迭代的对象，例如可以是<code>dict.items()</code>，<code>dict.keys()</code></li><li><code>key</code>参数是一个函数，用来选取参与比较的元素</li><li><code>reverse</code>参数用来指定是升序还是降序</li></ul><p><code>dic=dict(sorted(dic.items(),key=lambda x:x[0]))</code></p><ul><li><p><code>dic.items()</code>将<code>dic</code>转换为可迭代对象，迭代对象的元素为该字典元素，将其转换为元组</p></li><li><p>key参数对应的lambda表达式即选取元组中的第一个元素作为比较参数，即键。</p><p><code>lambda x:y</code>x表示输出参数，y表示lambda函数的返回值.</p></li><li><p><code>sorted()</code>函数返回值是list类型。</p></li></ul><h3 id="字典按值排序并输出Top-K个元素"><a href="#字典按值排序并输出Top-K个元素" class="headerlink" title="字典按值排序并输出Top K个元素"></a>字典按值排序并输出Top K个元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#升序排序</span></span><br><span class="line">dic=dict(sorted(dic.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]))</span><br><span class="line"><span class="comment">#降序排序</span></span><br><span class="line">dic=dict(sorted(dic.itmes(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出Top K个</span></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line">k=<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt&gt;k:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(key,value))</span><br></pre></td></tr></table></figure><h2 id="字典对象写入Json文件"><a href="#字典对象写入Json文件" class="headerlink" title="字典对象写入Json文件"></a>字典对象写入Json文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#中文字符需要设置ensure_ascii属性为False，否则输出为ASII码</span></span><br><span class="line">data=json.dumps(dic,ensure_ascii=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'xxx.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字典常用操作&quot;&gt;&lt;a href=&quot;#字典常用操作&quot; class=&quot;headerlink&quot; title=&quot;字典常用操作&quot;&gt;&lt;/a&gt;字典常用操作&lt;/h2&gt;&lt;h3 id=&quot;定义空字典&quot;&gt;&lt;a href=&quot;#定义空字典&quot; class=&quot;headerlink&quot; title=&quot;定义空字典&quot;&gt;&lt;/a&gt;定义空字典&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dic=&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tianwenyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://tianwenyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python Trick】Python的switch-case实现</title>
    <link href="https://tianwenyu.github.io/python-switch/"/>
    <id>https://tianwenyu.github.io/python-switch/</id>
    <published>2018-02-07T12:29:30.000Z</published>
    <updated>2018-02-07T02:58:20.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Python中，并没有实现<code>switch-case</code>语句，通过<code>if-elif</code>实现会显得麻烦，因此通过以下方式实现该语句功能。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="通过字典实现"><a href="#通过字典实现" class="headerlink" title="通过字典实现"></a>通过字典实现</h3><p>以如下情景为例，将百分制分数转换为五分制分数。如<code>100%</code>转换为<code>5</code>，<code>80%</code>转换为<code>4</code>等。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(score)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'100%'</span>:<span class="number">5</span>,</span><br><span class="line">            <span class="string">'80%'</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="string">'60%'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'40%'</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="string">'20%'</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">'0%'</span>:<span class="number">0</span></span><br><span class="line">        &#125;.get(score)</span><br><span class="line"></span><br><span class="line">print(foo(<span class="string">'100%'</span>)) <span class="comment">#输出5</span></span><br><span class="line">print(foo(<span class="string">'80%'</span>)) <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure><h3 id="通过匿名函数实现"><a href="#通过匿名函数实现" class="headerlink" title="通过匿名函数实现"></a>通过匿名函数实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(score,x)</span>:</span></span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line"><span class="string">'100%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">5</span>,</span><br><span class="line"><span class="string">'80%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">4</span>,</span><br><span class="line"><span class="string">'60%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">3</span>,</span><br><span class="line"><span class="string">'40%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">2</span>,</span><br><span class="line"><span class="string">'20%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">1</span>,</span><br><span class="line"><span class="string">'0%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">0</span>,</span><br><span class="line">&#125;[score](x)</span><br><span class="line"></span><br><span class="line">print(foo(<span class="string">'100%'</span>,<span class="number">0</span>)) <span class="comment">#输出5</span></span><br><span class="line">print(foo(<span class="string">'80%'</span>,<span class="number">0</span>)) <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Python中，并没有实现&lt;code&gt;switch-case&lt;/code&gt;语句，通过&lt;code&gt;if-elif&lt;/code&gt;实现会显得麻烦，因此通过以下方式实现该语句功能。&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h2&gt;&lt;h3 id=&quot;通过字典实现&quot;&gt;&lt;a href=&quot;#通过字典实现&quot; class=&quot;headerlink&quot; title=&quot;通过字典实现&quot;&gt;&lt;/a&gt;通过字典实现&lt;/h3&gt;&lt;p&gt;以如下情景为例，将百分制分数转换为五分制分数。如&lt;code&gt;100%&lt;/code&gt;转换为&lt;code&gt;5&lt;/code&gt;，&lt;code&gt;80%&lt;/code&gt;转换为&lt;code&gt;4&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tianwenyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://tianwenyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Windows下pip更换源地址</title>
    <link href="https://tianwenyu.github.io/windows-pip/"/>
    <id>https://tianwenyu.github.io/windows-pip/</id>
    <published>2018-02-07T12:29:30.000Z</published>
    <updated>2018-02-07T06:05:32.953Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>打开<code>cmd</code>，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> %APPDATA%</span><br></pre></td></tr></table></figure><p>进入到显示的路径中</p></li><li><p>进入该路径，新建<code>pip</code>文件夹，然后在该文件夹下新建<code>pip.ini</code></p></li><li><p>编辑<code>pip.ini</code>，输入以下内容，即把源地址改为阿里云地址。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">6000</span></span><br><span class="line"><span class="attr">index-url</span> = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"><span class="section">[install]</span></span><br><span class="line"><span class="attr">trusted-host</span>=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开&lt;code&gt;cmd&lt;/code&gt;，输入&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_
      
    
    </summary>
    
      <category term="Python" scheme="https://tianwenyu.github.io/categories/Python/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="pip" scheme="https://tianwenyu.github.io/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>Seaborn库的使用</title>
    <link href="https://tianwenyu.github.io/seaborn/"/>
    <id>https://tianwenyu.github.io/seaborn/</id>
    <published>2018-02-07T02:29:30.000Z</published>
    <updated>2018-02-27T07:31:11.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountPlot"><a href="#CountPlot" class="headerlink" title="CountPlot"></a>CountPlot</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">train_data=pd.read_csv(<span class="string">'./data/train.csv'</span>)</span><br><span class="line">sns.countplot(x=<span class="string">'Score'</span>,data=train_data)</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>sns.countplot(x=&#39;Score&#39;,data=train_data)</code></p><p>【注】</p><p>属性<code>x</code>为x轴名称，值必须为数据集中的列名。属性<code>x</code>或<code>y</code>中任一一组没有值，则默认<code>count</code></p><p>属性<code>data</code>为数据集，值可以为<code>pandas</code>的<code>dataframe</code>类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CountPlot&quot;&gt;&lt;a href=&quot;#CountPlot&quot; class=&quot;headerlink&quot; title=&quot;CountPlot&quot;&gt;&lt;/a&gt;CountPlot&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;%matplotlib inline&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; seaborn &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; sns&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;train_data=pd.read_csv(&lt;span class=&quot;string&quot;&gt;&#39;./data/train.csv&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sns.countplot(x=&lt;span class=&quot;string&quot;&gt;&#39;Score&#39;&lt;/span&gt;,data=train_data)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://tianwenyu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Seaborn" scheme="https://tianwenyu.github.io/tags/Seaborn/"/>
    
  </entry>
  
  <entry>
    <title>【汽车口碑分析】3.爬取汽车评论数据</title>
    <link href="https://tianwenyu.github.io/automobile-analysis-3/"/>
    <id>https://tianwenyu.github.io/automobile-analysis-3/</id>
    <published>2018-02-03T12:29:30.000Z</published>
    <updated>2018-02-07T02:22:56.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>Ubuntu 16.04</li><li>Python 3.5</li></ul><h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h2><ul><li>Scrapy</li></ul><h2 id="需求目标"><a href="#需求目标" class="headerlink" title="需求目标"></a>需求目标</h2><p>本项目为汽车口碑分析，第一步需要爬取对于不同车型的评论数据。</p><p>选择<a href="http://www.58che.com/brand.html" target="_blank" rel="external">58车</a>的车型分类爬取评论数据。</p><a id="more"></a><h2 id="爬取流程"><a href="#爬取流程" class="headerlink" title="爬取流程"></a>爬取流程</h2><ol><li><p>先获取每个车型的链接，以下图中红框内的车型为例</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/jB04IJjkLk.png?imageslim" alt="mark"></p></li><li><p>打开链接后，抓取下图红框中的总评分，写入文件中。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/5j7LE7l1EB.png?imageslim" alt="mark"></p></li><li><p>写入总评分后，通过拼接链接进入该车型的用户评论页面。</p><p>通过第一步中获取的链接拼接上<code>list_s1_p1.html</code>，组成用户评论页面的链接。</p><p>【注】此为第一页的链接，若还有下一页，下述步骤会提及处理方法。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/9KaKELGGj7.png?imageslim" alt="mark"></p></li><li><p>抓取评论页面中的各种数据，如<code>id</code>，<code>评分</code>，<code>评论</code>等。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/24mD9Kk40g.png?imageslim" alt="mark"></p></li><li><p>若该评论页面还有<code>下一页</code>，则继续抓取下一页中的评论数据。</p><p>【方法】</p><p>判断页面中是否有<code>下一页</code>元素，若有则回调解析评论页面的方法。</p></li><li><p>将爬取的数据保存到文件中。</p></li></ol><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程"></a>创建新工程</h3><p>先创建工程目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/t/dataset/</span><br><span class="line">mkdir carSpider</span><br></pre></td></tr></table></figure><p>创建新工程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy startproject carSpider</span><br></pre></td></tr></table></figure><h3 id="编辑items-py文件"><a href="#编辑items-py文件" class="headerlink" title="编辑items.py文件"></a>编辑<code>items.py</code>文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># http://doc.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarspiderItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    file=scrapy.Field() <span class="comment">#文件名</span></span><br><span class="line">    car=scrapy.Field() <span class="comment">#车型</span></span><br><span class="line">    score=scrapy.Field() <span class="comment">#总评分</span></span><br><span class="line">    u_id=scrapy.Field() <span class="comment">#用户ID</span></span><br><span class="line">    u_score=scrapy.Field() <span class="comment">#用户评分</span></span><br><span class="line">    u_merit=scrapy.Field() <span class="comment">#用户评论优点</span></span><br><span class="line">    u_demerit=scrapy.Field() <span class="comment">#用户评论缺点</span></span><br><span class="line">    u_summary=scrapy.Field() <span class="comment">#用户评论综述</span></span><br><span class="line">    u_flower=scrapy.Field() <span class="comment">#用户评论鲜花数</span></span><br><span class="line">    u_brick=scrapy.Field() <span class="comment">#用户评论板砖数</span></span><br></pre></td></tr></table></figure><h3 id="编写carSpider-py文件"><a href="#编写carSpider-py文件" class="headerlink" title="编写carSpider.py文件"></a>编写<code>carSpider.py</code>文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> carSpider.items <span class="keyword">import</span> CarspiderItem</span><br><span class="line"></span><br><span class="line">baseDir = <span class="string">'/home/t/dataset/carRemark/'</span></span><br><span class="line">startUrl=<span class="string">'http://www.58che.com/brand.html'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line"></span><br><span class="line">    name=<span class="string">'spider'</span> <span class="comment">#爬虫名</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start_urls=[startUrl] </span><br><span class="line"></span><br><span class="line">    <span class="comment">#第一层解析方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self,response)</span>:</span></span><br><span class="line"><span class="comment">#定位到车型元素</span></span><br><span class="line">        subclasses=response.css(<span class="string">'body &gt; div.fltop &gt; div.marcenter &gt; div &gt; div &gt; div.r &gt; ul &gt; li &gt; dl &gt; dt &gt; a'</span>)</span><br><span class="line">        <span class="keyword">for</span> subclass <span class="keyword">in</span> subclasses:</span><br><span class="line">            subclass_name=subclass.xpath(<span class="string">'text()'</span>).extract_first() <span class="comment">#获取车型名称文本</span></span><br><span class="line">            subclass_link=subclass.xpath(<span class="string">'@href'</span>).extract_first() <span class="comment">#获取车型链接</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=subclass_link,callback=self.parse_car_subclass,meta=&#123;<span class="string">'file'</span>:subclass_name&#125;) <span class="comment">#回调下一层解析方法，并把车型名称传递给该方法作为文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二层解析方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_car_subclass</span><span class="params">(self,response)</span>:</span></span><br><span class="line">        infos=response.css(<span class="string">'#line1 &gt; div.cars_line2.l &gt; div.dianpings &gt; div.d_div1.clearfix &gt; font'</span>) <span class="comment">#定位到总评分元素</span></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> infos:</span><br><span class="line">            score=info.xpath(<span class="string">'text()'</span>).extract_first() <span class="comment">#获取总评分元素文本</span></span><br><span class="line">            file=response.meta[<span class="string">'file'</span>] <span class="comment">#获取上个Request传递来的meta['file']</span></span><br><span class="line">            self.writeScore(file,score) <span class="comment">#将总评分写入文件中</span></span><br><span class="line">            link=response.url+<span class="string">'list_s1_p1.html'</span> <span class="comment">#拼接用户评论第一页链接</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=link,callback=self.parse_remark,meta=&#123;<span class="string">'file'</span>:file&#125;) <span class="comment">#回调下一层解析方法，把车型名称传递给该方法作为文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三层解析方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_remark</span><span class="params">(self,response)</span>:</span></span><br><span class="line">        <span class="comment">#定位到用户评论元素</span></span><br><span class="line">        infos=response.css(<span class="string">'body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; dl'</span>)</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> infos:</span><br><span class="line">            uid=info.xpath(<span class="string">'dd[1]/strong/a/text()'</span>)[<span class="number">0</span>].extract() <span class="comment">#获取用户ID</span></span><br><span class="line">            score=info.xpath(<span class="string">'dd[1]/div/div/@style'</span>)[<span class="number">0</span>].extract() <span class="comment">#获取用户评分星级</span></span><br><span class="line">            score=self.getScore(score) <span class="comment">#将用户评分星级转化为5分制评分</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#先获取是否有‘优点’元素，若有则定位‘优点’元素的下一个兄弟节点，即‘优点评语’，若无则为空</span></span><br><span class="line">                node=info.xpath(<span class="string">'dd[2]/div/div[contains(@class,"l redc00")]'</span>)[<span class="number">0</span>] </span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    merit=node.xpath(<span class="string">'following-sibling::*[1]/text()'</span>)[<span class="number">0</span>].extract()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    merit=<span class="string">''</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                merit=<span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#先获取是否有‘缺点’元素，若有则定位‘缺点’元素的下一个兄弟节点，即‘缺点评语’，若无则为空</span></span><br><span class="line">                node=info.xpath(<span class="string">'dd[2]/div/div[contains(@class,"l hei666")]'</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    demerit=node.xpath(<span class="string">'following-sibling::*[1]/text()'</span>)[<span class="number">0</span>].extract()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    demerit=<span class="string">''</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                demerit=<span class="string">''</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#先获取是否有‘综述’元素，若有则定位‘综述’元素的下一个兄弟节点，即‘综述评语’，若无则为空</span></span><br><span class="line">                node=info.xpath(<span class="string">'dd[2]/div/div[contains(@class,"l")]'</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    summary=node.xpath(<span class="string">'following-sibling::*[1]/text()'</span>)[<span class="number">0</span>].extract()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    summary=<span class="string">''</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                summary=<span class="string">''</span></span><br><span class="line"></span><br><span class="line">            flower=info.xpath(<span class="string">'dd[2]/div[contains(@class,"apply")]/a[3]/span/text()'</span>)[<span class="number">0</span>].extract() <span class="comment">#获取鲜花数</span></span><br><span class="line">            brick=info.xpath(<span class="string">'dd[2]/div[contains(@class,"apply")]/a[4]/span/text()'</span>)[<span class="number">0</span>].extract() <span class="comment">#获取板砖数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#创建Item</span></span><br><span class="line">            item=CarspiderItem()</span><br><span class="line">            item[<span class="string">'file'</span>]=response.meta[<span class="string">'file'</span>]</span><br><span class="line">            item[<span class="string">'u_id'</span>]=uid</span><br><span class="line">            item[<span class="string">'u_score'</span>]=score</span><br><span class="line">            item[<span class="string">'u_merit'</span>]=merit</span><br><span class="line">            item[<span class="string">'u_demerit'</span>]=demerit</span><br><span class="line">            item[<span class="string">'u_summary'</span>]=summary</span><br><span class="line">            item[<span class="string">'u_flower'</span>]=flower</span><br><span class="line">            item[<span class="string">'u_brick'</span>]=brick</span><br><span class="line"></span><br><span class="line">            <span class="comment">#生成Item</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#获取`下一页`元素，若有则回调`parse_remark`第三层解析方法，即继续获取下一页用户评论数据</span></span><br><span class="line">        <span class="comment">#定位`下一页`元素</span></span><br><span class="line">        next_pages=response.css(<span class="string">'body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; div &gt; a.next'</span>)</span><br><span class="line">        <span class="keyword">for</span> next_page <span class="keyword">in</span> next_pages:</span><br><span class="line">            <span class="comment">#若有`下一页`元素，则拼接`下一页`元素链接，并回调第三层解析方法，用来获取下一页用户评论数据</span></span><br><span class="line">            <span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                next_page_link=next_page.xpath(<span class="string">'@href'</span>)[<span class="number">0</span>].extract()</span><br><span class="line">                next_page_link=<span class="string">'http://www.58che.com'</span>+next_page_link</span><br><span class="line">                file=response.meta[<span class="string">'file'</span>]</span><br><span class="line">                <span class="keyword">yield</span> scrapy.Request(url=next_page_link, callback=self.parse_remark, meta=&#123;<span class="string">'file'</span>: file&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将总评分写入文件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeScore</span><span class="params">(self,file,score)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'/home/t/dataset/carRemark/'</span>+file+<span class="string">'.json'</span>,<span class="string">'a+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(score+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将用户评分星级转为5分制分数，类似switch功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getScore</span><span class="params">(self,text)</span>:</span></span><br><span class="line">        text=text.split(<span class="string">':'</span>)[<span class="number">1</span>] <span class="comment">#分割文本，原文本格式形如`width:100%`，分割并截取`:`后的文本</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'100%'</span>:<span class="number">5</span>,</span><br><span class="line">            <span class="string">'80%'</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="string">'60%'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'40%'</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="string">'20%'</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">'0%'</span>:<span class="number">0</span></span><br><span class="line">        &#125;.get(text)</span><br></pre></td></tr></table></figure><p>【解析】</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定位到用户评论元素</span></span><br><span class="line">   infos=response.css(<span class="string">'body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; dl'</span>)</span><br></pre></td></tr></table></figure><p>此句代码定位的元素如下图所示，定位到的是评论页面每条评论的元素整体。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/GDkBDcE9A8.png?imageslim" alt="mark"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> infos:</span><br><span class="line">           uid=info.xpath(<span class="string">'dd[1]/strong/a/text()'</span>)[<span class="number">0</span>].extract() <span class="comment">#获取用户ID</span></span><br><span class="line">           score=info.xpath(<span class="string">'dd[1]/div/div/@style'</span>)[<span class="number">0</span>].extract() <span class="comment">#获取用户评分星级</span></span><br><span class="line">           score=self.getScore(score) <span class="comment">#将用户评分星级转化为5分制评分</span></span><br></pre></td></tr></table></figure><p><code>uid</code>定位到的元素如下图所示，</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/3jJH33i5lI.png?imageslim" alt="mark"></p><p><code>score</code>定位到的元素如下图所示，获取<code>score</code>元素的<code>style</code>属性，值形如<code>width:80%</code>，需要通过<code>getScore()</code>方法转换为五分制分数。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/1IG8ef6j92.png?imageslim" alt="mark"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#先获取是否有‘优点’元素，若有则定位‘优点’元素的下一个兄弟节点，即‘优点评语’，若无则为空</span></span><br><span class="line">node=info.xpath(<span class="string">'dd[2]/div/div[contains(@class,"l redc00")]'</span>)[<span class="number">0</span>] </span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">merit=node.xpath(<span class="string">'following-sibling::*[1]/text()'</span>)[<span class="number">0</span>].extract()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">merit=<span class="string">''</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">merit=<span class="string">''</span></span><br></pre></td></tr></table></figure><p>先定位是否有<code>优点</code>元素，如下图红框所示，若有该元素，则获取<code>优点</code>元素的下一个兄弟节点内容，如下图蓝框所示，若无则为空。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180206/6Bl97dCa4D.png?imageslim" alt="mark"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取`下一页`元素，若有则回调`parse_remark`第三层解析方法，即继续获取下一页用户评论数据</span></span><br><span class="line"><span class="comment">#定位`下一页`元素</span></span><br><span class="line">next_pages=response.css(<span class="string">'body &gt; div.newbox &gt; div &gt; div.xgo_cars_w760.l &gt; div.xgo_dianping_infos.mb10 &gt; div.xgo_cars_dianping &gt; div &gt; div &gt; a.next'</span>)</span><br><span class="line"><span class="keyword">for</span> next_page <span class="keyword">in</span> next_pages:</span><br><span class="line"><span class="comment">#若有`下一页`元素，则拼接`下一页`元素链接，并回调第三层解析方法，用来获取下一页用户评论数据</span></span><br><span class="line"><span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">next_page_link=next_page.xpath(<span class="string">'@href'</span>)[<span class="number">0</span>].extract()</span><br><span class="line">             next_page_link=<span class="string">'http://www.58che.com'</span>+next_page_link</span><br><span class="line">             file=response.meta[<span class="string">'file'</span>]</span><br><span class="line">             <span class="keyword">yield</span> scrapy.Request(url=next_page_link, callback=self.parse_remark, meta=&#123;<span class="string">'file'</span>: file&#125;)</span><br></pre></td></tr></table></figure><p>解析完上述内容，判断用户评论页面是否有分页，定位是否有<code>下一页</code>元素，如下图红框所示，若有则获取该元素链接，如下图橙框所示。</p><p>获取之后，回调<code>parse_remark</code>方法解析下一页的评论页面。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180207/3bDiLjmH2b.png?imageslim" alt="mark"></p><h2 id="编辑pipelines-py文件"><a href="#编辑pipelines-py文件" class="headerlink" title="编辑pipelines.py文件"></a>编辑<code>pipelines.py</code>文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line">baseDir = <span class="string">'/home/t/dataset/carRemark/'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarspiderPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        print(item[<span class="string">'file'</span>])</span><br><span class="line">        <span class="keyword">with</span> codecs.open(baseDir+item[<span class="string">'file'</span>]+<span class="string">'.json'</span>,<span class="string">'a+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            line=json.dumps(dict(item),ensure_ascii=<span class="keyword">False</span>)+<span class="string">'\n'</span></span><br><span class="line">            f.write(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h2 id="编辑settings-py文件"><a href="#编辑settings-py文件" class="headerlink" title="编辑settings.py文件"></a>编辑<code>settings.py</code>文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scrapy settings for carSpider project</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For simplicity, this file contains only settings considered important or</span></span><br><span class="line"><span class="comment"># commonly used. You can find more settings consulting the documentation:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://doc.scrapy.org/en/latest/topics/settings.html</span></span><br><span class="line"><span class="comment">#     http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html</span></span><br><span class="line"><span class="comment">#     http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.html</span></span><br><span class="line"></span><br><span class="line">BOT_NAME = <span class="string">'carSpider'</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">'carSpider.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'carSpider.spiders'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = 'carSpider (+http://www.yourdomain.com)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure maximum concurrent requests performed by Scrapy (default: 16)</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS = 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a delay for requests for the same website (default: 0)</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/settings.html#download-delay</span></span><br><span class="line"><span class="comment"># See also autothrottle settings and docs</span></span><br><span class="line"><span class="comment">#DOWNLOAD_DELAY = 3</span></span><br><span class="line"><span class="comment"># The download delay setting will honor only one of:</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS_PER_DOMAIN = 16</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS_PER_IP = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable cookies (enabled by default)</span></span><br><span class="line"><span class="comment">#COOKIES_ENABLED = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable Telnet Console (enabled by default)</span></span><br><span class="line"><span class="comment">#TELNETCONSOLE_ENABLED = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Override the default request headers:</span></span><br><span class="line"><span class="comment">#DEFAULT_REQUEST_HEADERS = &#123;</span></span><br><span class="line"><span class="comment">#   'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',</span></span><br><span class="line"><span class="comment">#   'Accept-Language': 'en',</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable or disable spider middlewares</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/spider-middleware.html</span></span><br><span class="line"><span class="comment">#SPIDER_MIDDLEWARES = &#123;</span></span><br><span class="line"><span class="comment">#    'carSpider.middlewares.CarspiderSpiderMiddleware': 543,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable or disable downloader middlewares</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html</span></span><br><span class="line"><span class="comment">#DOWNLOADER_MIDDLEWARES = &#123;</span></span><br><span class="line"><span class="comment">#    'carSpider.middlewares.MyCustomDownloaderMiddleware': 543,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable or disable extensions</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/extensions.html</span></span><br><span class="line"><span class="comment">#EXTENSIONS = &#123;</span></span><br><span class="line"><span class="comment">#    'scrapy.extensions.telnet.TelnetConsole': None,</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure item pipelines</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'carSpider.pipelines.CarspiderPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable and configure the AutoThrottle extension (disabled by default)</span></span><br><span class="line"><span class="comment"># See http://doc.scrapy.org/en/latest/topics/autothrottle.html</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_ENABLED = True</span></span><br><span class="line"><span class="comment"># The initial download delay</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_START_DELAY = 5</span></span><br><span class="line"><span class="comment"># The maximum download delay to be set in case of high latencies</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_MAX_DELAY = 60</span></span><br><span class="line"><span class="comment"># The average number of requests Scrapy should be sending in parallel to</span></span><br><span class="line"><span class="comment"># each remote server</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0</span></span><br><span class="line"><span class="comment"># Enable showing throttling stats for every response received:</span></span><br><span class="line"><span class="comment">#AUTOTHROTTLE_DEBUG = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable and configure HTTP caching (disabled by default)</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings</span></span><br><span class="line">HTTPCACHE_ENABLED = <span class="keyword">False</span></span><br><span class="line"><span class="comment">#HTTPCACHE_EXPIRATION_SECS = 0</span></span><br><span class="line"><span class="comment">#HTTPCACHE_DIR = 'httpcache'</span></span><br><span class="line"><span class="comment">#HTTPCACHE_IGNORE_HTTP_CODES = []</span></span><br><span class="line"><span class="comment">#HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage'</span></span><br></pre></td></tr></table></figure><p>【解析】</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ROBOTSTXT_OBEY = <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>将原来的<code>True</code>改为<code>False</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'carSpider.pipelines.CarspiderPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原来的注释去掉，即注册pipelines，否则无法使用该pipelines。</p><h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><p>在项目根目录下新建文件<code>entrypoint.py</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180207/42KlbG9aFe.png?imageslim" alt="mark"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line">execute([<span class="string">'scrapy'</span>,<span class="string">'crawl'</span>,<span class="string">'spider'</span>])</span><br></pre></td></tr></table></figure><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p><a href="https://github.com/tianwenyu/58CheSpider" target="_blank" rel="external">Github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04&lt;/li&gt;
&lt;li&gt;Python 3.5&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;技术框架&quot;&gt;&lt;a href=&quot;#技术框架&quot; class=&quot;headerlink&quot; title=&quot;技术框架&quot;&gt;&lt;/a&gt;技术框架&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Scrapy&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;需求目标&quot;&gt;&lt;a href=&quot;#需求目标&quot; class=&quot;headerlink&quot; title=&quot;需求目标&quot;&gt;&lt;/a&gt;需求目标&lt;/h2&gt;&lt;p&gt;本项目为汽车口碑分析，第一步需要爬取对于不同车型的评论数据。&lt;/p&gt;
&lt;p&gt;选择&lt;a href=&quot;http://www.58che.com/brand.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;58车&lt;/a&gt;的车型分类爬取评论数据。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://tianwenyu.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="汽车口碑分析" scheme="https://tianwenyu.github.io/tags/%E6%B1%BD%E8%BD%A6%E5%8F%A3%E7%A2%91%E5%88%86%E6%9E%90/"/>
    
      <category term="scrapy" scheme="https://tianwenyu.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>【分布式编程】四——Pycharm运行Python版Spark程序</title>
    <link href="https://tianwenyu.github.io/spark-pycharm/"/>
    <id>https://tianwenyu.github.io/spark-pycharm/</id>
    <published>2018-01-13T12:29:30.000Z</published>
    <updated>2018-01-17T15:12:55.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此前搭建成功分布式Spark环境，此文介绍使用Pycharm运行Python语言的Spark程序。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="安装Pycharm"><a href="#安装Pycharm" class="headerlink" title="安装Pycharm"></a>安装Pycharm</h3><ol><li><p><a href="https://download.jetbrains.8686c.com/python/pycharm-professional-2017.3.2.tar.gz" target="_blank" rel="external">点击下载</a>。</p></li><li><p>过程与<a href="https://tianwenyu.github.io/ubuntu-intellij/">安装Intellij IDEA</a>类似，在此不在赘述。</p></li><li><p>进入到安装目录下执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin pycharm-sh</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h3 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h3><ol><li><p>创建新项目</p></li><li><p>新建一个Python文件，这里命名为<code>main.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext,SparkConf</span><br><span class="line"></span><br><span class="line">conf=SparkConf().setAppName(<span class="string">"sparkDemo"</span>).setMaster(<span class="string">"local"</span>)</span><br><span class="line">sc=SparkContext(conf=conf)</span><br><span class="line">logFile=<span class="string">'/data/input/README.txt'</span></span><br><span class="line">logData=sc.textFile(logFile).cache()</span><br><span class="line"></span><br><span class="line">numAs = logData.filter(<span class="keyword">lambda</span> s: <span class="string">'a'</span> <span class="keyword">in</span> s).count()</span><br><span class="line">numBs = logData.filter(<span class="keyword">lambda</span> s: <span class="string">'b'</span> <span class="keyword">in</span> s).count()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Lines with a: %i, lines with b: %i"</span> % (numAs, numBs))</span><br></pre></td></tr></table></figure><p><code>logFile=&#39;/data/input/README.txt&#39;</code></p><p>此路径是之前运行Hadoop例程在HDFS中创建的<code>/data/input</code>文件夹以及上传到此文件夹的<code>README.txt</code>文件。</p></li><li><p>将Spark中的pyspark模块添加到Python环境变量中去</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加以下代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$SPARK_HOME</span>/libexec/python:<span class="variable">$SPARK_HOME</span>/libexec/python/build:<span class="variable">$PYTHONPATH</span></span><br></pre></td></tr></table></figure></li><li><p>更新配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>将<code>/usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip</code>解压。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf /usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip</span><br></pre></td></tr></table></figure><p>将解压后的文件夹复制到<code>/usr/spark-2.2.1-bin-without-hadoop/Python</code>文件夹下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j /usr/spark-2.2.1-bin-without-hadoop/Python</span><br></pre></td></tr></table></figure><p>【注】</p><ul><li><code>/usr/spark-2.2.1-bin-without-hadoop</code>是spark安装目录。</li><li><code>py4j-0.10-4-src.zip</code>根据版本号不同，文件名称也有差异</li></ul></li><li><p>点击<code>Run-Edit Configurations</code></p><p>点击左上角绿色<code>+</code>，选择<code>Python</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/cHdc249k76.png?imageslim" alt="mark"></p><p>填写配置</p><ul><li><p><code>Name</code>：任起一个名字即可</p></li><li><p><code>Script path</code>：执行的Python文件的路径。可以点右侧的下图中红框选择文件路径。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/JdAk0mAFIf.png?imageslim" alt="mark"></p></li><li><p><code>Environment variables</code>：添加<code>PYTHONPATH</code>和<code>SPARK_HOME</code>变量。</p><p><code>PYTHONPATH</code>：<code>spark安装目录/python</code></p><p><code>SPARK_HOME</code>：<code>spark安装目录</code></p></li></ul></li><li><p>点击<code>File-Settings-Project-Project Structure</code></p><p>点击右侧<code>Add Content Root</code></p><p>添加<code>/usr/spark-2.2.1-bin-without-hadoop/Python/lib/py4j-0.10.4-src.zip</code>和<code>/usr/spark-2.2.1-bin-without-hadoop/Python/lib/pyspark.zip</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180117/f9A9bFieH4.png?imageslim" alt="mark"></p></li><li><p>运行即可</p></li></ol><p>【注】若<code>from pyspark import SparkContext,SparkConf</code>下还有红线，则添加以下代码即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">1</span>,<span class="string">'/usr/spark-2.2.1-bin-without-hadoop/python'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此前搭建成功分布式Spark环境，此文介绍使用Pycharm运行Python语言的Spark程序。&lt;/p&gt;
&lt;h2 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;headerlink&quot; title=&quot;操作步骤&quot;&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;&lt;h3 id=&quot;安装Pycharm&quot;&gt;&lt;a href=&quot;#安装Pycharm&quot; class=&quot;headerlink&quot; title=&quot;安装Pycharm&quot;&gt;&lt;/a&gt;安装Pycharm&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://download.jetbrains.8686c.com/python/pycharm-professional-2017.3.2.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击下载&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过程与&lt;a href=&quot;https://tianwenyu.github.io/ubuntu-intellij/&quot;&gt;安装Intellij IDEA&lt;/a&gt;类似，在此不在赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入到安装目录下执行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./bin pycharm-sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Spark" scheme="https://tianwenyu.github.io/categories/Spark/"/>
    
    
      <category term="Python" scheme="https://tianwenyu.github.io/tags/Python/"/>
    
      <category term="Spark" scheme="https://tianwenyu.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>【分布式编程】三——基于VirtualBox的Spark完全分布式环境</title>
    <link href="https://tianwenyu.github.io/virtualbox-spark/"/>
    <id>https://tianwenyu.github.io/virtualbox-spark/</id>
    <published>2018-01-13T02:29:30.000Z</published>
    <updated>2018-01-22T13:57:15.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spark的搭建依赖于Hadoop，因此本文基于之前<a href="https://tianwenyu.github.io/virtualbox-haddop/">分布式Hadoop环境</a>，JDK、Hadoop等已安装好，</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>虚拟机：VirtualBox</li><li>Linux：Ubuntu 16.04 LTS</li><li>HAdoop 2.7.5</li><li>IDE：Intellij IDEA</li><li>JDK 1.8.0_151</li><li>Scala-2.12.4</li><li>Spark-2.2.1</li></ul><a id="more"></a><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="安装Scala"><a href="#安装Scala" class="headerlink" title="安装Scala"></a>安装Scala</h3><ol><li><p>下载<a href="https://downloads.lightbend.com/scala/2.12.4/scala-2.12.4.tgz" target="_blank" rel="external">Scala-2.12.4</a></p></li><li><p>解压到当前目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf scala-2.12.4.tgz</span><br></pre></td></tr></table></figure></li><li><p>将解压后的文件夹移动到<code>/usr</code>下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv scala-2.12.4/ /usr/</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加如下代码，路径根据情况自己修改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SCALA_HOME=/usr/scala-2.12.4</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$SCALA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>更新环境变量配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>验证是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scala -version</span><br></pre></td></tr></table></figure><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180115/e6k62ke67K.png?imageslim" alt=""></p></li></ol><h3 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h3><ol><li><p>下载<a href="http://spark.apache.org/downloads.html" target="_blank" rel="external">Spark</a>，由于Spark基于Hadoop，且之前已经安装好Hadoop，所以下载没有绑定Hadoop的版本，所以选择<a href="http://mirrors.hust.edu.cn/apache/spark/spark-2.2.1/spark-2.2.1-bin-without-hadoop.tgz" target="_blank" rel="external">spark-2.2.1-bin-without-hadoop.tgz</a></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180115/JBJiB7BK7A.png?imageslim" alt="mark"></p></li><li><p>解压到当前目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf spark-2.2.1-bin-without-hadoop.tgz</span><br></pre></td></tr></table></figure></li><li><p>将解压后的文件夹移动到<code>/usr/local/</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv spark-2.2.1-bin-without-hadoop/ /usr/</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加以下代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/spark-2.2.1-bin-without-hadoop</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/sbin</span><br></pre></td></tr></table></figure></li><li><p>更新环境变量配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="Spark配置"><a href="#Spark配置" class="headerlink" title="Spark配置"></a>Spark配置</h3><p>【注】此处以<code>master</code>主机为例，其他从机作相应更改</p><h4 id="配置spark-env-sh"><a href="#配置spark-env-sh" class="headerlink" title="配置spark-env.sh"></a>配置<code>spark-env.sh</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/spark-2.2.1-bin-without-hadoop/conf/</span><br><span class="line">sudo cp spark-env.sh.template spark-env.sh</span><br><span class="line">sudo vim spark-env.sh</span><br></pre></td></tr></table></figure><p>添加以下代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/spark-2.2.1-bin-without-hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_DIST_CLASSPATH=$(/usr/hadoop-2.7.5/bin/hadoop classpath)</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/jdk1.8.0_151</span><br><span class="line"><span class="built_in">export</span> SCALA_HOME=/usr/scala-2.12.4</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/hadoop-2.7.5</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/hadoop-2.7.5/etc/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_IP=master</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=master</span><br><span class="line"><span class="built_in">export</span> SPARK_LOCAL_IP=master</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_MEMEORY=1g</span><br><span class="line"><span class="built_in">export</span> SPARK_EXECUTOR_MEMEORY=1g</span><br><span class="line"><span class="built_in">export</span> SPARK_DRIVER_MEMORY=1g</span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_CORES=1</span><br></pre></td></tr></table></figure><p>【注】</p><ul><li><code>SPARK_LOCAL_IP</code>为本地地址，从机需要更改为自己的IP</li></ul><h4 id="配置slaves"><a href="#配置slaves" class="headerlink" title="配置slaves"></a>配置<code>slaves</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp slaves.template slaves</span><br><span class="line">sudo vim slaves</span><br></pre></td></tr></table></figure><p>添加所有从机的主机名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node1</span><br><span class="line">node2</span><br></pre></td></tr></table></figure><h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>因为Spark基于Hadoop，所以需要先启动Hadoop。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p>再启动Spark，进入到Spark安装目录下的<code>sbin</code>文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/spark-2.2.1-bin-without-hadoop/sbin</span><br></pre></td></tr></table></figure><p>执行<code>sbin</code>文件夹下的<code>start-all.sh</code>，若直接执行<code>start-all.sh</code>，启动的是Hadoop</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>主机上显示以下进程</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/laek5CEcGf.png?imageslim" alt="mark"></p><p>从机显示以下进程</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/8ab821igFG.png?imageslim" alt="mark"></p><h4 id="通过Web查看状态"><a href="#通过Web查看状态" class="headerlink" title="通过Web查看状态"></a>通过Web查看状态</h4><p>在主机<code>master</code>上打开浏览器，访问<code>http://localhost:8080</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/4igD0E0HI2.png?imageslim" alt="mark"></p><h4 id="运行pyspark"><a href="#运行pyspark" class="headerlink" title="运行pyspark"></a>运行pyspark</h4><p>进入到spark安装目录下的<code>bin</code>文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/spark-2.2.1-bin-without-hadoop/bin/</span><br></pre></td></tr></table></figure><p>运行<code>pyspark</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pyspark</span><br></pre></td></tr></table></figure><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/4kfiDg4IfL.png?imageslim" alt="mark"></p><h4 id="运行spark-shell"><a href="#运行spark-shell" class="headerlink" title="运行spark-shell"></a>运行spark-shell</h4><p>进入到spark安装目录下的<code>bin</code>文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/spark-2.2.1-bin-without-hadoop/bin/</span><br></pre></td></tr></table></figure><p>运行<code>spark-shell</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./sparkshell</span><br></pre></td></tr></table></figure><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180116/9DKJiIi12F.png?imageslim" alt="mark"></p><p>以上，证明spark配置成功。</p><h3 id="关闭集群"><a href="#关闭集群" class="headerlink" title="关闭集群"></a>关闭集群</h3><p>同样进入到Spark安装目录下的<code>sbin</code>文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/spark-2.2.1-bin-without-hadoop/sbin</span><br><span class="line">./stop-all.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spark的搭建依赖于Hadoop，因此本文基于之前&lt;a href=&quot;https://tianwenyu.github.io/virtualbox-haddop/&quot;&gt;分布式Hadoop环境&lt;/a&gt;，JDK、Hadoop等已安装好，&lt;/p&gt;
&lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟机：VirtualBox&lt;/li&gt;
&lt;li&gt;Linux：Ubuntu 16.04 LTS&lt;/li&gt;
&lt;li&gt;HAdoop 2.7.5&lt;/li&gt;
&lt;li&gt;IDE：Intellij IDEA&lt;/li&gt;
&lt;li&gt;JDK 1.8.0_151&lt;/li&gt;
&lt;li&gt;Scala-2.12.4&lt;/li&gt;
&lt;li&gt;Spark-2.2.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spark" scheme="https://tianwenyu.github.io/categories/Spark/"/>
    
    
      <category term="VirtualBox" scheme="https://tianwenyu.github.io/tags/VirtualBox/"/>
    
      <category term="Spark" scheme="https://tianwenyu.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>【分布式编程】二——基于Hadoop的MapReduce程序</title>
    <link href="https://tianwenyu.github.io/hadoop-wordcount/"/>
    <id>https://tianwenyu.github.io/hadoop-wordcount/</id>
    <published>2018-01-12T12:29:30.000Z</published>
    <updated>2018-01-14T06:43:59.818Z</updated>
    
    <content type="html"><![CDATA[<p>此前配置好<a href="https://tianwenyu.github.io/virtualbox-haddop/">分布式Hadoop环境</a>，此篇主要讲解通过Intellij IDEA编写分布式MapReduce程序以及利用Hadoop实现词频统计</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>虚拟机：VirtualBox</li><li>Linux：Ubuntu 16.04 LTS</li><li>Hadoop 2.7.5</li><li>IDE：Intellij IDEA </li><li>JDK 1.8.0_151<a id="more"></a><h2 id="安装Intellij及破解"><a href="#安装Intellij及破解" class="headerlink" title="安装Intellij及破解"></a>安装Intellij及破解</h2></li></ul><p><a href="https://tianwenyu.github.io/ubuntu-intellij/">安装Intellij IDEA</a></p><p><a href="https://tianwenyu.github.io/Idea2017-license/">破解Intellij IDEA</a></p><h2 id="创建Hadoop工程"><a href="#创建Hadoop工程" class="headerlink" title="创建Hadoop工程"></a>创建Hadoop工程</h2><h3 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程"></a>创建新工程</h3><ol><li><p>打开Intellij IDEA，创建一个新工程</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180112/FmL2jD01aF.png?imageslim" alt="mark"></p></li><li><p>选择Java项目，并添加JDK路径</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180112/iCAcgIIj3b.png?imageslim" alt="mark"></p></li></ol><h3 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h3><p>点击<code>File-Project Structure</code></p><p>打开后点击左侧<code>Modules</code>，然后点击<code>Dependencies</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180114/5J0ked69Bk.png?imageslim" alt="mark"></p><p>点击右侧<code>+</code>，选择<code>JARs or directories</code>，将下图所有依赖包的目录导入</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180114/7Al8HAmi0G.png?imageslim" alt="mark"></p><p>【注】<code>/usr/hadoop-2.7.5</code>是Hadoop安装目录</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>新建一个类名为<code>WordCount</code>，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">            <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">                word.set(itr.nextToken());</span><br><span class="line">                context.write(word, one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Context context</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">                sum += val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            result.set(sum);</span><br><span class="line">            context.write(key, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf, <span class="string">"word count"</span>);</span><br><span class="line">        job.setJarByClass(WordCount.class);</span><br><span class="line">        job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">        job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">        job.setReducerClass(IntSumReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h3><p>点击<code>Run-Edit Configuration</code></p><p>点击左上角<code>+</code>，然后点击<code>Application</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180114/0Ee3j1CIaF.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180114/cdaF1d4HKb.png?imageslim" alt="mark"></p><ul><li><p><code>Name</code>，即该运行配置的名字，这里命名为<code>RunHadoop</code></p></li><li><p><code>Main Class</code>，即需要运行的主类，这里使用的默认包，所以填写<code>WordCount</code></p></li><li><p><code>Program arguments</code>，即运行时需要输入的参数，此处填写参数为<code>hdfs://master:9000/data/input/README.txt hdfs://master:9000/output/</code></p><p>此处，第一个参数为输入文件路径，第二个参数为输出文件路径。</p><p><code>master:9000</code>为<a href="https://tianwenyu.github.io/virtualbox-haddop/">分布式Hadoop环境</a>中<code>core-site.xml</code>配置文件中<code>fs.default.name</code>的值</p><p><code>/data/input/README.txt</code>为<a href="https://tianwenyu.github.io/virtualbox-haddop/">分布式Hadoop环境</a>中利用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /data/input</span><br><span class="line">hdfs dfs -put README.txt /data/input</span><br></pre></td></tr></table></figure><p>创建并上传到HDFS系统中的文件路径。</p></li></ul><p>【注】若<code>hdfs://master:9000/output</code>已经存在，需要手动删除</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs dfs -rm -r /output</span><br></pre></td></tr></table></figure><h3 id="查看运行结果"><a href="#查看运行结果" class="headerlink" title="查看运行结果"></a>查看运行结果</h3><h4 id="web界面查看"><a href="#web界面查看" class="headerlink" title="web界面查看"></a>web界面查看</h4><p>通过<code>http://localhost:50070</code>查看各个结点运行状况</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180114/0jfAihfLm7.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此前配置好&lt;a href=&quot;https://tianwenyu.github.io/virtualbox-haddop/&quot;&gt;分布式Hadoop环境&lt;/a&gt;，此篇主要讲解通过Intellij IDEA编写分布式MapReduce程序以及利用Hadoop实现词频统计&lt;/p&gt;
&lt;h2 id=&quot;系统环境&quot;&gt;&lt;a href=&quot;#系统环境&quot; class=&quot;headerlink&quot; title=&quot;系统环境&quot;&gt;&lt;/a&gt;系统环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟机：VirtualBox&lt;/li&gt;
&lt;li&gt;Linux：Ubuntu 16.04 LTS&lt;/li&gt;
&lt;li&gt;Hadoop 2.7.5&lt;/li&gt;
&lt;li&gt;IDE：Intellij IDEA &lt;/li&gt;
&lt;li&gt;JDK 1.8.0_151
    
    </summary>
    
      <category term="Hadoop" scheme="https://tianwenyu.github.io/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://tianwenyu.github.io/tags/Hadoop/"/>
    
      <category term="文本分类" scheme="https://tianwenyu.github.io/tags/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
</feed>
