<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenyu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianwenyu.github.io/"/>
  <updated>2018-05-27T07:13:51.657Z</updated>
  <id>https://tianwenyu.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://tianwenyu.github.io/install-software/"/>
    <id>https://tianwenyu.github.io/install-software/</id>
    <published>2018-05-24T06:49:18.905Z</published>
    <updated>2018-05-27T07:13:51.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h2><ol><li>下载文件</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;lrzsz&quot;&gt;&lt;a href=&quot;#lrzsz&quot; class=&quot;headerlink&quot; title=&quot;lrzsz&quot;&gt;&lt;/a&gt;lrzsz&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;下载文件&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianwenyu.github.io/no-root-install-python/"/>
    <id>https://tianwenyu.github.io/no-root-install-python/</id>
    <published>2018-05-23T03:30:09.516Z</published>
    <updated>2018-05-24T06:48:11.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无Root权限中Ubuntu安装Python"><a href="#无Root权限中Ubuntu安装Python" class="headerlink" title="无Root权限中Ubuntu安装Python"></a>无Root权限中Ubuntu安装Python</h2><p>​                                                                </p><ol><li><p>下载Python</p><p><code>wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz</code></p></li><li><p>解压</p><p><code>tar -xvf Python-3.6.3.tar.zx</code></p></li><li><p>进入到解压后的文件夹</p><p><code>cd Python-3.6.3</code></p></li><li><p><code>./configure --prefix=&#39;Your Install Director&#39;</code></p></li><li><p><code>make &amp;&amp; make install</code></p></li><li><p>添加路径,编辑<code>~/.bashrc</code></p><p><code>vim ~/.bashrc</code></p></li><li><p>在文件最后添加</p><p><code>export PATH=/Your Install Path:$PATH</code>，如<code>export PATH=/usr/local/bin/:$PATH</code></p></li><li><p>创建别名，编辑<code>~/.bashrc</code></p><p><code>vim ~/.bashrc</code></p></li><li><p>在文件最后添加</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> python=<span class="string">'Your python path'</span></span><br><span class="line"><span class="built_in">alias</span> pip=<span class="string">'Your pip path'</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;无Root权限中Ubuntu安装Python&quot;&gt;&lt;a href=&quot;#无Root权限中Ubuntu安装Python&quot; class=&quot;headerlink&quot; title=&quot;无Root权限中Ubuntu安装Python&quot;&gt;&lt;/a&gt;无Root权限中Ubuntu安装Pyth
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Match-LSTM和Pointer Net</title>
    <link href="https://tianwenyu.github.io/match-LSTM-Pointer-Network/"/>
    <id>https://tianwenyu.github.io/match-LSTM-Pointer-Network/</id>
    <published>2018-04-21T11:29:36.000Z</published>
    <updated>2018-07-26T09:12:42.295Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Match-LSTM"><a href="#Match-LSTM" class="headerlink" title="Match-LSTM"></a>Match-LSTM</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Match-LSTM是由(Wang &amp; Jiang,2016)发表在NAACL的论文提出，用于解决NLI(Natural Language Inference，文本蕴含)问题。</p><ul><li>premise：前提，代表上下文</li><li>hypothesis：假设，代表一个陈述性的结论</li></ul><p>文本蕴含问题：给定一个premise（前提），根据这个premise去判断相应的hypothesis（假说）正确与否，如果从这个premise中能够推断出这个hypothesis，那么就判断为entailment（蕴含），否则就是contradiction（矛盾）。</p><h3 id="Word-by-Word-Attention"><a href="#Word-by-Word-Attention" class="headerlink" title="Word-by-Word Attention"></a>Word-by-Word Attention</h3><p>Match-LSTM是在<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1509.06664v4.pdf" target="_blank" rel="external">Rocktaschel et al. (2015)</a>提出的word-by-word attention的基础上进行了改进，先解释一下<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1509.06664v4.pdf" target="_blank" rel="external">Rocktaschel et al. (2015)</a>提出的基本模型</p><p><img src="https://pic2.zhimg.com/80/v2-c68ed27c07068dde4cec33536b7a7483_hd.jpg" alt=""></p><ol><li><p>用LSTM处理premise和hypothesis，(用premise的最后一个输出初始化hypothesis的LSTM)，得到它们的隐层输出。</p><p>其中，</p><ul><li>$h_j^s(1 \le j \le M )$是premise的输入序列经过LSTM之后得到的隐层输出。</li><li>$h_{k}^{t}(1\leq k\leq N)$是hypothesis的隐层输出向量。</li></ul></li><li><p>word-by-word attention的意思是为每个hypothesis中的词引入一个$a<em>k$,用于表示hypothesis，并称这个$a</em>{k}$向量为attention向量，具体公式如下：</p><p><img src="https://pic2.zhimg.com/80/v2-fd900634c4ca508000bc3417510607a7_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-56ad976ad61547379fda615ab5d1e48a_hd.jpg" alt=""></p><p>这里的attention权重$a_{kj}$表示hypothesis中第k个词和premise中第j个词之间的关系。</p><p><img src="https://pic1.zhimg.com/80/v2-93d0014aa6014648937ebc8178dc116c_hd.jpg" alt=""></p><p>$h<em>j^s$是premise的隐层输出，$h</em>{k}^{t} $是hypothesis的隐层输出，$h_{k-1}^a$是将输入一个RNN之后得到的隐层状态。</p><p><img src="https://pic3.zhimg.com/80/v2-50376b2b9618bd48be0f0a3cf30a85bc_hd.jpg" alt=""></p></li><li><p>最后利用$h_N^a$和$h_N^t$来预测label：<code>y</code>，即判断premise和hypothesis之间的关系。</p></li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p>用两个LSTM处理premise和hypothesis序列。得到两个隐状态$h^s$和$h^t$(s对应前提，t对应假设)。</p></li><li><p>用下面的公式计算注意力向量$a_k$,这里计算得到的$e$经过归一化和加权求和得到假设$h^t$对前提$h^s$在每个时刻的注意力向量$a_k$</p><p><img src="http://7xpqrs.com1.z0.glb.clouddn.com/FlgZlpVvlxyB5yFCsBr7QxGM8wSr" alt=""></p></li><li><p>上式中$h^m$的计算，用下面的公式计算，其中输入$m_k$是$[a_k,h_k^t]$的拼接。作者把这个结构称为<code>mLSTM</code>，把最后时刻的$h^m$作为输出以预测label。</p><p><img src="http://7xpqrs.com1.z0.glb.clouddn.com/Flel3Uqro1-XL15roShCUDOZkjdN" alt=""></p><p><img src="http://7xpqrs.com1.z0.glb.clouddn.com/FuuDW11Xv4QZGQA0p5Vb73F1rg4T" alt="img"></p><p>​</p></li></ol><h3 id="与Word-to-Word-Attention区别"><a href="#与Word-to-Word-Attention区别" class="headerlink" title="与Word-to-Word Attention区别"></a>与Word-to-Word Attention区别</h3><p><img src="https://pic2.zhimg.com/80/v2-4ffe801c5ac84e0e6df78e2d5d1a3604_hd.jpg" alt=""></p><p>两者的主要区别就是计算$e_{kj}$的不同。</p><ul><li><p>这里用$h^m$代替了$h^a$。</p><ul><li>之前的$h^m$是利用RNN得到的,$h^a$是用mLSTM得到的。</li></ul></li><li><p>为了得到premise跟hypothesis之间的matching关系，用LSTM对它们进行建模，作者认为LSTM能够将premise和hypothesis之间重要的match关系进行保留，忽略不重要的match关系。具体公式如下:</p><p><img src="https://pic4.zhimg.com/80/v2-6f254b9b14818e07b56a3ebe580f5a8e_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-3fac4a65dab1694d335b224a7055c3b6_hd.jpg" alt=""></p></li><li><p>最后利用$h_N^m$来预测。</p></li></ul><h2 id="Pointer-Net"><a href="#Pointer-Net" class="headerlink" title="Pointer Net"></a>Pointer Net</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Pointer Network是Vinyals et al.(2015)在NIPS发表的论文中提出的，是为了实现从输入序列中找到相应的tokens来作为输出，其他的阅读理解任务中，可能只需要用输入序列构建一个词典，再从这个候选词典中找到概率最大的一个词作为答案，然而SQuAD数据集的输出答案的长度是变化的，因而无法采用构建词典的方式，而pointer net是利用attention作为pointer，从输入序列中选择一个位置，并将这个位置所指向的词作为输出。对pointer net有兴趣的话，可以参看这个链接进行学习:<a href="https://link.zhihu.com/?target=https%3A//github.com/vshallc/PtrNets" target="_blank" rel="external">Pointer net</a>。AS-Reader、AoA-Reader和R-Net等模型都用了PtrNet作为输出层的结构。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="https://pic1.zhimg.com/80/v2-6731208d9422796f5a798d012472401b_hd.jpg" alt=""></p><p>论文中提出了两个模型，且都包含以下三个部分：</p><ul><li>用LSTM对question和passage进行预处理。</li><li>用match-LSTM对question和passage进行match。</li><li>利用Pointer Net从passage中选择tokens作为答案。</li></ul><p>两个模型的区别在于在于第三部分，由于pointer net没有限定所指向的位置必须是连续的，所以第一个模型sequence model直接将答案在passage中出现的位置序号作为答案序列$a=\left( a<em>{1} ,a</em>{2},… \right) $，第二个模型只预测答案的起始位置跟终止位置，即$a=\left(a<em>{s} ,a</em>{e} \right)$。</p><h4 id="LSTM-Preprocessing-Layer"><a href="#LSTM-Preprocessing-Layer" class="headerlink" title="LSTM Preprocessing Layer"></a>LSTM Preprocessing Layer</h4><p>用单向LSTM对passage和question进行预处理。</p><p><img src="https://pic1.zhimg.com/80/v2-271396c88c56d0ad43a7ad7d9640f0c3_hd.jpg" alt=""></p><h4 id="Match-LSTM-Layer"><a href="#Match-LSTM-Layer" class="headerlink" title="Match-LSTM Layer"></a>Match-LSTM Layer</h4><p>这里将question当做premise，将passage当做hypothesis，用标准的word-by-word attention得到attention向量，具体公式如下：</p><p><img src="https://pic1.zhimg.com/80/v2-3e8bac3a6b2d529dfbe82590e4703891_hd.jpg" alt=""></p><p>其中，</p><ul><li><p>$\vec{h}_{i-1}^r \in R^l$是经过单向m-LSTM得到的隐层输出。</p></li><li><p>$\vec{\alpha_{i,j}}$表示passage中的第i个词和question中的第j个词之间的匹配关系。然后用$\overline{\alpha}$对question的隐层输出进行加权，并将其跟passage的隐层输出进行拼接，得到一个新的向量，并输入到m-LSTM中，得到$\bar{H^r}$，具体公式如下：</p><p><img src="https://pic4.zhimg.com/80/v2-ef8069071be26c461f41eafe93af2aaf_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-1cf8251dbb311515d91a0cb33fb172d2_hd.jpg" alt=""></p></li></ul><p>再从另一个方向进行相同的处理,将两者进行合并，得到最后的输出向量$H^{r} $</p><p><img src="https://pic1.zhimg.com/80/v2-22189154aed842755d555b82574efd48_hd.jpg" alt=""></p><h4 id="Answer-Pointer-Layer"><a href="#Answer-Pointer-Layer" class="headerlink" title="Answer Pointer Layer"></a>Answer Pointer Layer</h4><h5 id="The-Sequence-Model"><a href="#The-Sequence-Model" class="headerlink" title="The Sequence Model"></a>The Sequence Model</h5><ul><li><p>由于这个模型是生成答案的位置序列$a=(a<em>{1} ,a</em>{2},…)$，每个元素表示的是这个词在passage中位置，其取值范围在1到P+1之间，当出现了P+1时，则答案生成终止。因此在$H^{r}$的最后中加入了一列0向量，用来表示终止词，得到$\bar{H} ^{r} $。</p></li><li><p>这里再次用到了attention方法去得到向量$\beta<em>k \in R^{(P+1)}$,$\beta</em>{k,j}$表示选择passage中的第j个词作为答案序列的第k个词的概率，$\beta_{k,(P+1)}$表示在第k个位置停止答案生成的概率。公式如下：</p><p><img src="https://pic4.zhimg.com/80/v2-2010c06cc5cad2250298cc5b71688894_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-931cc26fa9a20fc88235e34d2581c62e_hd.jpg" alt=""></p><p>其中，$h_k^a$也是经过一个LSTM的输出。</p></li><li><p>模型生成答案的概率公式如下：</p><p><img src="https://pic4.zhimg.com/80/v2-9fa21cef108ce36bfc461e926500ab2f_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-0e2151f9ed41efec99f58ec9720be311_hd.jpg" alt=""></p></li><li><p>损失函数如下：</p><p><img src="https://pic2.zhimg.com/80/v2-dd3069b97a3681cd81041742f4d65fd3_hd.jpg" alt=""></p></li></ul><h5 id="The-Boundary-Model"><a href="#The-Boundary-Model" class="headerlink" title="The Boundary Model"></a>The Boundary Model</h5><p>因为boundary model只需要生成答案的起始和终止位置，因此不用在<img src="https://www.zhihu.com/equation?tex=H%5E%7Br%7D+" alt="H^{r} ">最后加入一个零向量来表示答案生成结束。生成答案序列的概率模型如下：</p><p><img src="https://pic3.zhimg.com/80/v2-4c644369e011e52315d583b5f90a8a4b_hd.jpg" alt=""></p><p>其余部分与上个模型相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Match-LSTM&quot;&gt;&lt;a href=&quot;#Match-LSTM&quot; class=&quot;headerlink&quot; title=&quot;Match-LSTM&quot;&gt;&lt;/a&gt;Match-LSTM&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; cl
      
    
    </summary>
    
      <category term="NLP" scheme="https://tianwenyu.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://tianwenyu.github.io/tags/NLP/"/>
    
      <category term="阅读理解" scheme="https://tianwenyu.github.io/tags/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>任务型多轮对话系统概述</title>
    <link href="https://tianwenyu.github.io/task-oriented-dialog-system/"/>
    <id>https://tianwenyu.github.io/task-oriented-dialog-system/</id>
    <published>2018-04-20T11:29:36.000Z</published>
    <updated>2018-07-22T06:40:51.369Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><p>任务型机器人核心模块主要包括三个模块：</p><ul><li>自然语言理解模块（NLU）</li><li>对话管理模块</li><li>自然语言生成模块（NLG）</li></ul><p><img src="https://pic1.zhimg.com/80/v2-b70539cc9a32d7f2711a086f0fbbda4f_hd.jpg" alt="img"></p><h3 id="自然语言理解模块"><a href="#自然语言理解模块" class="headerlink" title="自然语言理解模块"></a>自然语言理解模块</h3><p>该模块一般包含以下三个模块：</p><ul><li>领域识别：即识别该语句是不是属于这个任务场景，一般有多个机器人集成时，如闲聊机器人，问答机器人等，领域识别应当在进入任务型机器人之前做判断与分发</li><li>意图识别：即识别用户意图，细分该任务型场景下的子场景、</li><li>语义槽填充：用于对话管理模块的输入</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设Text=“人民币对美元的汇率是多少”；经过自然语言理解模块会解析为 act ( slot1 = value1, slot2 = value2 ……) 的形式，即意图，槽位，槽位信息三元组形式，即 Text会解析为“查询（槽位1=人民币，槽位2=美元)”这样的形式。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="基于规则理解方法"><a href="#基于规则理解方法" class="headerlink" title="基于规则理解方法"></a>基于规则理解方法</h5><p>【优点】</p><ul><li>不需要大量训练数据</li></ul><p>【缺点】</p><ul><li>容易出错</li><li>调整规则费时费力，难以维护</li></ul><h5 id="统计方法（对齐）"><a href="#统计方法（对齐）" class="headerlink" title="统计方法（对齐）"></a>统计方法（对齐）</h5><p>基于词对齐数据的自然语言理解通常被看做一个序列标注问题。主要有以下两类方法：</p><ul><li>基于生成式模型<ul><li>随机有限状态机（FST）</li><li>统计机器翻译（SMT）</li><li>动态贝叶斯网络（DBN）</li></ul></li><li>基于判别式模型<ul><li>CRF</li><li>SVM</li><li>MEMM</li></ul></li></ul><h5 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h5><ul><li>BiLSTM+CRF</li><li>CNN：用于序列标注</li><li>Seq2Seq</li></ul><h3 id="对话管理模块"><a href="#对话管理模块" class="headerlink" title="对话管理模块"></a>对话管理模块</h3><p>自然语言理解模块的三元组输出将作为对话管理系统的输入。它主要包括两部分：</p><ul><li>状态追踪模块</li><li>对话策略模块</li></ul><p>【状态追踪模块】</p><p>该模块在对话的每一轮次对用户的目标进行预估，管理每个回合的输入和对话历史，输出当前对话状态。</p><p><img src="https://pic1.zhimg.com/80/v2-b08e6cd63a89448e47f4576ae3603067_hd.jpg" alt="img"></p><p>【对话策略模块】</p><p>该模块的主要功能是根据前面的对话状态决策采取的最优动作（如：提供结果，询问特定限制条件，澄清或确认需求等）从而最有效的辅助用户完成信息或服务获取的任务。该模块基于用户输入的语义表达和当前对话状态输出下一步的系统行为和更新的对话状态。</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>text=“人民币对美元的汇率是多少”。“查询（槽位1=人民币，槽位2=美元)”这样的形式将作为对话管理模块的输入，这时候状态追踪模块就要根据前几轮的信息，结合该输入判断该轮的查询状态，确定查询的槽位，以及与数据库的交互。如得到想要查询的确实是人民币对美元的汇率信息。这时候，根据现有的对话策略判断当前的槽位状态，最后给出对话管理模块的输出，如查询结果(源货币=人民币，目标货币=美元，汇率=1:0.16)</p><h3 id="自然语言生成模块"><a href="#自然语言生成模块" class="headerlink" title="自然语言生成模块"></a>自然语言生成模块</h3><p>该模块主要任务是将对话策略输出的语义表达生成流畅可读的自然语言句子，反馈给用户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;主要模块&quot;&gt;&lt;a href=&quot;#主要模块&quot; class=&quot;headerlink&quot; title=&quot;主要模块&quot;&gt;&lt;/a&gt;主要模块&lt;/h2&gt;&lt;p&gt;任务型机器人核心模块主要包括三个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然语言理解模块（NLU）&lt;/l
      
    
    </summary>
    
      <category term="NLP" scheme="https://tianwenyu.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://tianwenyu.github.io/tags/NLP/"/>
    
      <category term="多轮对话" scheme="https://tianwenyu.github.io/tags/%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianwenyu.github.io/interview/"/>
    <id>https://tianwenyu.github.io/interview/</id>
    <published>2018-04-18T01:55:12.166Z</published>
    <updated>2018-04-26T16:09:16.683Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://images2015.cnblogs.com/blog/739525/201605/739525-20160503202729044-614991035.jpg" alt="img"></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h3 id="深拷贝与浅拷贝的区别"><a href="#深拷贝与浅拷贝的区别" class="headerlink" title="深拷贝与浅拷贝的区别"></a>深拷贝与浅拷贝的区别</h3><h4 id="Java8改进"><a href="#Java8改进" class="headerlink" title="Java8改进"></a>Java8改进</h4><ul><li>Lambda表达式——为多核处理器编写代码</li><li>Nashorn引擎——使得Java程序和JavaScript代码互相操作</li><li>新日期API</li><li>GC改进</li><li>并发改进</li></ul><h4 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals()和==的区别"></a>equals()和==的区别</h4><table><thead><tr><th>equals()</th><th>==</th></tr></thead><tbody><tr><td>是方法</td><td>是操作符</td></tr><tr><td>判断两个变量指向的内存空间的值是否相等</td><td>用于判断两个变量是否指向同一个内存空间</td></tr><tr><td>对字符串内容进行比较</td><td>对内存地址进行比较</td></tr><tr><td>判断值是否相等</td><td>判断引用是否相同</td></tr></tbody></table><h4 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a>HashTable和HashMap区别</h4><table><thead><tr><th>HashTable</th><th>HashMap</th></tr></thead><tbody><tr><td>线程安全</td><td>线程不安全</td></tr><tr><td>不允许有null键和null值</td><td>允许有一个null键和多个null值</td></tr><tr><td>HashTable直接使用对象的HashCode。<br>HashCode是JDK根据对象的地址或字符串或数字算出来的int类型的数值。</td><td>HashMap重新计算Hash值。</td></tr><tr><td></td><td>单线程下HashMap速度较快</td></tr></tbody></table><h4 id="HashMap与HashSet区别"><a href="#HashMap与HashSet区别" class="headerlink" title="HashMap与HashSet区别"></a>HashMap与HashSet区别</h4><table><thead><tr><th style="text-align:left">HashMap</th><th style="text-align:left">HashSet</th></tr></thead><tbody><tr><td style="text-align:left">实现了Map接口</td><td style="text-align:left">实现Set接口</td></tr><tr><td style="text-align:left">存储键值对</td><td style="text-align:left">存储对象</td></tr><tr><td style="text-align:left">使用put()方法将元素放入map中</td><td style="text-align:left">使用add()方法将元素放入set中</td></tr><tr><td style="text-align:left">使用键对象计算HashCode值</td><td style="text-align:left">使用成员对象计算HashCode值。<br>对于两个对象来说HashCode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，返回fasle</td></tr><tr><td style="text-align:left">相对HashSet速度比较快因为是使用唯一的键来获取对象</td><td style="text-align:left">相对HashMap速度较慢</td></tr></tbody></table><h4 id="HashMap实现"><a href="#HashMap实现" class="headerlink" title="HashMap实现"></a>HashMap实现</h4><ul><li><p>结构实现</p><p>Hash Map是数组+链表+红黑树实现的（链表长度大于8时，转为红黑树）。</p><p>HashMap类中有一个非常重要的字段，是<code>Node[] table</code>,即哈希桶数组。Node是HashMap中的一个内部类，本质是一个映射（键值对）。如果哈希桶数组很大，即使很差的Hash算法也会比较分散。</p><p>HashMap是使用哈希表存储的，使用链地址法解决冲突。即数组+链表，每个数组元素上有一个链表结构，当数据被Hash以后，得到数组下标，把数据放在对应下表元素的链表上。</p></li><li><p>功能实现</p><ul><li><p>根据key获取哈希桶数组索引位置</p><p>定位到哈希桶数组的位置是所有操作的第一步。</p><ol><li><p>取key的HashCode值</p><p><code>h=key.hashcode() //取hashcode值</code></p></li><li><p>高位运算</p><p><code>h^(h&gt;&gt;&gt;16) //高位参与运算</code> </p></li><li><p>取模运算</p><p><code>h&amp;(length-1) //取模运算，使用&amp;比%效率高</code></p></li></ol></li><li><p>扩容过程</p><p>扩容的方法就是使用一个容量更大的数组代替已有的容量小的数组，然后将原有的数组元素复制到新的数组中。</p><p>JDK 1.8使用的是2次幂的扩展（即长度扩展为原来的2倍），所以元素位置是原位置或原位置移动2次幂的位置。</p><p>因此，在扩充hashmap时，不需要像jdk1.7重新计算hash，而是看新增的1bit位是0还是1，节省了时间。</p><p>jdk1.7扩充时，旧链表迁移到新链表时，如果新表的数组索引位置相同，则链表元素会倒置，jdk1.8不会。</p></li></ul></li><li><p>HashMap的几个字段</p><ul><li><p><code>length</code>：<code>Node[] table</code>的初始化长度，默认值16</p></li><li><p><code>loadfactor</code>：负载因子，默认值0.75</p></li><li><p><code>threshold</code>：HashMap所能容纳的最大数据量的Node（键值对）的个数。</p><p><code>threshold=length*loadfactor</code>，即定义好数组长度后，负载因子越大，所能容纳的键值对个数越多</p></li><li><p><code>size</code>：HashMap中实际存在的键值对数量</p></li></ul><p>【注】</p><p>数据结构Hash算法中负载因子的计算<code>α=填入表中的记录个数/散列表的长度</code>。</p><p>常见Hash函数：</p><ul><li>直接定址法：h(key)=a*key+b</li><li>除留余数法：h(key)=key mod p</li></ul></li></ul><h4 id="HashTable的线程安全如何实现？"><a href="#HashTable的线程安全如何实现？" class="headerlink" title="HashTable的线程安全如何实现？"></a>HashTable的线程安全如何实现？</h4><h4 id="两个对象的HashCode相同会发生什么？"><a href="#两个对象的HashCode相同会发生什么？" class="headerlink" title="两个对象的HashCode相同会发生什么？"></a>两个对象的HashCode相同会发生什么？</h4><p>会发生碰撞，会存储在同一个位置的LinkedList中，键对象的equals()方法用来找到键值对。</p><h4 id="如何让HashMap同步？"><a href="#如何让HashMap同步？" class="headerlink" title="如何让HashMap同步？"></a>如何让HashMap同步？</h4><p>使用Collections内部的SynchronizedMap类。</p><h4 id="Java实现多线程的四种方式"><a href="#Java实现多线程的四种方式" class="headerlink" title="Java实现多线程的四种方式"></a>Java实现多线程的四种方式</h4><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口通过FutureTask包装器创建Thread线程</li><li>实现ExecutorService、Callable、Future接口</li></ul><h4 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h4><h4 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h4><p>避免频繁地创建和销毁线程，达到线程对象的重用，使用线程池可以根据项目灵活控制并发的数目。</p><h4 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h4><p>【乐观锁】</p><p>对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>【悲观锁】</p><p>对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h4 id="Lambda表达式优缺点"><a href="#Lambda表达式优缺点" class="headerlink" title="Lambda表达式优缺点"></a>Lambda表达式优缺点</h4><p>【优点】</p><ul><li>简洁</li><li>容易进行并行计算</li></ul><h4 id="Java运行过程"><a href="#Java运行过程" class="headerlink" title="Java运行过程"></a>Java运行过程</h4><p>Java源文件（.java文件）–&gt;Java编译器–&gt;字节码文件(.class文件)–&gt;类装载器–&gt;字节码校验器–&gt;解释器–&gt;操作系统整个文件Load到内存区，操作系统找到main()方法开始执行。</p><h4 id="JNI使用步骤"><a href="#JNI使用步骤" class="headerlink" title="JNI使用步骤"></a>JNI使用步骤</h4><ol><li>在Java类中声明Native方法，并编译成class文件。</li><li>用javah，将上步中的class文件生成头文件。</li><li>用其他语言实现上述头文件的函数，生成动态库，供Java使用</li><li>发布Java和动态库。</li></ol><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM原理"><a href="#JVM原理" class="headerlink" title="JVM原理"></a>JVM原理</h4><p>操作系统装入JVM是通过JDK中Java.exe来完成，通过以下四个步骤完成JVM环境：</p><ol><li>创建JVM装载环境和配置</li><li>装在JVM.dll</li><li>初始化JVM.dll并挂载到JNI调用接口实例。</li><li>调用JNI实例装载并处理class类。</li></ol><h4 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h4><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180418/GBiC3KEjI7.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180418/64FaFbGjEe.png?imageslim" alt="mark"></p><p><img src="https://upload-images.jianshu.io/upload_images/3028880-f8c942cc5f5e0277?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p><ul><li><p>程序计数器</p><ul><li><p>作用：当前线程所执行的字节码的行号指示器。</p><p>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要这个计数器来完成。</p><p>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。在一个确定的时刻，一个cpu只会执行一条县城中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响 ，称这类内存区域是线程私有内存</strong>。</p><p>​</p></li><li><p>程序计数器用来记录一个线程的行号，字节码解释器在工作时，通过改变计数器的值取下一条语句指令。</p><ul><li><p>程序计数器线程私有。一个线程有一个程序计数器。</p></li><li><p>在线程创建时创建，指向下一条指令的地址。</p></li><li><p>程序计数器是唯一一个在Java虚拟机中没有规定<code>OutOfMemoryError</code>的区域。</p></li><li><p>如果一个线程执行的是Java方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址。</p><p>如果执行的是Native方法，则计数器值为空。</p></li></ul></li></ul></li><li><p>Java虚拟机栈</p><ul><li><p>线程私有。</p></li><li><p>生命周期与线程相同。</p></li><li><p>栈由一系列帧组成。因此Java栈也叫做帧栈。</p></li><li><p>帧保存一个方法的局部变量、操作数栈、常量池指针。</p></li><li><p>每个方法被执行时同时创建一个栈帧，并压栈，用于存储局部变量、操作栈、动态连接、方法出口等信息。</p><p>每一个方法被调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>对Java栈定义了两种异常：</p><ul><li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机允许的深度</li><li><code>OutOfMemoryError</code>：栈扩展时无法申请到足够内存</li></ul></li></ul></li><li><p>本地方法栈</p><ul><li>为虚拟机使用到的Native方法服务。</li><li>两种异常：<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。</li></ul></li><li><p>Java堆</p><ul><li>所有线程共享Java堆</li><li>在虚拟机启动时创建</li><li>所有对象实例及数组都分配在堆上。</li><li>堆是GC管理的主要区域</li><li><code>OutOfMemory</code>：如果堆中没有内存完成对象实例分配，且堆也无法扩展时抛出该异常。</li></ul></li><li><p>方法区</p><ul><li>所有线程共享方法区。</li><li>存储已被虚拟机加载的类信息、常量、静态变量等。</li></ul></li></ul><h4 id="本地方法栈和Java虚拟机栈区别"><a href="#本地方法栈和Java虚拟机栈区别" class="headerlink" title="本地方法栈和Java虚拟机栈区别"></a>本地方法栈和Java虚拟机栈区别</h4><ul><li>本地方法栈为虚拟机使用到的Native方法服务</li><li>虚拟机栈为虚拟机执行的Java方法服务</li></ul><p>【注】有的虚拟机（如Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一。</p><h4 id="Java内存分配机制"><a href="#Java内存分配机制" class="headerlink" title="Java内存分配机制"></a>Java内存分配机制</h4><ul><li>指在堆上的分配</li><li>分代分配</li></ul><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180418/b0i6Gf1210.png?imageslim" alt="mark"></p><ul><li><p>Eden区是连续的空间，且Survivor区总有一个为空。</p></li><li><p>在Eden区，HotSpot使用两种技术加快内存分配</p><ul><li><p><code>bump-the-pointer</code>：由于Eden区是连续的，因此<code>bump-the-pointer</code>就是跟踪最后一个创建的对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可。</p></li><li><p><code>TLAB(Thread-Local Allocation Buffers)</code>，针对多线程而言，将Eden区分为若干段，每个线程使用独立的一段，避免互相影响。</p><p>TLAB结合<code>bump-the-pointer</code>，保证每个线程都使用Eden区的一段，并快速分配内存。</p></li></ul></li></ul><h4 id="Java内存回收机制"><a href="#Java内存回收机制" class="headerlink" title="Java内存回收机制"></a>Java内存回收机制</h4><ul><li><p>分代分配</p></li><li><p>分配算法</p><ul><li><p>新生代：<code>复制</code>算法</p><p>将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p></li><li><p>老年代：<code>标记-整理</code>算法</p><p>标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p></li></ul></li></ul><h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><ul><li><p>标记-清除算法</p><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>【缺点】：</p><ul><li>效率低</li><li>会产生大量的内存碎片。</li></ul></li><li><p>复制算法</p><p>将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉。</p><p>【缺点】</p><ul><li>浪费一半的内存空间</li><li>若对象的存活率很高，需要将所有存活的对象复制一遍，效率低。</li></ul></li><li><p>标记-整理算法</p><p>标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。</p><p>【缺点】</p><ul><li>效率不高</li></ul></li></ul><p>【总结】</p><ul><li>效率：复制算法&gt;标记-整理算法&gt;标记-清除算法</li><li>内存整齐率：复制算法&gt;标记-整理算法&gt;标记-清除算法</li><li>内存利用率：标记-整理算法=标记-清除算法&gt;复制算法</li></ul><h4 id="Java8-JVM-CG改进"><a href="#Java8-JVM-CG改进" class="headerlink" title="Java8 JVM/CG改进"></a>Java8 JVM/CG改进</h4><ul><li>Java8中无持久代，被替换为<code>元空间</code>。</li><li>移除一些很少使用的GC组合</li></ul><h4 id="什么是元空间（Metaspace）？"><a href="#什么是元空间（Metaspace）？" class="headerlink" title="什么是元空间（Metaspace）？"></a>什么是元空间（Metaspace）？</h4><p>JDK8的HotSpot JVM移除永久代，使用本地内存来存储类的元数据（即一些描述性信息）的区域称为元空间。</p><p>【特点】</p><ul><li>类及相关的元数据的生命周期与类加载器一致</li><li>每个加载器有专门的存储空间</li><li>省去GC扫描及压缩的时间</li><li>不会单独回收某个类</li></ul><h4 id="为什么移除永久代（PermGen），添加元空间（Metaspace）？"><a href="#为什么移除永久代（PermGen），添加元空间（Metaspace）？" class="headerlink" title="为什么移除永久代（PermGen），添加元空间（Metaspace）？"></a>为什么移除永久代（PermGen），添加元空间（Metaspace）？</h4><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出</li><li>类及方法的信息等比较难确定大小，因此对永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易导致老年代溢出</li><li>永久代为GC带来不必要的复杂度，并且回收效率偏低。</li></ol><h4 id="了解JVM参数设置么，频繁出现GC怎么办？"><a href="#了解JVM参数设置么，频繁出现GC怎么办？" class="headerlink" title="了解JVM参数设置么，频繁出现GC怎么办？"></a>了解JVM参数设置么，频繁出现GC怎么办？</h4><p>频繁GC原因：</p><ul><li><p>人为原因</p><p>在代码中调用System.gc()或者Runtime.gc()方法。</p><p>System.gc()方法的调用是建议JVM进行Full GC，增加了Full GC的频率，即增加了间歇性停顿的次数。通过<code>-XX:DisableExplicitGC</code>禁止RMI调用System.gc()。</p></li><li><p>框架原因</p><p>在java程序调用相关框架时，框架内部调用了GC方法</p></li><li><p>内存原因</p><p>当Heap大小设置比较小时，会频繁引起GC。因此在Spark这样对内存性能要求比较高的应用程序运行时，可以分配给Heap较大的内存，减少频繁GC。</p></li></ul><p>【参考】</p><p><a href="https://blog.csdn.net/sinat_25306771/article/details/52258417" target="_blank" rel="external">JVM GC与频繁GC</a></p><p><a href="https://blog.csdn.net/lovetea99/article/details/52588281" target="_blank" rel="external">JVM频繁Full GC的情况及应对策略</a></p><h4 id="如何调整内存中新生代和老年代的内存大小？"><a href="#如何调整内存中新生代和老年代的内存大小？" class="headerlink" title="如何调整内存中新生代和老年代的内存大小？"></a>如何调整内存中新生代和老年代的内存大小？</h4><p>可以在JVM参数中设置 </p><ul><li><code>-XX:NewSize=n</code>：设置年轻代大小</li><li><code>-XX:NewRatio=n</code>：设置年轻代和老年代的比值，默认是1：2</li><li><code>-XX:SurvivorRatio</code>：设置Eden和From Survivor、To Survivor区比例。默认为8，即8:1:1。</li><li><code>-Xms</code>：初始堆大小</li><li><code>-Xmx</code>：最大堆大小</li></ul><p>【参考】</p><p><a href="https://my.oschina.net/sunnywu/blog/332870" target="_blank" rel="external">java 虚拟机–新生代与老年代GC</a></p><h4 id="GC和Full-GC有什么区别？"><a href="#GC和Full-GC有什么区别？" class="headerlink" title="GC和Full GC有什么区别？"></a>GC和Full GC有什么区别？</h4><ul><li>GC（Minor GC）：发生在新生代的GC，采用<code>复制</code>算法</li><li>Full GC（Major GC）：发生在老年代，采用<code>标记-整理</code>算法</li></ul><h4 id="Minor-GC后，Eden是空的么？"><a href="#Minor-GC后，Eden是空的么？" class="headerlink" title="Minor GC后，Eden是空的么？"></a>Minor GC后，Eden是空的么？</h4><p>是，Minor GC后会把Eden中所有的活的对象移动到Survivor区域中，如果Survivor区中放不下，则剩下的活的对象被移动到Old Generation中。</p><h4 id="如何判断一个对象是否存活？"><a href="#如何判断一个对象是否存活？" class="headerlink" title="如何判断一个对象是否存活？"></a>如何判断一个对象是否存活？</h4><ol><li>引用计数法</li><li>可达性算法（引用链法）</li></ol><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h4 id="什么是Map-Reduce"><a href="#什么是Map-Reduce" class="headerlink" title="什么是Map-Reduce"></a>什么是<code>Map-Reduce</code></h4><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><h4 id="Spark与Hadoop区别"><a href="#Spark与Hadoop区别" class="headerlink" title="Spark与Hadoop区别"></a>Spark与Hadoop区别</h4><p>【共同点】</p><ul><li>两者都是基于<code>Map-Reduce</code>模型来进行并行计算</li></ul><p>【区别】</p><ul><li><p>Hadoop有四个主要模块：Hadoop Common、HDFS、Hadoop YARN、Hadoop MapReduce。</p><p>Spark本身没有提供分布式文件系统，因此Spark的分析大多依赖于Hadoop的HDFS。</p></li><li><p>Hadoop的一个作业称为job，job里面分为<code>map task</code>和<code>reduce task</code>，每个<code>task</code>都是在自己的进程中运行的，当<code>task</code>结束，进程也会结束。</p><p>Spark提交的任务成为<code>application</code>，一个<code>application</code>对应一个<code>sparkcontext</code>，<code>application</code>中存在多个<code>job</code>，每触发一次<code>action</code>操作就会产生一个<code>job</code>。</p></li></ul><h4 id="Spark运行流程"><a href="#Spark运行流程" class="headerlink" title="Spark运行流程"></a>Spark运行流程</h4><p><img src="https://images2015.cnblogs.com/blog/1004194/201608/1004194-20160830094200918-1846127221.png" alt="img"></p><ol><li>构建Spark Application的运行环境，启动SparkContext</li><li>SparkContext向资源管理器申请运行Executor资源，并启动StandaloneExecutorbackend</li><li>Executor向SparkContext申请Task</li><li>SparkContext将应用程序分发给Executor</li><li>SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行</li><li>Task在Executor上运行，运行完释放所有资源。</li></ol><h4 id="Spark框架基本组件"><a href="#Spark框架基本组件" class="headerlink" title="Spark框架基本组件"></a>Spark框架基本组件</h4><ul><li><p>Driver</p><p>【作用】运行<code>Application</code>的main函数并创建<code>SparkContext</code>。</p><p>创建<code>SparkContext</code>的目的是为了准备Spark应用程序的运行环境，在Spark中有<code>SparkContext</code>负责与<code>ClusterManager</code>通信，进行资源申请、任务分配和监控，当<code>Executor</code>部分运行完毕后，<code>Driver</code>同时负责将<code>SparkContext</code>关闭。</p></li><li><p>Master</p></li><li><p>Worker</p></li><li><p>Executor</p><p>【作用】执行器，在<code>Worker</code>上执行任务的组件、用于启动线程池运行任务。每个<code>Application</code>拥有独立的一组<code>Executor</code>。</p></li><li><p>Task</p><p><code>Application</code>的运行基本单位，<code>Executor</code>上的工作单元，其调度和管理由<code>TaskScheduler</code>负责。</p><p><code>RDD</code>中的一个分区对应一个<code>Task</code>，<code>Task</code>是单个分区上最小的处理流程单元。</p></li></ul><h4 id="Spark中Application各个组件的关系"><a href="#Spark中Application各个组件的关系" class="headerlink" title="Spark中Application各个组件的关系"></a>Spark中<code>Application</code>各个组件的关系</h4><p><img src="https://images2015.cnblogs.com/blog/834652/201706/834652-20170629115027727-1330992206.png" alt="img"></p><ul><li><code>Application</code>：用户编写的Spark应用程序，由一个或多个<code>Job</code>组成，提交到Spark之后，Spark为<code>Application</code>分派资源。</li><li><code>Task</code>：<code>RDD</code>中的一个分区对应一个<code>Task</code>，<code>Task</code>是单个分区上最小的处理流程单元。</li><li><code>TaskSet</code>：一组关联的，但相互之间没有Shuffle依赖关系的Task集合</li><li><code>Stage</code>：由Action算子触发生成的由一个或多个<code>Stage</code>组成的计算作业</li><li><code>DAGScheduler</code>：根据<code>Job</code>构建基于<code>Stage</code>的<code>DAG</code>，并提交<code>Stage</code>给<code>TaskScheduler</code>。</li><li><code>TaskScheduler</code>：将<code>Taskset</code>提交给<code>Worker</code>结点集群运行并返回结果。</li></ul><h4 id="Spark中的RDD"><a href="#Spark中的RDD" class="headerlink" title="Spark中的RDD"></a>Spark中的RDD</h4><ul><li><p>RDD</p><ul><li>RDD：弹性分布式数据集合，是spark的基本数据结构，spark中所有数据都是通过RDD形式组织。逻辑上是一个数据集，物理上以分块分布在不同机器上并发运行。</li><li>它代表一个不可变、可分区、里面的元素可并行计算的集合。</li><li>RDD允许用户在执行多个查询时显式地将工作集缓存在内存中。</li><li>RDD每个分区数据都是只读的</li><li>RDD生命周期：读取或创建RDD，然后对数据进行一系列的转换(transform算子)，保存结果，最后进行处理(action算子)。</li></ul></li><li><p>RDD属性</p><ul><li><p>一组分片（Partition），即数据集的基本组成单位。</p><p>对于RDD来说，每个分片会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，则会采用默认值，默认值即程序所分配到的CPU　Core的数目。</p></li><li><p>一个计算每个分区的函数</p><p>Spark中RDD计算以分片为单位的，每个RDD都会实现compute函数达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。</p></li><li><p>RDD之间的依赖关系</p><p>RDD的每次转换都会生成一个新的RDD，所以RDD之间会形成类似于流水线一样的前后依赖关系，在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。</p></li><li><p>一个Partitioner，即RDD的分片函数</p><p>当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。</p><p>只有对于key-value的RDD，才会有Partitioner，非key-value的RDD的Partitioner的值是None.</p><p>Partitoner函数决定了RDD本身的分片数量，也决定了parent RDD Shuffer输出时的分片数量。</p></li><li><p>一个列表，存储存取每个Partition的优先位置（preferred location）</p><p>对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。</p></li></ul></li><li><p>算子</p><ul><li><p>转换算子(transform)</p><p>不触发提交作业，完成作业中间处理过程。</p><p>分为value类型和key-value类型。</p><p>所有的转换都是惰性的，不会马上计算结果，当action算子执行时，才会计算transform算子。</p></li><li><p>动作算子(action)</p><p>触发<code>SparkContext</code>提交作业，常见的有<code>count</code>、<code>collection</code>。</p></li></ul></li></ul><h4 id="Spark运行模式有几种？"><a href="#Spark运行模式有几种？" class="headerlink" title="Spark运行模式有几种？"></a>Spark运行模式有几种？</h4><ul><li><p>standalone(独立集群运行模式)</p><p>独立模式，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统。</p><p>不使用其他调度工具时会存在单点故障，可使用Zookeeper解决。</p></li><li><p>Spark on YARN</p></li><li><p>Spark on Mesos</p><p>通用集群管理，有<code>粗粒度模式</code>和<code>细粒度模式</code></p></li></ul><h4 id="Spark是多线程模式，怎么退化为多进程模式？"><a href="#Spark是多线程模式，怎么退化为多进程模式？" class="headerlink" title="Spark是多线程模式，怎么退化为多进程模式？"></a>Spark是多线程模式，怎么退化为多进程模式？</h4><p>在每个<code>executor core</code>设置为1，即每个executor为单线程。</p><h4 id="什么是Shuffle-具体过程怎么样，有几种方式？"><a href="#什么是Shuffle-具体过程怎么样，有几种方式？" class="headerlink" title="什么是Shuffle,具体过程怎么样，有几种方式？"></a>什么是Shuffle,具体过程怎么样，有几种方式？</h4><p>【Shuffle】</p><p><code>Shuffle</code>是<code>MapReduce</code>框架中的一个特定的<code>phase</code>，描述数据从<code>Map</code>到<code>Reduce</code>的过程，当<code>Map</code>的输出结果要被<code>Reduce</code>使用时，输出结果按<code>key</code>哈希，并分发到每一个<code>Reducer</code>上。因为<code>Shuffle</code>涉及到磁盘读写和网络传输，因此<code>Shuffle</code>性能的高低直接影响了整个程序性能和吞吐量。</p><p>【过程】</p><p><img src="http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle.png" alt="img"></p><ul><li>首先每一个Mapper会根据Reducer的数量创建出相应的bucket。</li><li>Mapper产生的结果会根据设置的partition算法填充到每个bucket中。默认的partition算法是根据key哈希到不同的<code>bucket</code>中去。</li><li>当Reducer启动时，会根据自己的task的id和所依赖的<code>Mapper</code>的id从远端或本地的<code>block manager</code>获取相应的<code>bucket</code>作为<code>Reducer</code>的输入进行处理。</li></ul><p><code>Shuffle</code>过程的本质是将Map端获得的数据使用partition算法进行划分，并将数据发送给对应的<code>Reducer</code>。</p><h4 id="什么是数据倾斜，如何处理？"><a href="#什么是数据倾斜，如何处理？" class="headerlink" title="什么是数据倾斜，如何处理？"></a>什么是数据倾斜，如何处理？</h4><p>【数据倾斜】</p><p>并行处理的数据集中，有一部分的数据显著多于其它部分，从而使得处理该部分的数据处理速度成为数据集处理的瓶颈。</p><p>【原因】</p><p>常见于各种<code>Shuffle</code>操作，如<code>reduceByKey</code>、<code>groupByKey</code>、<code>join</code>等。</p><ul><li>数据问题<ul><li>key本身分布不均匀（包括大量的key为空）</li><li>key的设置不合理</li></ul></li><li>spark使用问题<ul><li>shuffle时的并发度不够</li><li>计算方式有误</li></ul></li></ul><p>【解决方法】</p><ul><li><p>数据问题造成的数据倾斜</p><ul><li><p>找出异常的key</p><p>如果任务长时间卡在最后几个任务，对key进行抽样分析，判断是哪些key造成的。</p></li></ul></li><li><p>spark使用不当造成的数据倾斜</p><ul><li><p>提高shuffle并行度</p><p><code>dataFrame</code>和<code>sparkSql</code>可以设置<code>spark.sql.shuffle.partition</code>参数控制<code>shuffle</code>的并发度。</p><p><code>RDD</code>操作可以设置<code>spark.default.parallelism</code>控制并发度。</p></li><li><p>使用<code>map join</code>代替<code>reduce join</code></p><p>在小表不是特别大(取决于你的executor大小)的情况下使用，可以使程序避免shuffle的过程，自然也就没有数据倾斜的困扰了。</p></li></ul></li></ul><h4 id="MLlib支持的算法有哪些？"><a href="#MLlib支持的算法有哪些？" class="headerlink" title="MLlib支持的算法有哪些？"></a>MLlib支持的算法有哪些？</h4><p>分类、聚类、回归、协同过滤。</p><h4 id="Spark统计词频程序"><a href="#Spark统计词频程序" class="headerlink" title="Spark统计词频程序"></a>Spark统计词频程序</h4><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><ul><li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li><li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li><li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h4 id="什么是线性回归？"><a href="#什么是线性回归？" class="headerlink" title="什么是线性回归？"></a>什么是线性回归？</h4><p>线性回归的因变量是连续变量，自变量可以是连续变量，也可以是分类变量。</p><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><h4 id="什么是逻辑回归？"><a href="#什么是逻辑回归？" class="headerlink" title="什么是逻辑回归？"></a>什么是逻辑回归？</h4><p><strong>逻辑回归假设数据服从伯努利分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的。</strong></p><p>【基本假设】</p><p>逻辑回归的<strong>第一个</strong>基本假设是<strong>假设数据服从伯努利分布。</strong><br>$$<br>h_\theta\left(x;\theta \right )=\frac{1}{1+e^{-\theta^{T} x}}<br>$$<br>【损失函数】</p><p>逻辑回归的损失函数是它的极大似然函数<br>$$<br>L<em>\theta\left(x\right )= \prod </em>{i=1}^{m}h<em>\theta(x^{i};\theta )^{y{i}}*(1-h</em>\theta(x^{i};\theta))^{1-y^{i}}<br>$$</p><h4 id="为什么逻辑回归的损失函数使用极大似然函数作为损失函数"><a href="#为什么逻辑回归的损失函数使用极大似然函数作为损失函数" class="headerlink" title="为什么逻辑回归的损失函数使用极大似然函数作为损失函数"></a>为什么逻辑回归的损失函数使用极大似然函数作为损失函数</h4><ul><li>损失函数一般有四种，平方损失函数，对数损失函数，HingeLoss0-1损失函数，绝对值损失函数。将极大似然函数取对数以后等同于对数损失函数。在逻辑回归这个模型下，对数损失函数的训练求解参数的速度是比较快的。</li></ul><ul><li>为什么不选平方损失函数的呢？其一是因为如果你使用平方损失函数，你会发现梯度更新的速度和sigmod函数本身的梯度是很相关的。sigmod函数在它在定义域内的梯度都不大于0.25。这样训练会非常的慢。</li></ul><h4 id="为什么在训练过程中将高度相关的特征去掉？"><a href="#为什么在训练过程中将高度相关的特征去掉？" class="headerlink" title="为什么在训练过程中将高度相关的特征去掉？"></a>为什么在训练过程中将高度相关的特征去掉？</h4><ul><li>去掉高度相关的特征会让模型的可解释性更好</li><li>可以大大提高训练的速度。如果模型当中有很多特征高度相关的话，就算损失函数本身收敛了，但实际上参数是没有收敛的，这样会拉低训练的速度。其次是特征多了，本身就会增大训练的时间。</li></ul><h4 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h4><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h4 id="中文特点"><a href="#中文特点" class="headerlink" title="中文特点"></a>中文特点</h4><ul><li>汉语是大字符集的意音文字</li><li>词与词之间没有空格</li><li>同义、同音词多</li><li>没有形态变化</li></ul><h4 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h4><ul><li><p>基于字符串匹配的分词方法</p><p>按照<strong>一定的策略</strong>将<strong>待分析的汉字串</strong>与一个“<strong>充分大的”机器词典</strong>中的词条进行配，<strong>若在词典中找到某个字符串</strong>，则<strong>匹配成功</strong>（识别出一个词）</p><ul><li><p><strong>正向最大匹配</strong> （从左到右方向）</p><p>选取包含6到8个汉字的符号串作为最大符号串，把最大符号串与词典中的单词条目匹配，如果不能匹配，削掉最右边的一个汉字继续匹配，直到在词典中找到相应的单词为止，匹配的方法从右向左。</p></li><li><p>逆向最大匹配（从右到左方向）</p></li><li><p>最小切分（每一句中切出的词数最小）</p></li><li><p><strong>双向最大匹配 </strong>（从左到右、从右到左两次扫描）</p></li></ul></li><li><p>基于统计的分词方法</p><ul><li>N元文法模型（N-gram）</li><li>隐马尔可夫模型（HMM）</li><li>最大熵模型（ME）</li><li>条件随机场模型（CRF）</li></ul><p>【注】</p><p>实际应用中，基于统计的分词系统都需要分词词典来进行字符串匹配，同时<strong>使用统计方法识别一些新词</strong>，即将<strong>字符串频率统计</strong>和<strong>字符串匹配</strong>结合起来，既发挥<strong>匹配分词切分速度快、效率高的特点</strong>，又利用了<strong>无词典分词结合上下文识别生词、自动消除歧义的优点</strong>。</p></li></ul><h4 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h4><p>【两种模型】</p><ul><li>CBOW（连续词袋）<ul><li>无隐层</li><li>使用双向上下文窗口</li><li>上下文词序无关</li><li>输入层直接使用低维稠密表示</li><li>输入层、映射层、输出层</li><li>输入层即某个单词周围的n-1个单词词向量。</li><li>映射层到输出层。需要借助Huffman树，从根节点开始，映射层的zhi需要huffman树不断进行logistic分类。</li></ul></li></ul><ul><li>Skip-Gram<ul><li>无隐层</li><li>投影层也可以省略</li><li>每个词向量作为log-linear模型的输入</li></ul></li></ul><p>【两种算法】</p><ul><li>层次Softmax<ul><li>采用Huffman树来编码输出层的词典</li><li>只需要计算路径上所有非叶子结点的词向量即可。</li></ul></li><li>负例采样<ul><li>​</li></ul></li></ul><h4 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h4><h4 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h4><ul><li>最大熵原理指出，当我们需要对一个随机事件的概率分布预测的时候，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。在这种情况下，概率分布最均匀，预测的风险最小。因为这时的概率分布的信息熵最大，所以这种模型叫做“最大熵模型”。即遇到不确定性时，保留各种可能性。</li></ul><h4 id="产生式模型和判别式模型"><a href="#产生式模型和判别式模型" class="headerlink" title="产生式模型和判别式模型"></a>产生式模型和判别式模型</h4><p>对于输入x，类别标签y</p><ul><li>产生式模型：估计它们的联合概率分布，如HMM、Naive Bayes、BNs、MRF</li><li>判别式模型：估计条件概率分布，如SVM、CRF、LR、Boosting、Neural Networks</li></ul><ul><li>生成式模型：有多个模型（一般有多少类就有多少个），把测试用例分别丢给各个模型，最后比较得出最佳结果。</li><li>判别式模型：只有一个模型，把测试用例丢给模型，直接得出结果。</li></ul><p>【联系】</p><p>由生成模型可以得到判别模型，但由判别模型无法得到生成模型</p><h4 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h4><p>【定义】</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180424/jCdF3IF5eA.png?imageslim" alt="mark"></p><p>【分类】</p><p>根据途中边有无方向，分为两类：</p><ul><li>有向图：贝叶斯网络</li><li>无向图：马尔科夫随机场（MRF）</li></ul><h4 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h4><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180424/44LHHCh6cD.png?imageslim" alt="mark"></p><h4 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h4><p>【特征函数】</p><p>在CRF中，每个特征函数以以下信息作为输入</p><ul><li>一个句子s</li><li>词在句子中的位置i</li><li>当前词的标签</li><li>前一个词的标签</li></ul><p>输出：一个实数值（一般0 或1）</p><p>【应用】</p><ul><li>分词（标注字的词位信息，由字构词）</li><li>词性标注（标注分词的词性）</li><li>命名实体识别</li></ul><h3 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h3><h4 id="实体对齐（同义词关系学习）"><a href="#实体对齐（同义词关系学习）" class="headerlink" title="实体对齐（同义词关系学习）"></a>实体对齐（同义词关系学习）</h4><ul><li>从开放链接数据中抽取同意关系</li><li>同一百科中的实体对齐<ul><li>重定向</li><li>信息模块：中文别称、别名</li></ul></li><li>不同百科间的实体对齐<ul><li>名称匹配</li></ul></li><li>基于SVM的自监督百科实体对齐方法（百科间实体）</li><li>基于CRF的开放同义关系学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS7安装python3</title>
    <link href="https://tianwenyu.github.io/centos-install-python/"/>
    <id>https://tianwenyu.github.io/centos-install-python/</id>
    <published>2018-04-01T11:29:36.000Z</published>
    <updated>2018-04-14T13:27:22.576Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>下载安装包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar -xvJf Python-3.6.2.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>进入到解压后的<code>Python-3.6.2</code>文件夹</p></li><li><p>编译安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./configure --prefix=xxxx</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>【注】<code>prefix</code>后是<code>Python-3.6.2</code>的解压路径的父目录</p></li><li><p>添加软连接到执行目录<code>/usr/bin</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s xxx/bin/python3 /usr/bin/python3</span><br><span class="line">ln -s xxx/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>【注】<code>xxx</code>代表python的安装路径，即步骤四的<code>prefix</code>后的路径</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载安装包&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo wget https://www.python.org/ft
      
    
    </summary>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://tianwenyu.github.io/tags/CentOS/"/>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【算法】LeetCode总结</title>
    <link href="https://tianwenyu.github.io/algorithm-leetcode/"/>
    <id>https://tianwenyu.github.io/algorithm-leetcode/</id>
    <published>2018-03-21T11:29:36.000Z</published>
    <updated>2018-04-30T06:35:32.225Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371.两整数之和"></a>371.两整数之和</h3><p>【题目描述】</p><p><strong>不使用</strong>运算符 <code>+</code> 和<code>-</code>，计算两整数<code>a</code> 、<code>b</code>之和。</p><p><strong>示例：</strong><br>若 <em>a</em> = 1 ，<em>b</em> = 2，返回 3。</p><p>【思路】</p><p>使用位运算，异或+移位。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(um.find(target-nums[i]) != um.end())&#123;</span><br><span class="line">                result.push_back(um[target-nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                um[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="7-反转整数"><a href="#7-反转整数" class="headerlink" title="7.反转整数"></a>7.反转整数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        sign=<span class="number">-1</span>;</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret&gt;INT_MAX || ret&lt;INT_MIN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sign*ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> isPositive=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        isPositive=<span class="literal">false</span>;</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result&gt;INT_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!isPositive)</span><br><span class="line">        <span class="keyword">return</span> -result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><p>【题目描述】</p><p>判断一个数是否是回文数</p><p>【思路】</p><ul><li>直接判断不是回文数的情况<ul><li>负数</li><li>个位为0（0这个数除外，如果是0也返回true）</li></ul></li><li>否则用一个数字记录它逆转的一半，与其另一半做比较，查看是否相等。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>))<span class="comment">//负数或者个位数为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//记录逆转的一半</span></span><br><span class="line">    <span class="keyword">while</span>(x&gt;sum)&#123;</span><br><span class="line">        sum=sum*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x==sum || x==(sum/<span class="number">10</span>); <span class="comment">//包含数字位数是奇数和偶数两种情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><p>【题目描述】</p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>【思路】</p><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><p>【题目描述】</p><p>给定一个 <em>n </em> n* 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[4,5,6]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[7,8,9]</span></span></span><br><span class="line"><span class="comment">]</span>,</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[7,4,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[8,5,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[9,6,3]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p>【思路】</p><p>通过两个步骤的元素交换</p><ul><li>按照副对角线翻转一次</li><li>按照水平中线翻转一次</li></ul><p><img src="http://img.blog.csdn.net/20140120222734218" alt="img"></p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//按副对角线旋转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n<span class="number">-1</span>-j][n<span class="number">-1</span>-i];</span><br><span class="line">            matrix[n<span class="number">-1</span>-j][n<span class="number">-1</span>-i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按水平中心旋转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n<span class="number">-1</span>-i][j];</span><br><span class="line">            matrix[n<span class="number">-1</span>-i][j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="118-帕斯卡三角形"><a href="#118-帕斯卡三角形" class="headerlink" title="118.帕斯卡三角形"></a>118.帕斯卡三角形</h3><p>【题目描述】</p><p>给定 <em>numRows</em>, 生成帕斯卡三角形的前 <em>numRows </em>行。</p><p>例如, 给定 <em>numRows</em> = 5,</p><p>返回</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>【思路】</p><ul><li>n行有n个数</li></ul><ul><li>每个数字等于上一行的左右两个数字之和，即第n+1行的第i个数等于第n行的第i-1个数和第i个数之和。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//初始化1个值为1的元素</span></span><br><span class="line">        ret.push_back(last);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=numRows;i++)&#123;</span><br><span class="line">            last.push_back(<span class="number">0</span>);<span class="comment">//补齐下一位</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur=last;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)<span class="comment">//第一位都为1，因此从第二位开始</span></span><br><span class="line">                cur[j]=cur[j]+last[j<span class="number">-1</span>];</span><br><span class="line">            ret.push_back(cur);</span><br><span class="line">            last=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169.求众数"></a>169.求众数</h3><p>【题目描述】</p><p>给定一个大小为 n的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [3,2,3]</span></span><br><span class="line"><span class="section">输出: 3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [2,2,1,1,1,2,2]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p>【思路】</p><p>数组中有一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。</p><p>在遍历数组的时候保存两个值</p><ul><li>一个是数组中的数字，一个是次数</li><li>如果下一个数字和我们之前保存的数字相同，则次数加1</li><li>如果下一个数字和我们之前保存的数字不同，则次数减1</li><li>如果次数为0，则保存下一个数字，并把次数设为1。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret==nums[i])</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            times--;</span><br><span class="line">        <span class="keyword">if</span>(times==<span class="number">0</span>)&#123;</span><br><span class="line">            ret=nums[i];</span><br><span class="line">            times=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    times=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==ret)</span><br><span class="line">            times++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (times&gt;len/<span class="number">2</span>)?ret:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h3><p>【题目描述】</p><p>将包含n 个元素的数组向右旋转 k 步。</p><p>例如，如果  <em>n</em> = 7 ,  <em>k</em> = 3，给定数组  <code>[1,2,3,4,5,6,7]</code>  ，向右旋转后的结果为 <code>[5,6,7,1,2,3,4]</code>。</p><p>【思路】</p><ul><li>旋转左部分</li><li>旋转右部分</li><li>整体旋转</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    k=k%len;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,len-k<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,len-k,len<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(from&lt;to)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=nums[from];</span><br><span class="line">        nums[from++]=nums[to];</span><br><span class="line">        nums[to--]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="233-数字1的个数"><a href="#233-数字1的个数" class="headerlink" title="233.数字1的个数"></a>233.数字1的个数</h3><p>【题目描述】</p><p>给定一个整数 n，计算所有小于等于 n 的非负数中数字1出现的个数。</p><p>例如：</p><p>给定 n = 13，</p><p>返回 6，因为数字1出现在下数中出现：1，10，11，12，13。</p><p>【思路】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628.三个数的最大乘积"></a>628.三个数的最大乘积</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h3><p>【题目描述】</p><p>给定两个有序整数数组 <em>nums1 </em>和 <em>nums2</em>，将 <em>nums2 </em>合并到 <em>nums1 </em>中<em>，</em>使得 <em>num1 </em>成为一个有序数组。</p><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li><li>你可以假设 <em>nums1 </em>有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line"><span class="section">输出: [1,2,2,3,5,6]</span></span><br></pre></td></tr></table></figure><p>【思路】</p><p>两个数组从后往前比较。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=m<span class="number">-1</span>;<span class="comment">//nums1数字长度最后一位</span></span><br><span class="line">    <span class="keyword">int</span> j=n<span class="number">-1</span>;<span class="comment">//nums2最后一位</span></span><br><span class="line">    <span class="keyword">int</span> k=m+n<span class="number">-1</span>;<span class="comment">//nums1+nums2数字长度</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">            nums1[k--]=nums2[j--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[k--]=nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果nums2还没结束，则把剩下的直接复制到nums1，因为剩下的nums2已经有序</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">        nums1[k--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p>【题目描述】</p><p>给定一个数组 <code>nums</code>, 编写一个函数将所有 <code>0</code> 移动到它的末尾，同时保持非零元素的相对顺序。</p><p>例如， 定义 <code>nums = [0, 1, 0, 3, 12]</code>，调用函数之后， <code>nums</code> 应为 <code>[1, 3, 12, 0, 0]</code>。</p><p><strong>注意事项</strong>:</p><ol><li>必须在原数组上操作，不要为一个新数组分配额外空间。</li><li>尽量减少操作总数。</li></ol><p>【思路】</p><ul><li>对原数组进行遍历，把非零值放在前面，空出后面的位置存放0。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i])</span><br><span class="line">            nums[index++]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;len;i++)</span><br><span class="line">        nums[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414.第三大的数"></a>414.第三大的数</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>【思路】</p><ul><li>用set，避免同一元素出现多次</li><li>定义反向迭代器，之后判断set中有多少个元素，小于三个时直接返回最大值，否则反向迭代就可以找到第三大的值了</li><li>时间复杂度是O(n)</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it=num.rbegin();</span><br><span class="line">        <span class="keyword">if</span>(num.size()&lt;<span class="number">3</span>)</span><br><span class="line">           <span class="keyword">return</span> *it; </span><br><span class="line">           </span><br><span class="line">        it++;</span><br><span class="line">        it++;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>【思路】</p><p>设置n1=第3大的数，n2=第2大的数，n3=最大数，最后返回n1，遍历一次即可。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> n=nums.size();  </span><br><span class="line">       <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];  </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);  </span><br><span class="line">       <span class="keyword">int</span> n1=min(nums[<span class="number">0</span>],min(nums[<span class="number">1</span>],nums[<span class="number">2</span>])),n2=max(nums[<span class="number">0</span>],min(nums[<span class="number">1</span>],nums[<span class="number">2</span>])),n3=max(nums[<span class="number">0</span>],max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]));  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">if</span>(nums[i]&gt;n3)   </span><br><span class="line">           &#123;  </span><br><span class="line">               n1=n2;  </span><br><span class="line">               n2=n3;  </span><br><span class="line">               n3=nums[i];  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;=n2)   </span><br><span class="line">           &#123;  </span><br><span class="line">              n2=nums[i];  </span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;n1)  </span><br><span class="line">           n1=nums[i];  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> n1;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><p>【思路】</p><p>动态规划方法。</p><p>动态规划问题的特点：</p><ul><li>大问题拆解为小问题</li><li>重复利用之前的计算结果</li></ul><p>根据回文的特性，一个大回文按比例缩小之后的字符串必定也是回文。</p><p>具体的递归方法有多种，这里选取两种递归方法。</p><hr><p><strong>解法1</strong></p><ul><li><code>dp[i][j]</code>表示字符串区间<code>[i,j]</code>是否为回文串<ul><li>当j=i时，只有一个字符，肯定是回文串</li><li>当j=i+1时，说明是相邻字符，需要判断s[i]是否等于s[j]</li><li>当j&gt;i+1时，说明是不相邻字符，除了判断s[i]和s[j]相等之外，<code>dp[i+1][j-1]</code>若为真，则是回文串，即字符串区间左侧+1，右侧-1。</li></ul></li><li>根据以上分析，写出状态转移方程</li></ul><p>$$<br>\begin{equation}<br>dp[i][j]=\left{<br>\begin{aligned}<br>1&amp; &amp; (i=j) \<br>=(s[i]==s[j]) &amp;  &amp; (j=i+1) \<br>=(s[i]==s[j] \&amp;\&amp;dp[i+1][j-1]) &amp;&amp;(j&gt;i+1)<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p><p>【题解】</p><p><strong>（未理解）</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size()][s.size()]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;<span class="comment">//最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//最长回文子串的起点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.size();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">              dp[j][j]=<span class="number">1</span>;<span class="comment">//边界条件</span></span><br><span class="line">              <span class="comment">//状态转移方程的二三个情况合写</span></span><br><span class="line">                dp[i][j]=(s[i]==s[j] &amp;&amp; (j-i&lt;=<span class="number">1</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]));</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; len&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                    len=j-i+<span class="number">1</span>;</span><br><span class="line">                    start=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,len);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>解法2</p><p>【思路】</p><ul><li><p><code>dp[i][j]</code>表示s[i]到s[j]所表示的子串是否为回文子串，是则为1，不是为0.</p><ul><li>若s[i]==s[j]，<ul><li>若s[i+1]到s[j-1]是回文子串，s[i]到s[j]就是回文子串。</li><li>若s[i+1]到s[j-1]不是回文子串，s[i]到s[j]则不是回文子串。</li></ul></li><li>若s[i]!=s[j]，则s[i]到s[j]一定不是回文子串。</li></ul></li><li><p>状态转移方程<br>$$<br>\begin{equation}<br>dp[i][j]=\left{<br>\begin{aligned}<br>dp[i+1][j-1]&amp; &amp; s[i]==s[j] \<br>0 &amp;  &amp; s[i]!=s[j]\</p><p>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>​</p></li><li><p>边界：<code>dp[i][i]=1</code>，<code>dp[i][i+1]=(s[i]==s[i+1]?1:0)</code></p><p>​</p></li></ul><h3 id="8-字符串转整数（atoi）"><a href="#8-字符串转整数（atoi）" class="headerlink" title="8.字符串转整数（atoi）"></a>8.字符串转整数（atoi）</h3><p>【思路】</p><ul><li>字符串格式的合法判断<ul><li>空格不计入计算，从第一个非空字符开始判断，</li><li>首字母只能是<code>+</code>、<code>-</code>或数字</li></ul></li><li>转换结果的溢出判断<ul><li><code>Int类型</code>范围是<code>INT_MIN(-2147482648)</code>到<code>INT_MAX(2147483647)</code>，超出范围则返回最大与最小值。因此使用long long 类型变量储存结果。</li><li>如果正确的值超过的可表示的范围，则返回 <code>INT_MAX（2147483647）</code>或 <code>INT_MIN（-2147483648）</code>。</li><li>如果不能执行有效的转换，则返回 0。</li><li>字符串可以在形成整数的字符后包括多余的字符，将这些字符忽略，这些字符对于函数的行为没有影响。</li></ul></li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(str[index]==<span class="string">' '</span>)</span><br><span class="line">        index++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str[index]==<span class="string">'+'</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[index]==<span class="string">'-'</span>)&#123;</span><br><span class="line">        sign=<span class="number">-1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;index&lt;str.length();index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[index]&gt;=<span class="string">'0'</span> &amp;&amp; str[index]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            result=result*<span class="number">10</span>+(str[index]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(result&gt;INT_MAX)</span><br><span class="line">                <span class="keyword">return</span> sign&gt;<span class="number">0</span>?INT_MAX:INT_MIN;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result*=sign;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h3><p>【题目描述】</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>【思路】</p><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h3><p>【题目描述】</p><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="string">"11"</span>, <span class="selector-tag">b</span> = <span class="string">"1"</span></span><br><span class="line">输出: <span class="string">"100"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入: <span class="selector-tag">a</span> = <span class="string">"1010"</span>, <span class="selector-tag">b</span> = <span class="string">"1011"</span></span><br><span class="line">输出: <span class="string">"10101"</span></span><br></pre></td></tr></table></figure><p>【思路】</p><p>用0补齐较短字符串左侧至两字符串相等，然后相加即可。</p><p>【题解】</p><p>未通过</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len1=a.size();</span><br><span class="line">        <span class="keyword">int</span> len2=b.size();</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len1&gt;len2)&#123;</span><br><span class="line">            b=<span class="string">'0'</span>+b;</span><br><span class="line">            len2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(len2&gt;len1)&#123;</span><br><span class="line">            a=<span class="string">'0'</span>+b;</span><br><span class="line">            len1++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len1)&#123;</span><br><span class="line">            len1--;</span><br><span class="line">            <span class="keyword">int</span> tmp=(a[len1]-<span class="string">'0'</span>)+(b[len1]-<span class="string">'0'</span>)+carry;</span><br><span class="line">            result=to_string(carry%<span class="number">2</span>)+result;</span><br><span class="line">            carry=tmp/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后一位有进位，单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            result[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">            result=<span class="string">'1'</span>+result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">int</span> aSize = a.size();  </span><br><span class="line">        <span class="keyword">int</span> bSize = b.size();  </span><br><span class="line">        <span class="keyword">while</span>(aSize&gt;bSize)&#123;  </span><br><span class="line">            b = <span class="string">'0'</span> + b;  </span><br><span class="line">            bSize++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(bSize&gt;aSize)&#123;  </span><br><span class="line">            a = <span class="string">'0'</span> + a;  </span><br><span class="line">            aSize++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;  </span><br><span class="line">        <span class="keyword">while</span>(aSize)&#123;  </span><br><span class="line">            aSize--;  </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">                <span class="keyword">if</span>((a[aSize] - <span class="string">'0'</span>)^(b[aSize]-<span class="string">'0'</span>))&#123;  </span><br><span class="line">                    result = <span class="string">'0'</span> + result;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((a[aSize]-<span class="string">'0'</span>)&amp;&amp;(b[aSize]-<span class="string">'0'</span>))&#123;  </span><br><span class="line">                    result = <span class="string">'1'</span> + result;  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                    result = <span class="string">'1'</span> + result;  </span><br><span class="line">                    flag = <span class="literal">false</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">if</span>((a[aSize]-<span class="string">'0'</span>)^(b[aSize]-<span class="string">'0'</span>))  </span><br><span class="line">                    result = <span class="string">'1'</span> + result;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((a[aSize]-<span class="string">'0'</span>)&amp;&amp;(b[aSize]-<span class="string">'0'</span>))&#123;  </span><br><span class="line">                    flag = <span class="literal">true</span>;  </span><br><span class="line">                    result = <span class="string">'0'</span> + result;  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                    result = <span class="string">'0'</span> + result;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag) result = <span class="string">'1'</span> + result;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="125-验证回文字符串"><a href="#125-验证回文字符串" class="headerlink" title="125.验证回文字符串"></a>125.验证回文字符串</h3><p>【思路】</p><p>使用一头一尾两个指针，反方向判断是否一一满足即可。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAlphanumeric</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">toLower</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a'</span> + c - <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; s.size() &amp;&amp; !isAlphanumeric(s[begin]))</span><br><span class="line">            begin++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; !isAlphanumeric(s[end])) </span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= begin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (toLower(s[begin]) != toLower(s[end]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###242.有效的字母异位词</p><p>【问题描述】</p><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的一个字母异位词。</p><p>例如，<br><em>s</em> = “anagram”，<em>t</em> = “nagaram”，返回 true<br><em>s</em> = “rat”，<em>t</em> = “car”，返回 false</p><p>【思路】</p><p>求每个字符个数判别是否相等。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len1=s.size();</span><br><span class="line">    <span class="keyword">int</span> len2=t.size();</span><br><span class="line">  <span class="comment">//如果两个字符串长度不同，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(len1!=len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//词频统计</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        count[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)</span><br><span class="line">        count[t[i]-<span class="string">'a'</span>]--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h3><p>【问题描述】</p><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>案例:</strong></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"leetcode"</span></span><br><span class="line">返回 0.</span><br><span class="line"></span><br><span class="line">s = <span class="string">"loveleetcode"</span>,</span><br><span class="line">返回 2.</span><br></pre></td></tr></table></figure><p>【思路】</p><ul><li>字频统计</li><li>找出第一个出现次数为1的字符</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">        count[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[s[i]-<span class="string">'a'</span>]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="409-Longest-Palindrome"><a href="#409-Longest-Palindrome" class="headerlink" title="409 Longest Palindrome"></a>409 Longest Palindrome</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>【题目描述】</p><p>给定两个<strong>非空</strong>链表来表示两个非负整数。位数按照<strong>逆序</strong>方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><p>【思路】</p><ul><li>遍历两个链表。<ul><li>将两个结点的值相加，大于10的值进位，放入结果链表中。记录除数和余数。</li></ul></li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1 || !l2 )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 || l2 || carry)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=(l1?l1-&gt;val:<span class="number">0</span>)+(l2?l2-&gt;val:<span class="number">0</span>)+carry;</span><br><span class="line">        p-&gt;next=<span class="keyword">new</span> ListNode(tmp%<span class="number">10</span>);<span class="comment">//tmp%10用来记录相加后的数。</span></span><br><span class="line">        carry=tmp/<span class="number">10</span>;<span class="comment">//carry的范围最大不超过18，因此可用来记录进位。</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        l1=l1?l1-&gt;next:l1;</span><br><span class="line">        l2=l2?l2-&gt;next:l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> l2;</span><br><span class="line">       <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> l1;</span><br><span class="line">       <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       ListNode *result;</span><br><span class="line">       <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">           result=l1;</span><br><span class="line">           result-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           result=l2;</span><br><span class="line">           result-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="24-两两交换链表中的结点"><a href="#24-两两交换链表中的结点" class="headerlink" title="24.两两交换链表中的结点"></a>24.两两交换链表中的结点</h3><p>【题目描述】</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180417/A5Bh2CCjbj.png?imageslim" alt="mark"></p><p>【思路】</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180417/GceD8cC5h8.jpg?imageslim" alt="mark"></p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *dummy=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode *pre=dummy;</span><br><span class="line">    ListNode *cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur&amp;&amp;cur-&gt;next)&#123;</span><br><span class="line">        pre-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        pre-&gt;next-&gt;next=cur;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h3><p>【题目描述】</p><p>给定一个链表，旋转链表，将链表每个节点向右移动 k个位置，其中k是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">3</span> 步: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">4</span> 步: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p>【思路】</p><p>先计算链表长度，然后从头遍历链表直到倒数第k个点，即原链表倒数k个元素成为新链表的前部分，原链表的前(len-k)个元素成为新链表的后部分。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    k%=len;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;<span class="comment">//记录新链表的位置</span></span><br><span class="line">    p=head;</span><br><span class="line">    <span class="comment">//寻找右旋k个位置后，新链表的首个结点</span></span><br><span class="line">    <span class="keyword">while</span>(index&lt;(len-k) &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *ret=p-&gt;next;</span><br><span class="line">    ListNode *q=p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//原链表寻找尾结点，将其链接到head</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    p-&gt;next=head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前部分尾结点设为NULL</span></span><br><span class="line">    q-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="82-删除排序链表中的重复元素Ⅱ"><a href="#82-删除排序链表中的重复元素Ⅱ" class="headerlink" title="82.删除排序链表中的重复元素Ⅱ"></a>82.删除排序链表中的重复元素Ⅱ</h3><p>【题目描述】</p><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现 </em>的数字。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *dummy=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *p=dummy;</span><br><span class="line">    ListNode *q=head;</span><br><span class="line">    <span class="keyword">while</span>(q)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;next &amp;&amp; q-&gt;next-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = q-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; q-&gt;val==tmp)</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next=q;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(q)</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83.删除排序链表中的重复元素"></a>83.删除排序链表中的重复元素</h3><p>【题目描述】</p><p>给定一个排序链表，删除所有重复的元素使得每个元素只留下一个。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val == p-&gt;next-&gt;val)</span><br><span class="line">            p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86.分隔链表"></a>86.分隔链表</h3><p>【题目描述】</p><p>给定一个链表和一个特定值x<em>，对链表进行分隔，使得所有小于 </em>x<em> 的节点都在大于或等于 </em>x* 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">输入: head = <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>, x = <span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><p>【思路】</p><ul><li>在数组partition中，一般是通过首尾两个指针来进行前后遍历以及交换；</li><li>而在链表中，不需要进行元素的交换，可以通过创建两个新的头结点指针，来分别指向小于x的结点和大于等于x的结点，遍历结束之后，再将两个新的链表重新连接起来。</li></ul><p>【题解】</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><p>【题目描述】</p><p>给定一个链表，判断链表中否有环。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode *slowP=head;</span><br><span class="line">    ListNode *fastP=head;</span><br><span class="line">    <span class="keyword">while</span>(fastP&amp;&amp;fastP-&gt;next)&#123;</span><br><span class="line">        fastP=fastP-&gt;next-&gt;next;</span><br><span class="line">        slowP=slowP-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slowP==fastP)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h3><p>【题目描述】</p><p>给一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isCycle=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *slowP=head;</span><br><span class="line">    ListNode *fastP=head;</span><br><span class="line">    <span class="keyword">while</span>(fastP-&gt;next!=<span class="literal">NULL</span>&amp;&amp;fastP-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        fastP=fastP-&gt;next-&gt;next;</span><br><span class="line">        slowP=slowP-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slowP==fastP)&#123;</span><br><span class="line">            isCycle=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isCycle)&#123;</span><br><span class="line">        fastP=head;</span><br><span class="line">        <span class="keyword">while</span>(slowP!=<span class="literal">NULL</span>&amp;&amp;fastP!=<span class="literal">NULL</span>&amp;&amp;fastP!=slowP)&#123;</span><br><span class="line">            slowP=slowP-&gt;next;</span><br><span class="line">            fastP=fastP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowP;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143.重排链表"></a>143.重排链表</h3><p>【题目描述】</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180417/e3Lif2Jj99.png?imageslim" alt="mark"></p><p>【思路】</p><ul><li>使用快慢指针将链表从中间分割成两段</li></ul><ul><li>后半段就地逆置</li><li>合并插入到前半段链表即可。</li></ul><p>时间复杂度O(n).</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    ListNode *slow=head;</span><br><span class="line">    ListNode *fast=head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        pre=slow;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next=<span class="literal">NULL</span>;<span class="comment">//从中间切分</span></span><br><span class="line">    </span><br><span class="line">    ListNode *rHead=reverse(slow);<span class="comment">//rHead是逆置后的头结点</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//合并两个链表</span></span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = rHead;</span><br><span class="line">        rHead= rHead-&gt;next;</span><br><span class="line">        cur-&gt;next-&gt;next = tmp;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = rHead; <span class="comment">//链接上最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        next=head-&gt;next;</span><br><span class="line">        head-&gt;next=pre;</span><br><span class="line">        pre=head;</span><br><span class="line">        head=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147.链表插入排序"></a>147.链表插入排序</h3><p>【题目描述】</p><p>用插入排序对链表进行排序。</p><p>【思路】</p><p>插入排序的链表实现版。</p><p>新建一个头结点，来保存排序后的链表。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//边界条件判断</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">//创建一个新的链表头部</span></span><br><span class="line">    ListNode *sortedHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//排序后的链表当前结点</span></span><br><span class="line">  ListNode *cur=sortedHead;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur=sortedHead;</span><br><span class="line">        <span class="comment">//寻找插入点</span></span><br><span class="line">      <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val&lt;p-&gt;val)</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        <span class="comment">//保存原链表当前结点的next域</span></span><br><span class="line">      ListNode *tmp=p-&gt;next;</span><br><span class="line">        <span class="comment">//插入结点</span></span><br><span class="line">      p-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=p;</span><br><span class="line">      <span class="comment">//移动到原链表的下一个位置</span></span><br><span class="line">        p=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h3><p>【题目描述】</p><p>找到两个单链表相交的起始结点</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    ListNode *s=head;</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        s=s-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA||!headB)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len1=GetLength(headA);</span><br><span class="line">    <span class="keyword">int</span> len2=GetLength(headB);</span><br><span class="line">    <span class="keyword">int</span> diff=len1-len2;</span><br><span class="line">    ListNode *fast=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *slow=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(diff&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        fast=headA;</span><br><span class="line">        slow=headB;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fast=headB;</span><br><span class="line">        slow=headA;</span><br><span class="line">        diff=-diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;diff;i++)&#123;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; slow &amp;&amp; fast!=slow)&#123;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="203-删除链表中的元素"><a href="#203-删除链表中的元素" class="headerlink" title="203.删除链表中的元素"></a>203.删除链表中的元素</h3><p>【题目描述】</p><p>删除链表中等于给定值 <strong>val </strong>的所有元素。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *p=head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==head &amp;&amp; p-&gt;val==val)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            head=p;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val==val)&#123;</span><br><span class="line">            pre-&gt;next=p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p=pre-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>【思路】</p><p>即链表逆置</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">    ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        next=head-&gt;next;</span><br><span class="line">        head-&gt;next=pre;</span><br><span class="line">        pre=head;</span><br><span class="line">        head=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><h4 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h4><p>【思路】</p><ul><li>将链表后半段翻转<ul><li>寻找链表中分界点的方法是：快慢指针法，fast指针一次走两步，slow指针一次走一步</li><li>当遍历结束时，如果链表长度是奇数，则slow刚好在中间，若链表长度是偶数，则slow在中间前一个。</li></ul></li><li>将前半段与后半段比较</li><li>时间复杂度O(n)</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空或者是只有一个，必定是回文链表，返回true</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow=head;</span><br><span class="line">        ListNode *fast=head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rHead是逆转后的头结点</span></span><br><span class="line">        </span><br><span class="line">        ListNode *rHead=slow;</span><br><span class="line">        <span class="comment">//如果链表长度是奇数，则rHead在中间；如果链表长度是偶数，则rHead在中间前一个。</span></span><br><span class="line">        <span class="comment">//不论链表长度是奇数还是偶数，只需要一种情况处理。</span></span><br><span class="line">        <span class="comment">//如1234321，slow在4上，只需要判断123和321相同即可。</span></span><br><span class="line">        <span class="comment">//如123321，长度是偶数，slow在第一个3上，判断123和321是否相同即可。</span></span><br><span class="line">        rHead=reverse(rHead-&gt;next);</span><br><span class="line">        <span class="keyword">while</span>(rHead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rHead-&gt;val != head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            rHead=rHead-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            next=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h4><p>【思路】</p><ul><li>用一个vector把链表里的值一次性push进去。</li><li>遍历vector，判断v[i]与v[v.size()-i-1]是否相等<ul><li>不相等，直接返回false</li><li>遍历结束，返回true</li></ul></li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            v.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size() / <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] != v[v.size() - i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328.Odd Even Linked List"></a>328.Odd Even Linked List</h3><p>【题目描述】</p><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p><strong>Example:</strong><br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>return <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.</p><p><strong>Note:</strong><br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p><p>【思路】</p><ul><li>定义两个链表，奇数链表和偶数链表</li><li>用两个指针遍历链表，每次遍历两个结点（奇数结点和偶数结点），然后将偶数链表的头部接在奇数链表的尾部。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *oddHead=head;<span class="comment">//奇数链表头</span></span><br><span class="line">    ListNode *evenHead=head-&gt;next;<span class="comment">//偶数链表头</span></span><br><span class="line">    ListNode *curOdd=oddHead;<span class="comment">//当前奇数指针</span></span><br><span class="line">    ListNode *curEven=evenHead;<span class="comment">//当前偶数指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curEven &amp;&amp; curEven-&gt;next)&#123;</span><br><span class="line">        curOdd-&gt;next=curEven-&gt;next;</span><br><span class="line">        curOdd=curOdd-&gt;next;</span><br><span class="line">        curEven-&gt;next=curOdd-&gt;next;</span><br><span class="line">        curEven=curEven-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    curOdd-&gt;next=evenHead;<span class="comment">//偶数链表的头部接在奇数链表的尾部</span></span><br><span class="line">    <span class="keyword">return</span> oddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="94-中序遍历二叉树"><a href="#94-中序遍历二叉树" class="headerlink" title="94.中序遍历二叉树"></a>94.中序遍历二叉树</h3><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode *p=root;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||p)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            result.push_back(p-&gt;val);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><p>【题目描述】</p><p>给定一个二叉树，返回其按层次遍历的节点值。 </p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回其层次遍历结果为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelResult;        </span><br><span class="line">        q.push(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            </span><br><span class="line">            levelResult.clear();</span><br><span class="line">            <span class="keyword">int</span> size=q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                p=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">                levelResult.push_back(p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(levelResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><h4 id="解法1-2"><a href="#解法1-2" class="headerlink" title="解法1"></a>解法1</h4><p>DFS方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth=maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth=maxDepth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (leftDepth&gt;rightDepth)?(leftDepth+<span class="number">1</span>):(rightDepth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解法2-2"><a href="#解法2-2" class="headerlink" title="解法2"></a>解法2</h4><p>BFS方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;<span class="comment">//记录队列中每一层的元素个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                depth++;</span><br><span class="line">                count=q.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层次遍历Ⅱ"><a href="#107-二叉树的层次遍历Ⅱ" class="headerlink" title="107.二叉树的层次遍历Ⅱ"></a>107.二叉树的层次遍历Ⅱ</h3><p>【题目描述】</p><p>给定一个二叉树，返回其节点值自底向上的层次遍历。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回其自自底向上的层次遍历为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>【思路】</p><p>在102题的基础上，将输出的结果逆序即可。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    TreeNode *p=root;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(p);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelResult;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        levelResult.clear();</span><br><span class="line">        <span class="keyword">int</span> size=q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            levelResult.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(levelResult);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(result.begin(),result.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><p>【题目描述】</p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">给定有序数组: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><p>【思路】</p><p>使用递归方法。</p><p>每次找到排序数组的中点，中点左边的子排序数组构成左子树，中点右边的子排序数组构成右子树,递归进行。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> buildBST(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">buildBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    TreeNode *node=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    node-&gt;left=buildBST(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">    node-&gt;right=buildBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><p>【思路】</p><p>用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前就已经遍历了它的左右子树。</p><p>只要在遍历每个结点的时候记录它的深度，就可以一边遍历一边判断每个结点是否平衡。</p><ul><li>如果子树是平衡二叉树，则返回子树高度</li><li>如果子树不是平衡二叉树，直接停止遍历</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root,&amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root,<span class="keyword">int</span> *depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        *depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isBalanced(root-&gt;left,&amp;leftDepth) &amp;&amp; isBalanced(root-&gt;right,&amp;rightDepth))&#123;</span><br><span class="line">        <span class="keyword">int</span> diff=leftDepth-rightDepth;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(diff)&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            *depth=<span class="number">1</span>+(leftDepth&gt;rightDepth?leftDepth:rightDepth);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树最小深度"><a href="#111-二叉树最小深度" class="headerlink" title="111.二叉树最小深度"></a>111.二叉树最小深度</h3><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth=minDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth=minDepth(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(leftDepth==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(rightDepth==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (leftDepth&lt;rightDepth)?leftDepth+<span class="number">1</span>:rightDepth+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h3><p>【题目描述】</p><p>给定一个二叉树，<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757" target="_blank" rel="external">原地</a>将它展开为链表。</p><p>例如，给定二叉树</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>将其展开为：</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure><p>【思路】</p><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">       <span class="keyword">if</span>(!root)</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       TreeNode* p=root;</span><br><span class="line">       <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">       <span class="keyword">while</span>(p||!s.empty())&#123;</span><br><span class="line">           <span class="keyword">while</span>(p)&#123;</span><br><span class="line">               result.push_back(p-&gt;val);</span><br><span class="line">               s.push(p);</span><br><span class="line">               p=p-&gt;left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">               p=s.top();</span><br><span class="line">               s.pop();</span><br><span class="line">               p=p-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        TreeNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        s.push(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            <span class="keyword">if</span>((!p-&gt;left &amp;&amp; !p-&gt;right)||(pre &amp;&amp; (pre==p-&gt;left || pre==p-&gt;right)))&#123;</span><br><span class="line">                result.push_back(p-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">                pre=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">                    s.push(p-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">                    s.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="230-二叉搜素树第k小的元素"><a href="#230-二叉搜素树第k小的元素" class="headerlink" title="230.二叉搜素树第k小的元素"></a>230.二叉搜素树第k小的元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||k&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p=root;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||p)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                p=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count==k)</span><br><span class="line">                    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h3><p>【题目描述】</p><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) – 将元素x推入栈中。</li><li>pop() – 删除栈顶的元素。</li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">M<span class="keyword">in</span>Stack <span class="keyword">min</span>Stack = new M<span class="keyword">in</span>Stack();</span><br><span class="line"><span class="keyword">min</span>Stack.push(-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">min</span>Stack.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">min</span>Stack.push(-<span class="number">3</span>);</span><br><span class="line"><span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line"><span class="keyword">min</span>Stack.pop();</span><br><span class="line"><span class="keyword">min</span>Stack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line"><span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p>【思路】</p><p>使用两个栈，一个栈是正常的栈s，另一个栈是存最小值的栈sm。</p><ul><li>push时，判断sm是否为空，以下两种情况在sm中插入x<ul><li>为空</li><li>非空但栈顶元素大于插入值的</li></ul></li><li>pop时，s的元素删除，若sm中的元素与s的元素相等，则一同删除。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sm;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        <span class="keyword">if</span>(sm.empty() || (!sm.empty() &amp;&amp; sm.top()&gt;=x))</span><br><span class="line">            sm.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.top()==sm.top())</span><br><span class="line">            sm.pop();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sm.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h2&gt;&lt;h3 id=&quot;371-两整数之和&quot;&gt;&lt;a href=&quot;#371-两整数之和&quot; class=&quot;headerlink&quot; title=&quot;371.两整数之和&quot;&gt;&lt;/a&gt;371.两整数之和&lt;/h3&gt;&lt;p&gt;【题目描述】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不使用&lt;/strong&gt;运算符 &lt;code&gt;+&lt;/code&gt; 和&lt;code&gt;-&lt;/code&gt;，计算两整数&lt;code&gt;a&lt;/code&gt; 、&lt;code&gt;b&lt;/code&gt;之和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;若 &lt;em&gt;a&lt;/em&gt; = 1 ，&lt;em&gt;b&lt;/em&gt; = 2，返回 3。&lt;/p&gt;
&lt;p&gt;【思路】&lt;/p&gt;
&lt;p&gt;使用位运算，异或+移位。&lt;/p&gt;
&lt;p&gt;【题解】&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (b != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a ^ b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b = (a &amp;amp; b) &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a = c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数&quot;&gt;&lt;a href=&quot;#数&quot; class=&quot;headerlink&quot; title=&quot;数&quot;&gt;&lt;/a&gt;数&lt;/h2&gt;&lt;h3 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.两数之和&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unordered_map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; twoSum(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;unordered_map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; um;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n=nums.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(um.find(target-nums[i]) != um.end())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result.push_back(um[target-nums[i]]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result.push_back(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                um[nums[i]]=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="https://tianwenyu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tianwenyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】剑指Offer总结</title>
    <link href="https://tianwenyu.github.io/algorithm-offer/"/>
    <id>https://tianwenyu.github.io/algorithm-offer/</id>
    <published>2018-03-20T11:29:36.000Z</published>
    <updated>2018-04-26T16:09:03.474Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="二进制中1的个数-（面试题10）"><a href="#二进制中1的个数-（面试题10）" class="headerlink" title="二进制中1的个数 （面试题10）"></a>二进制中1的个数 （面试题10）</h3><p>【题目描述】</p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p>【思路】</p><p>把一个整数减去1，再和原整数做<code>与</code>运算，会把该整数最右边一个1变成0，则一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><a id="more"></a><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=(n<span class="number">-1</span>)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中只出现一次的数字（面试题40）"><a href="#数组中只出现一次的数字（面试题40）" class="headerlink" title="数组中只出现一次的数字（面试题40）"></a>数组中只出现一次的数字（面试题40）</h3><p>【题目描述】</p><p>一个整形数组里除了两个数字之外，其他的数字都出现了两次，找出这两个只出现一次的数字。要求时间复杂度O(n)，空间复杂度O(1)。</p><p>【思路】</p><p>【题解】</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组中出现次数超过一半的数字（面试题29）"><a href="#数组中出现次数超过一半的数字（面试题29）" class="headerlink" title="数组中出现次数超过一半的数字（面试题29）"></a>数组中出现次数超过一半的数字（面试题29）</h3><p>【题目描述】</p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>【思路】</p><p>数组中有一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。</p><p>在遍历数组的时候保存两个值</p><ul><li>一个是数组中的数字，一个是次数</li><li>如果下一个数字和我们之前保存的数字相同，则次数加1</li><li>如果下一个数字和我们之前保存的数字不同，则次数减1</li><li>如果次数为0，则保存下一个数字，并把次数设为1。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  第一个数字作为第一个士兵，守阵地；count = 1；</span></span><br><span class="line"><span class="comment">  遇到相同元素，count++;</span></span><br><span class="line"><span class="comment">  遇到不相同元素，即为敌人，同归于尽,count--；当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。</span></span><br><span class="line"><span class="comment">  再加一次循环，记录这个士兵的个数看是否大于数组一般即可。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len=numbers.size();</span><br><span class="line">      <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> result=numbers[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> times=<span class="number">1</span>;    <span class="comment">//次数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(result==numbers[i])</span><br><span class="line">              times++;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              times--;</span><br><span class="line">           <span class="comment">// 更新result的值为当前元素，并置次数为1</span></span><br><span class="line">          <span class="keyword">if</span>(times==<span class="number">0</span>)&#123;</span><br><span class="line">              result=numbers[i];</span><br><span class="line">              times=<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断result是否符合条件，即出现次数大于数组长度的一半</span></span><br><span class="line">      times=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">          <span class="keyword">if</span>(numbers[i]==result)</span><br><span class="line">              times++;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> (times&gt;len/<span class="number">2</span>)?result:<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="数字在排序数组中出现的次数（面试题38）"><a href="#数字在排序数组中出现的次数（面试题38）" class="headerlink" title="数字在排序数组中出现的次数（面试题38）"></a>数字在排序数组中出现的次数（面试题38）</h3><p>【题目描述】</p><p>统计一个数字在排序数组中出现的次数</p><p>【思路】</p><ul><li>看到有序数组的查找，想到二分查找</li><li>因为要查找的k是连续出现的，需要确定第一个k的位置和最后一个k的位置。</li><li>分两次查找第一个k的位置和最后一个k的位置。</li><li>先查找第一个k的位置，查找到k值后，不确定是否是第一个k，所以比较查找到的k值和前面一个值是否相等，即向该k值的左方查找<ul><li>如果不等，则说明是第一个k值</li><li>如果相等，则继续向左比较。</li></ul></li><li>查找最后一个k的位置同理。</li><li>最后确定第一个k的位置和最后一个k的位置，lastK-firstK+1即可。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFirstK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> k,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.size()==<span class="number">0</span> || low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]&lt;k)</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//查找到k值，但是不确定是否是第一个k</span></span><br><span class="line">            <span class="comment">//往左寻找第一个k</span></span><br><span class="line">            <span class="keyword">while</span>(data[mid<span class="number">-1</span>]==data[mid])&#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> k,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.size()==<span class="number">0</span> || low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]&lt;k)</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//查找到k值，但是不确定是否是最后一个k</span></span><br><span class="line">            <span class="comment">//往右寻找最后一个k</span></span><br><span class="line">            <span class="keyword">while</span>(data[mid+<span class="number">1</span>]==data[mid])&#123;</span><br><span class="line">                mid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.size()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=data.size();</span><br><span class="line">    <span class="keyword">int</span> firstK=GetFirstK(data,k,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> lastK=GetLastK(data,k,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(firstK==<span class="number">-1</span> || lastK==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (lastK-firstK+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和为s的两个数字（面试题41）"><a href="#和为s的两个数字（面试题41）" class="headerlink" title="和为s的两个数字（面试题41）"></a>和为s的两个数字（面试题41）</h3><p>【题目描述】</p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。</p><p>【思路】</p><p>同LeetCode 1。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.find(sum-<span class="built_in">array</span>[i])!=m.end())&#123;</span><br><span class="line">                result.push_back(sum-<span class="built_in">array</span>[i]);</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                m[<span class="built_in">array</span>[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h3><p>【题目描述】</p><p>输入一个正数s，打印所有和为s的连续正数序列（至少含两个数）</p><p>【思路】</p><ul><li>用两个数small和big分别表示序列的最小值和最大值。</li><li>把small初始化为1，big初始化为2.<ul><li>当前和的值为<code>(big+small)*(big-small+1)/2</code></li><li>若当前和的值小于sum，big加1</li><li>若当前和大于sum，small加1</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="替换空格-（面试题4）"><a href="#替换空格-（面试题4）" class="headerlink" title="替换空格 （面试题4）"></a>替换空格 （面试题4）</h3><p>【题目描述】：把字符串中的每个空格替换成”%20”。例如输入”We are happy”，输出”We%20are%20happy”</p><p>【思路】O(n)解法</p><ol><li>先遍历一遍字符串，统计出字符串中空格的总数，并可由此计算出替换空格之后的字符串的总长度。每替换一个空格，长度增加2。</li><li>从字符串尾部开始复制和替换<ul><li>两个指针p1,p2。p1指向原字符串末尾，p2指向替换之后的字符串末尾。</li><li>向前移动p1，逐个把它指向的字符复制到p2指向的位置，直到遇到第一个空格为止。</li><li>碰到第一个空格之后，把p1向前移动1格，在p2之前插入“%20”。</li><li>因为”%20”长度为3，所以将p2向前移动3格</li></ul></li></ol><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       <span class="keyword">int</span> spaceNum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> originalLength=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(str[index] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(str[index] == <span class="string">' '</span>)</span><br><span class="line">               spaceNum++;</span><br><span class="line">           originalLength++;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> newLength=originalLength+spaceNum*<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span>(newLength &gt; length)</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       <span class="keyword">int</span> originalIndex=originalLength;</span><br><span class="line">       <span class="keyword">int</span> newIndex=newLength;</span><br><span class="line">       <span class="keyword">while</span>(originalIndex &gt;=<span class="number">0</span> &amp;&amp; newIndex &gt; originalIndex)&#123;</span><br><span class="line">           <span class="keyword">if</span>(str[originalIndex] == <span class="string">' '</span>)&#123;</span><br><span class="line">               str[newIndex--]=<span class="string">'0'</span>;</span><br><span class="line">               str[newIndex--]=<span class="string">'2'</span>;</span><br><span class="line">               str[newIndex--]=<span class="string">'%'</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               str[newIndex--]=str[originalIndex];</span><br><span class="line">           &#125;</span><br><span class="line">           originalIndex--;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印1到最大的n位数（面试题12）"><a href="#打印1到最大的n位数（面试题12）" class="headerlink" title="打印1到最大的n位数（面试题12）"></a>打印1到最大的n位数（面试题12）</h3><p>【题目描述】输入数字n，按顺序打印出从1开始到最大的n位十进制数。</p><p>【思路】</p><p>因为n的范围没给出，因此为了防止溢出使用字符串的方式解决此题。</p><p>采用数字排列的方法。在输出的数字前面补0的话，会发现n位所有十进制数其实就是n个从0到9的全排列。即把数字的每一位从0到9排列一遍，得到所有的十进制数。</p><p>全排列用递归容易表达，数字的每一位都可能是0-9中的一个数，然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>​</li></ul><h3 id="字符串全排列（面试题28）"><a href="#字符串全排列（面试题28）" class="headerlink" title="字符串全排列（面试题28）"></a>字符串全排列（面试题28）</h3><p>【题目描述】输入一个字符串，打印出该字符串中字符的所有排列。</p><p>【思路】</p><p>该问题即全排列问题，可以分为递归方法和非递归方法实现。</p><p>递归方法：《剑指Offer》中的该题题解没有考虑去重的情况。去重的全排列规则：从第一个数字起每个数分别与它后面非重复出现的数字交换。用编程的话描述就是第i个数与第j个数交换时，要求[i,j)中没有与第j个数相等的数。</p><p>非递归方法：</p><p><a href="https://blog.csdn.net/morewindows/article/details/7370155" target="_blank" rel="external">https://blog.csdn.net/morewindows/article/details/7370155</a></p><p>【题解】</p><ul><li><p>递归方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去重全排列的递归实现  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> t = *a;  </span><br><span class="line">    *a = *b;  </span><br><span class="line">    *b = t;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//在pszStr数组中，[nBegin,nEnd)中是否有数字与下标为nEnd的数字相等  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSwap</span><span class="params">(<span class="keyword">char</span> *pszStr, <span class="keyword">int</span> nBegin, <span class="keyword">int</span> nEnd)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nBegin; i &lt; nEnd; i++)  </span><br><span class="line">        <span class="keyword">if</span> (pszStr[i] == pszStr[nEnd])  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//k表示当前选取到第几个数,m表示共有多少数.  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AllRange</span><span class="params">(<span class="keyword">char</span> *pszStr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (k == m)&#123;  </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s_i = <span class="number">1</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  第%3d个排列\t%s\n"</span>, s_i++, pszStr);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= m; i++)&#123; </span><br><span class="line">          <span class="comment">//第i个数分别与它后面的数字交换就能得到新的排列  </span></span><br><span class="line">            <span class="keyword">if</span> (IsSwap(pszStr, k, i))&#123;  </span><br><span class="line">                Swap(pszStr + k, pszStr + i);  </span><br><span class="line">                AllRange(pszStr, k + <span class="number">1</span>, m);  </span><br><span class="line">                Swap(pszStr + k, pszStr + i);  </span><br><span class="line">         &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">char</span> *pszStr)</span></span>&#123;  </span><br><span class="line">    AllRange(pszStr, <span class="number">0</span>, <span class="built_in">strlen</span>(pszStr) - <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归方法</p></li></ul><h3 id="表示数值的字符串（面试题54）"><a href="#表示数值的字符串（面试题54）" class="headerlink" title="表示数值的字符串（面试题54）"></a>表示数值的字符串（面试题54）</h3><p>【题目描述】</p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）</p><p>【思路】</p><ul><li>整数开始部分遇到+、-号跳过</li><li>小数点只能出现一次</li><li>小数点之前不能存在e</li><li>e之前必须有整数</li><li>e只能出现一次</li><li>e之后可以存在+、-号，但+ -之后必须有整数</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line">        ++str;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;    <span class="comment">//标记整数部分</span></span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>; <span class="comment">//标记小数点</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">0</span>;     <span class="comment">//标记e的状态</span></span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//标记整数部分的状态</span></span><br><span class="line">        <span class="keyword">if</span> (*str &gt;= <span class="string">'0'</span> &amp;&amp; *str &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line">            x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小数点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前面已经出现过小数点或小数点之前存在e，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (digit &gt; <span class="number">0</span> || e &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++str;</span><br><span class="line">            digit = <span class="number">1</span>;    <span class="comment">//标记小数点已经出现过</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//e</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//e之前没有整数或e已经出现过，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> || e &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++str;</span><br><span class="line">            e = <span class="number">1</span>;     <span class="comment">//标记e表示已经出现过</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//e之后可以出现+-号再加整数</span></span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line">                ++str;</span><br><span class="line">            <span class="keyword">if</span> (*str == <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="翻转单词顺序（面试题42）"><a href="#翻转单词顺序（面试题42）" class="headerlink" title="翻转单词顺序（面试题42）"></a>翻转单词顺序（面试题42）</h3><p>【题目描述】</p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。</p><p>【思路】</p><ol><li>按空格分割单词，然后按头插法插入到目标字符串中。原字符串最后一个单词需要单独处理</li><li>翻转两遍，第一遍翻转所有字符，第二遍翻转每个单词中字符的顺序。</li></ol><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">' '</span>)&#123;</span><br><span class="line">                tmp+=str[i];<span class="comment">//获取完整的一个单词</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result=<span class="string">' '</span>+tmp+result;<span class="comment">//插入到后面</span></span><br><span class="line">                tmp=<span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result=tmp+result;<span class="comment">//最后的单词单独处理，加在最后</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="左旋转字符串（面试题42）"><a href="#左旋转字符串（面试题42）" class="headerlink" title="左旋转字符串（面试题42）"></a>左旋转字符串（面试题42）</h3><p>【题目描述】</p><p>把字符串前面的若干个字符转移到字符串的尾部。</p><p>【思路】</p><ul><li>分别旋转前部分字符和后部分字符。如<code>abcdefg</code>把<code>ab</code>移动到<code>cdefg</code>后，则先旋转<code>ab</code>为<code>ba</code>，旋转<code>cdefg</code>为<code>gfedc</code></li><li>最后旋转整个字符串。如旋转<code>bagfedc</code>为<code>cdefgab</code></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(;begin&lt;end;begin++,end--)&#123;</span><br><span class="line">           <span class="keyword">char</span> tmp=str[begin];</span><br><span class="line">           str[begin]=str[end];</span><br><span class="line">           str[end]=tmp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">int</span> len=str.size();</span><br><span class="line">        <span class="keyword">int</span> firstStart=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> firstEnd=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> secondStart=n;</span><br><span class="line">        <span class="keyword">int</span> secondEnd=len<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//旋转前部分字符</span></span><br><span class="line">        reverse(str,firstStart,firstEnd);</span><br><span class="line">        <span class="comment">//旋转后部分字符</span></span><br><span class="line">        reverse(str,secondStart,secondEnd);</span><br><span class="line">        <span class="comment">//旋转全部字符</span></span><br><span class="line">        reverse(str,firstStart,secondEnd);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="从尾到头打印链表（面试题5）"><a href="#从尾到头打印链表（面试题5）" class="headerlink" title="从尾到头打印链表（面试题5）"></a>从尾到头打印链表（面试题5）</h3><p>【题目描述】输入一个链表的头结点，从尾到头反过来打印输出每个结点的值</p><p>【思路】</p><p>从头到尾遍历整个链表，每经过一个结点的时候，把该结点放到栈中，当遍历完整个链表后，再从栈顶开始逐个遍历结点。</p><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode *&gt; s;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            result.push_back(s.top()-&gt;val);</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="在O-1-时间删除链表结点（面试题13）"><a href="#在O-1-时间删除链表结点（面试题13）" class="headerlink" title="在O(1)时间删除链表结点（面试题13）"></a>在O(1)时间删除链表结点（面试题13）</h3><p>【题目描述】给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p><p>【思路】</p><p>本题与《编程之美》上的「从无头单链表中删除节点」类似。用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。</p><p>注意点：若链表中只有一个结点，而我们又要删除链表的头结点（也是尾结点），在删除结点后，需要把链表的头节点设置为NULL。</p><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(Node** pHead,Node* pDeleted)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!pHead || !pDeleted)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">if</span>(pDeleted-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    Node *pNext=pDeleted-&gt;next;</span><br><span class="line">    pDeleted-&gt;data=pNext-&gt;data;</span><br><span class="line">    pDeleted-&gt;data=pNext-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pNext;</span><br><span class="line">    pNext=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*pHead==pDeleted)&#123;</span><br><span class="line">    <span class="comment">//链表只有一个结点，删除头结点，也是尾结点</span></span><br><span class="line">    <span class="keyword">delete</span> pDeleted;</span><br><span class="line">    pDeleted=<span class="literal">NULL</span>;</span><br><span class="line">    *pHead=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//链表中有多个结点，删除尾结点</span></span><br><span class="line">    Node* pNode=*pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode-&gt;next != pDeleted)</span><br><span class="line">      pNode=pNode-&gt;next;</span><br><span class="line">    </span><br><span class="line">    pNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pDeleted;</span><br><span class="line">    pDeleted=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中倒数第k个结点（面试题15）"><a href="#链表中倒数第k个结点（面试题15）" class="headerlink" title="链表中倒数第k个结点（面试题15）"></a>链表中倒数第k个结点（面试题15）</h3><p>【题目描述】输入一个链表，输出该链表中倒数第k个结点。 本题从1开始计数，即链表的尾结点是倒数第1个结点。</p><p>【思路】</p><p>定义两个指针。</p><ul><li>第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动</li><li>从第k步开始，第二个指针也开始从链表的头指针开始遍历。</li><li>由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</li></ul><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *slowP=pListHead;</span><br><span class="line">        ListNode *fastP=pListHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pListHead == <span class="literal">NULL</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fastP-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">                fastP=fastP-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fastP-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fastP=fastP-&gt;next;</span><br><span class="line">            slowP=slowP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowP;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="链表逆置（面试题16）"><a href="#链表逆置（面试题16）" class="headerlink" title="链表逆置（面试题16）"></a>链表逆置（面试题16）</h3><p>【题目描述】：输入一个单向链表，输出逆序反转后的链表</p><h4 id="三指针方法"><a href="#三指针方法" class="headerlink" title="三指针方法"></a>三指针方法</h4><p>【思路】：非递归方法即就地逆置法，用三个临时指针pre,head,next在链表循环即可。</p><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表转置，循环方法</span></span><br><span class="line"> <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode *next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pHead!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next=pHead-&gt;next;</span><br><span class="line">            pHead-&gt;next=pre;</span><br><span class="line">            pre=pHead;</span><br><span class="line">            pHead=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h4><p>【思路】</p><p>同<code>从尾到头打印单链表（面试题5）</code>类似</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode* p=pHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从栈里建立新链表,尾插法建立新链表</span></span><br><span class="line">        ListNode *result=s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        p=result;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            p-&gt;next=s.top();</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            s.pop();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后不要忘了终端节点指针域置为空</span></span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个排序的链表（面试题17）"><a href="#合并两个排序的链表（面试题17）" class="headerlink" title="合并两个排序的链表（面试题17）"></a>合并两个排序的链表（面试题17）</h3><p>【题目描述】输入两个递增排序的链表，合并这两个链表并使新联中的结点仍然是按照递增排序的。</p><p>【思路】</p><ul><li>若第一个链表是空链表，则结果是第二个链表</li><li>若第二个链表是空链表，则结果是第一个链表</li><li>若两个链表都是空指针，则结果是空链表</li><li>采用递归方法，比较两个链表中值较小的头结点并把它链接到已经合并的链表之后，因为两个链表的结点仍然是有序的，因此采用递归方法完成合并过程</li></ul><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">NULL</span> &amp;&amp; pHead2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *result;</span><br><span class="line">        <span class="comment">//采用递归的方法创建单链表，最后返回的result单链表是由一层层返回逆序链接好的单链表结果组合成的。</span></span><br><span class="line">        <span class="comment">//相当于倒着一层层返回由上一个排序好的子链表</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)&#123;</span><br><span class="line">            result=pHead1;</span><br><span class="line">            result-&gt;next=Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result=pHead2;</span><br><span class="line">            result-&gt;next=Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="两个链表的第一个公共结点（面试题37）"><a href="#两个链表的第一个公共结点（面试题37）" class="headerlink" title="两个链表的第一个公共结点（面试题37）"></a>两个链表的第一个公共结点（面试题37）</h3><p>【题目描述】输入两个链表，找出它们的第一个公共结点</p><p>【思路】O(m+n)</p><ul><li>遍历两个链表得到它们的长度。计算出哪个链表长，并比短的多几个结点</li><li>在第二次遍历时，在较长的链表上先走若干步，接着再同时在两个链表遍历，找到的第一个相同的结点就是第一个公共结点。</li></ul><p>【题解】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len1=GetLength(pHead1);</span><br><span class="line">    <span class="keyword">int</span> len2=GetLength(pHead2);</span><br><span class="line">    <span class="keyword">int</span> diff=<span class="number">0</span>;</span><br><span class="line">    ListNode *fastIndex,*slowIndex;</span><br><span class="line">    <span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line">        diff=len1-len2;</span><br><span class="line">        fastIndex=pHead1;</span><br><span class="line">        slowIndex=pHead2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        diff=len2-len1;</span><br><span class="line">        fastIndex=pHead2;</span><br><span class="line">        slowIndex=pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;diff;i++)&#123;</span><br><span class="line">        fastIndex=fastIndex-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fastIndex != <span class="literal">NULL</span> &amp;&amp; slowIndex != <span class="literal">NULL</span> &amp;&amp; fastIndex != slowIndex)&#123;</span><br><span class="line">        fastIndex=fastIndex-&gt;next;</span><br><span class="line">        slowIndex=slowIndex-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    ListNode *s=root;</span><br><span class="line">    <span class="keyword">while</span>(s!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        s=s-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断单链表是否有环"><a href="#判断单链表是否有环" class="headerlink" title="判断单链表是否有环"></a>判断单链表是否有环</h3><p>【题目描述】</p><p><strong>单链表有环的定义：</strong>链表的尾节点指向了链接中间的某个节点。</p><p>如下图所示，如果有环，则遍历到结点7时，又重新回到结点3，结点3就是环的入口结点。</p><p><img src="https://images2015.cnblogs.com/blog/509374/201603/509374-20160329220459738-2046143200.png" alt="img"></p><p>【思路】</p><p>采用快慢指针的思想，设两个工作指针，一个快一个慢，比如一个每次走一步，另一个每次走两步，如果链表有环，必定会在某个结点处相遇。</p><p>具体流程：</p><ul><li>可以设置两个指针(fast,slow)，初始值均指向头，slow每次向前一步，fast每次向前两步；</li><li>如果链表中有环，则fast先进入环中，而slow后进入环中，两个指针在环中必定相遇;</li><li>如果fast遍历到尾部为NULL，则无环</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasLoop</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">  Node *p1,p2;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//链表为空，或者是单结点链表返回头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  p1=p2=head;</span><br><span class="line">  <span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    p1=p1-&gt;next-&gt;next;</span><br><span class="line">    p2=p2-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p1==p2)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中环的入口结点（面试题56）"><a href="#链表中环的入口结点（面试题56）" class="headerlink" title="链表中环的入口结点（面试题56）"></a>链表中环的入口结点（面试题56）</h3><p>【题目描述】</p><p>一个链表中包含环，请找出该链表的环的入口结点。</p><p>【思路】</p><p>两个指针一个快fast，一个慢slow。两个指针同时从一个链表的头部出发。</p><p>fast指针一次走两步，slow一次走一步。</p><ul><li>若该链表有环，则两个指针必然在环内相遇</li><li>若有环则把其中一个指针重新指向链表头部，另一个不变（还在环内），两个指针每次都走一步，相遇的地方即是入口结点。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pHead==<span class="literal">NULL</span> || pHead-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *fastP=pHead;</span><br><span class="line">    ListNode *slowP=pHead;</span><br><span class="line">    <span class="keyword">bool</span> isCycle=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(fastP-&gt;next!=<span class="literal">NULL</span> &amp;&amp; fastP-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">        slowP=slowP-&gt;next;</span><br><span class="line">        fastP=fastP-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fastP==slowP)&#123;</span><br><span class="line">            isCycle=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isCycle)&#123;</span><br><span class="line">        slowP=pHead;</span><br><span class="line">        <span class="keyword">while</span>(slowP!=<span class="literal">NULL</span> &amp;&amp; fastP!=<span class="literal">NULL</span> &amp;&amp; slowP!=fastP)&#123;</span><br><span class="line">            slowP=slowP-&gt;next;</span><br><span class="line">            fastP=fastP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowP;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表中重复的结点（面试题57）"><a href="#删除链表中重复的结点（面试题57）" class="headerlink" title="删除链表中重复的结点（面试题57）"></a>删除链表中重复的结点（面试题57）</h3><p>【题目】</p><p>在一个排序的链表中，如何删除重复的结点。</p><p>【思路】</p><p>设置一个头结点，然后根据情况遍历</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pHead==<span class="literal">NULL</span> || pHead-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">           <span class="keyword">return</span> pHead;</span><br><span class="line">       ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">       ListNode *p=head;</span><br><span class="line">       ListNode *q=pHead;</span><br><span class="line">       <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(q!=<span class="literal">NULL</span> &amp;&amp; q-&gt;next!=<span class="literal">NULL</span> &amp;&amp; q-&gt;next-&gt;val==q-&gt;val)&#123;</span><br><span class="line">               <span class="keyword">int</span> tmp=q-&gt;val;</span><br><span class="line">               <span class="keyword">while</span>(q!=<span class="literal">NULL</span> &amp;&amp; q-&gt;val==tmp)</span><br><span class="line">                   q=q-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           p-&gt;next=q;</span><br><span class="line">           p=p-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">               q=q-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="用两个栈实现队列（面试题7）"><a href="#用两个栈实现队列（面试题7）" class="headerlink" title="用两个栈实现队列（面试题7）"></a>用两个栈实现队列（面试题7）</h3><p>【题目描述】</p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>【思路】</p><p>利用两个栈stack1和stack2实现队列。</p><ul><li><p>Push操作</p><p>直接将元素压入stack1即可。</p></li><li><p>Pop操作</p><ul><li>当stack2非空时，直接弹出栈顶元素</li><li>当stack2为空时，把stack1中的元素逐个弹出并压入stack2，再弹出栈顶元素。</li></ul></li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="包含min函数的栈（面试题21）"><a href="#包含min函数的栈（面试题21）" class="headerlink" title="包含min函数的栈（面试题21）"></a>包含min函数的栈（面试题21）</h3><p>【题目描述】</p><p>定义栈的数据结构，请在该类型中实现一个能得到栈的最小元素的min函数</p><p>【思路】</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="最小的k个数（面试题30）"><a href="#最小的k个数（面试题30）" class="headerlink" title="最小的k个数（面试题30）"></a>最小的k个数（面试题30）</h3><p>【题目描述】</p><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><p>【思路】</p><ul><li>使用堆，在STL中set和multiset都是基于红黑树实现的。</li><li>用最大堆保存这k个数，每次只和堆顶比<ul><li>如果比堆顶小，删除堆顶，新数入堆。</li><li>如果比堆顶大，则丢弃，因为要求的是最小的k个数，比堆顶还大则不可能是最小的数</li></ul></li><li>O(nlogk)</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">       <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt; &gt; leastNumbers;</span><br><span class="line">       <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator greaterIt;</span><br><span class="line">       <span class="keyword">int</span> len=input.size();</span><br><span class="line">       <span class="keyword">if</span>(len&lt;<span class="number">0</span> || k&lt;<span class="number">0</span> || len&lt;k)</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vi;</span><br><span class="line">       <span class="keyword">for</span>(vi=input.begin();vi != input.end(); vi++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(leastNumbers.size() &lt; k)</span><br><span class="line">               leastNumbers.insert(*vi);</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               greaterIt=leastNumbers.begin();</span><br><span class="line">               <span class="keyword">if</span>(*greaterIt&gt;*vi)&#123;</span><br><span class="line">                   leastNumbers.erase(greaterIt);</span><br><span class="line">                   leastNumbers.insert(*vi);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(greaterIt=leastNumbers.begin();greaterIt!=leastNumbers.end();greaterIt++)</span><br><span class="line">           result.push_back(*greaterIt);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的子结构（面试题18）"><a href="#树的子结构（面试题18）" class="headerlink" title="树的子结构（面试题18）"></a>树的子结构（面试题18）</h3><p>【题目描述】</p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>【思路】</p><ul><li>分成两步<ul><li>第一步在树A中找到和树B的根结点的值一样的结点R</li><li>再判断树A中以R为根结点的子树是不是包含和树B一样的结构</li></ul></li><li>采用递归方法</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*思路：参考剑指offer</span></span><br><span class="line"><span class="comment">1、首先设置标志位result = false，因为一旦匹配成功result就设为true，</span></span><br><span class="line"><span class="comment">剩下的代码不会执行，如果匹配不成功，默认返回false</span></span><br><span class="line"><span class="comment">2、递归思想，如果根节点相同则递归调用DoesTree1HaveTree2（），</span></span><br><span class="line"><span class="comment">如果根节点不相同，则判断tree1的左子树和tree2是否相同，</span></span><br><span class="line"><span class="comment">再判断右子树和tree2是否相同</span></span><br><span class="line"><span class="comment">3、注意null的条件，HasSubTree中，如果两棵树都不为空才进行判断，</span></span><br><span class="line"><span class="comment">DoesTree1HasTree2中，如果Tree2为空，则说明第二棵树遍历完了，即匹配成功，</span></span><br><span class="line"><span class="comment">tree1为空有两种情况（1）如果tree1为空&amp;&amp;tree2不为空说明不匹配，</span></span><br><span class="line"><span class="comment">（2）如果tree1为空，tree2为空，说明匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//当Tree1和Tree2都不为空的时候，才进行比较。否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果找到了Tree A对应Tree B的根结点的结点</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">            <span class="comment">//以这个根结点为起点判断是否包含Tree2</span></span><br><span class="line">            result=DoesTree1HaveTree2(pRoot1,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">            <span class="comment">//如果找不到，那么就再去root的左孩子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            result=HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">             <span class="comment">//如果还找不到，那么就再去root的右孩子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            result=HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode *node1,TreeNode *node2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">    <span class="keyword">if</span>(node2==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">    <span class="keyword">if</span>(node1==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(node1-&gt;val != node2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">    <span class="keyword">return</span> DoesTree1HaveTree2(node1-&gt;left,node2-&gt;left) &amp;&amp; DoesTree1HaveTree2(node2-&gt;right,node2-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的镜像（面试题19）"><a href="#树的镜像（面试题19）" class="headerlink" title="树的镜像（面试题19）"></a>树的镜像（面试题19）</h3><p>【题目描述】</p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>【思路】</p><p>类同二叉树的翻转，先翻转左子树，再翻转右子树，然后对整个树进行翻转</p><p>【题解】</p><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::invertTree(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    swap(node-&gt;lchild,node-&gt;rchild);</span><br><span class="line">    invertTree(node-&gt;lchild);</span><br><span class="line">    invertTree(node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><p>利用队列。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::invertTreeNonRec(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiNode *&gt; q;</span><br><span class="line">    q.push(node);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        BiNode *cur=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        BiNode *tmp=cur-&gt;lchild;</span><br><span class="line">        cur-&gt;lchild=cur-&gt;rchild;</span><br><span class="line">        cur-&gt;rchild=tmp;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            q.push(cur-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            q.push(cur-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上往下打印二叉树（面试题23）"><a href="#从上往下打印二叉树（面试题23）" class="headerlink" title="从上往下打印二叉树（面试题23）"></a>从上往下打印二叉树（面试题23）</h3><p>【题目描述】</p><p>从上往下打印二叉树各个结点，同层结点从左至右打印。</p><p>【思路】</p><p>利用队列实现层序遍历</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    TreeNode *s;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        s=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        result.push_back(s-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            q.push(s-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            q.push(s-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的后序遍历序列（面试题24）"><a href="#二叉搜索树的后序遍历序列（面试题24）" class="headerlink" title="二叉搜索树的后序遍历序列（面试题24）"></a>二叉搜索树的后序遍历序列（面试题24）</h3><p>【题目描述】</p><p>输入一个整数数组，判断该数组是否为某棵二叉搜索树的后序遍历的结果</p><p>【思路】</p><p>条件：</p><ul><li>根结点是后序遍历序列中的最后一个数。</li><li>二叉搜索树左子树值都比根结点小，右孩子值都比根结点大。</li></ul><p>方法：</p><ul><li>确定根结点</li><li>遍历除去根结点的序列，找到第一个比根结点大的位置，左边是左子树，右边是右子树</li><li>遍历右子树，若存在小于根结点的值，直接返回false</li><li>分别判断左子树和右子树是否是二叉搜索树（即递归步骤1、2、3）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len=sequence.size();</span><br><span class="line">        <span class="keyword">int</span> root=sequence[len<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//划分左右子树界限</span></span><br><span class="line">        <span class="comment">//寻找左右子树界限</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            index=i;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历右子树，是否符合右子树的值都大于根结点的规律</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftSequence,rightSequence;</span><br><span class="line">        <span class="comment">//判断是否有左子树</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">                leftSequence.push_back(sequence[i]);</span><br><span class="line">        <span class="comment">//判断是否有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(index != len<span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">                rightSequence.push_back(sequence[i]);</span><br><span class="line">        <span class="comment">//左右子树是否为二叉搜索树</span></span><br><span class="line">        <span class="keyword">bool</span> isLeft=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> isRight=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftSequence.size()&gt;<span class="number">1</span>)</span><br><span class="line">            isLeft=VerifySquenceOfBST(leftSequence);</span><br><span class="line">        <span class="keyword">if</span>(rightSequence.size()&gt;<span class="number">1</span>)</span><br><span class="line">            isRight=VerifySquenceOfBST(rightSequence);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (isLeft&amp;&amp;isRight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的深度（面试题39）"><a href="#二叉树的深度（面试题39）" class="headerlink" title="二叉树的深度（面试题39）"></a>二叉树的深度（面试题39）</h3><p>【题目描述】</p><p>输入一棵二叉树，求该树的深度。</p><p>【思路】</p><ul><li>如果一棵树只有一个结点，则深度为1；</li><li>如果根结点只有左子树而没有右子树，则深度为其左子树深度+1</li><li>如果根结点只有右子树而没有左子树，则深度为其右子树深度+1</li><li>如果既有左子树又有右子树，则深度是左、右子树深度的较大值+1</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> leftDepth=TreeDepth(pRoot-&gt;left);</span><br><span class="line">     <span class="keyword">int</span> rightDepth=TreeDepth(pRoot-&gt;right);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> (leftDepth&gt;rightDepth)?(leftDepth+<span class="number">1</span>):(rightDepth+<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="判断平衡二叉树（面试题39）"><a href="#判断平衡二叉树（面试题39）" class="headerlink" title="判断平衡二叉树（面试题39）"></a>判断平衡二叉树（面试题39）</h3><p>【题目描述】</p><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>【思路】</p><p>用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前就已经遍历了它的左右子树。</p><p>只要在遍历每个结点的时候记录它的深度，就可以一边遍历一边判断每个结点是否平衡。</p><ul><li>如果子树是平衡二叉树，则返回子树高度</li><li>如果子树不是平衡二叉树，直接停止遍历</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced</span><span class="params">(TreeNode* root,<span class="keyword">int</span> *depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            *depth=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightDepth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(IsBalanced(root-&gt;left,&amp;leftDepth) &amp;&amp; IsBalanced(root-&gt;right,&amp;rightDepth))&#123;</span><br><span class="line">            <span class="keyword">int</span> diff=leftDepth-rightDepth;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(diff)&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                *depth=<span class="number">1</span>+(leftDepth&gt;rightDepth?leftDepth:rightDepth);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced(pRoot,&amp;depth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的第k个结点（面试题63）"><a href="#二叉搜索树的第k个结点（面试题63）" class="headerlink" title="二叉搜索树的第k个结点（面试题63）"></a>二叉搜索树的第k个结点（面试题63）</h3><p>【题目描述】</p><p>给定一棵二叉搜索树，请找出其中的第k个的结点。</p><p>【思路】</p><p>按中序遍历可以找出第k个的结点。</p><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归遍历二叉树</span></span><br><span class="line"><span class="comment">//先将左孩子都存在栈中，从最左孩子开始遍历。</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p=pRoot;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                p=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count==k)<span class="comment">//如果已经是第k个结点，则返回</span></span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="连续子数组的最大和（面试题31）"><a href="#连续子数组的最大和（面试题31）" class="headerlink" title="连续子数组的最大和（面试题31）"></a>连续子数组的最大和（面试题31）</h3><p>【题目描述】</p><p>输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><p>【思路】</p><ul><li>dp[i]表示以A[i]作为末尾的连续序列的最大和，最大和即dp[0],dp[1],dp[2],….,dp[n-1]中的最大值。</li><li>因为dp[i]要求是必须以A[i]结尾的连续序列，那么只有两种情况<ul><li>最大和的连续序列只有一个元素，即以A[i]开始，A[i]结尾。即A[i]本身</li><li>最大和的连续序列有多个元素，即从前面某处A[p]开始，一直到A[i]结尾。即dp[i-1]+A[i]</li></ul></li><li>得到结论<ul><li>状态转移方程：dp[i]=max{A[i],dp[i-1]+A[i]}</li><li>边界：dp[0]=A[0]</li></ul></li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="built_in">array</span>.begin(),<span class="built_in">array</span>.end());<span class="comment">//dp用来存放以A[i]结尾的连续序列的最大和</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="built_in">array</span>[<span class="number">0</span>];<span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">            dp[i]=max(<span class="built_in">array</span>[i],dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i]);<span class="comment">//状态转移方程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;dp[index])</span><br><span class="line">                index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="斐波那契数列-面试题9"><a href="#斐波那契数列-面试题9" class="headerlink" title="斐波那契数列(面试题9)"></a>斐波那契数列(面试题9)</h3><p>【题目描述】</p><p>输入n，求斐波那契数列的第n项。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180408/4E3jAL1LCe.png?imageslim" alt="mark"></p><p>【思路】</p><ul><li>根据<code>f(0)</code>和<code>f(1)</code>算出<code>f(2)</code>，再根据<code>f(1)</code>和<code>f(2)</code>算出<code>f(3)</code>，以此类推。</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> firstItem=<span class="number">0</span>;<span class="comment">//相加的第一项</span></span><br><span class="line">    <span class="keyword">int</span> secondItem=<span class="number">1</span>;<span class="comment">//相加的第二项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        result=firstItem+secondItem;</span><br><span class="line">        firstItem=secondItem;</span><br><span class="line">        secondItem=result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳台阶（面试题9的变形）"><a href="#跳台阶（面试题9的变形）" class="headerlink" title="跳台阶（面试题9的变形）"></a>跳台阶（面试题9的变形）</h3><p>【题目描述】</p><p>一只青蛙一次可以跳1级台阶，也可以跳2级台阶，求该青蛙跳上一个n级台阶总共有多少种跳法。</p><p>【思路】</p><ul><li><p>把n级台阶跳法看成n的函数f(n)。</p></li><li><p>如果两种跳法，1级或2级，假定第一次跳的是1级，则剩下n-1级台阶，跳法是f(n-1)。</p></li><li><p>假定第一次跳的是2级，则剩下的n-2级台阶，跳法是f(n-2)</p></li><li><p>由a、b可总结出跳法是f(n)=f(n-1)+f(n-2)</p></li><li><p>根据题意，只有一级台阶时f(1)=1,只有两级台阶时f(2)=2</p></li><li><p>最后是一个斐波那契数列<br>$$<br>\begin{equation}<br>f(n)=\left{<br>\begin{aligned}<br>1&amp; &amp; (n=1) \<br>2 &amp;  &amp; (n=2) \<br>f(n-1)+f(n-2)&amp;   &amp;(n&gt;2)<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> firstItem=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> secondItem=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)&#123;</span><br><span class="line">            result=firstItem+secondItem;</span><br><span class="line">            firstItem=secondItem;</span><br><span class="line">            secondItem=result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h2&gt;&lt;h3 id=&quot;二进制中1的个数-（面试题10）&quot;&gt;&lt;a href=&quot;#二进制中1的个数-（面试题10）&quot; class=&quot;headerlink&quot; title=&quot;二进制中1的个数 （面试题10）&quot;&gt;&lt;/a&gt;二进制中1的个数 （面试题10）&lt;/h3&gt;&lt;p&gt;【题目描述】&lt;/p&gt;
&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;p&gt;【思路】&lt;/p&gt;
&lt;p&gt;把一个整数减去1，再和原整数做&lt;code&gt;与&lt;/code&gt;运算，会把该整数最右边一个1变成0，则一个整数的二进制有多少个1，就可以进行多少次这样的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://tianwenyu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tianwenyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】面试算法题总结</title>
    <link href="https://tianwenyu.github.io/algorithm-interview/"/>
    <id>https://tianwenyu.github.io/algorithm-interview/</id>
    <published>2018-03-20T11:29:36.000Z</published>
    <updated>2018-05-04T07:42:35.627Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiSearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="literal">NULL</span> || size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high=size<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;key)</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180409/4e4Imi609e.png?imageslim" alt="mark"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一次划分，选取第一个记录作为关键码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=first;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> j=end;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=a[j])<span class="comment">//右侧扫描</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;<span class="comment">//将较小的记录交换到前面</span></span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=a[j])<span class="comment">//左侧扫描</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            swap(a[i],a[j]);<span class="comment">//将较大的记录交换到后面</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整个快排的过程可递归进行，若待排序序列中只有一个记录，则结束递归，否则进行一次划分后，再分别对划分得到的两个子序列进行快排（即递归处理）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first&lt;end)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=partition(a,first,end);</span><br><span class="line">        quickSort(a,first,pivot<span class="number">-1</span>);</span><br><span class="line">        quickSort(a,pivot+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>【思路】</p><ul><li><p>设置exchange变量记载每次记录交换的位置，则一趟排序后，exchange记载的一定是这趟排序中记录的最后一次交换的位置，从此位置后所有记录均有序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r[j]&gt;r[j+<span class="number">1</span>])&#123;</span><br><span class="line">  swap(r[j],r[j+<span class="number">1</span>]);</span><br><span class="line">  exchange=j;<span class="comment">//记载每一次记录交换的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设bound位置的记录是无序区的最后一个记录，则每趟冒泡排序的范围是r[1]~r[bound]。在一趟排序后，exchange位置之后的记录一定是有序的，所以下一趟冒泡排序汇总无序区的最后一个记录的位置是exchange，即bound=exchange</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bound;j++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(r[j]&gt;r[j+<span class="number">1</span>])&#123;</span><br><span class="line">    swap(r[j],r[j+<span class="number">1</span>]);</span><br><span class="line">    exchange=j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判别冒泡排序的结束条件应该是在一趟排序过程中没有进行交换记录的操作。为此，在每趟冒泡排开始之前，设exchange初值为0，在该趟排序的过程中，只要有记录的交换，则exchange值大于0.</p><p>通过exchange的值是否为0可以判断是否有记录的交换，从而判断整个冒泡排序是否结束。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(exchange != <span class="number">0</span>)&#123;</span><br><span class="line">  bound=exchagne;</span><br><span class="line">  exchange=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bound;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(r[j]&gt;r[j+<span class="number">1</span>])&#123;</span><br><span class="line">      swap(r[j],r[j+<span class="number">1</span>]);</span><br><span class="line">      exchange=j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>【实现】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> exchange=n;<span class="comment">//第一趟冒泡排序的区间是[1,n]</span></span><br><span class="line">    <span class="keyword">while</span>(exchange != <span class="number">0</span>)&#123;<span class="comment">//当上一趟排序有记录交换时</span></span><br><span class="line">        <span class="keyword">int</span> bound=exchange;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bound;i++)&#123;<span class="comment">//一趟冒泡排序，区间是[1,bound]</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">                exchange=i;<span class="comment">//记载每一次记录交换的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h3><p>以最大堆进行升序排序为例</p><ul><li>初始化堆：即构造堆</li><li>交换数据，调整堆</li></ul><p><img src="https://images0.cnblogs.com/i/497634/201403/151545571211442.jpg" alt="img"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DownAdjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">//i是指欲调整结点</span></span><br><span class="line">    <span class="keyword">int</span> lchild=<span class="number">2</span>*i;</span><br><span class="line">    <span class="keyword">int</span> rchild=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIndex=i;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=size/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lchild&lt;=size &amp;&amp; a[lchild] &gt; a[maxIndex])</span><br><span class="line">            maxIndex=lchild;</span><br><span class="line">        <span class="keyword">if</span>(rchild&lt;=size &amp;&amp; a[rchild] &gt; a[maxIndex])</span><br><span class="line">            maxIndex=rchild;</span><br><span class="line">        <span class="keyword">if</span>(maxIndex != i)&#123;  <span class="comment">//如果最大值maxIndex更新了</span></span><br><span class="line">            swap(a[maxIndex],a[i]);</span><br><span class="line">            DownAdjust(a,maxIndex,size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建堆，对每一个非叶结点进行堆调整（从最后一个非叶结点开始）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)  <span class="comment">//注意：这里从(size/2)开始到1</span></span><br><span class="line">        DownAdjust(a,i,size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    BuildHeap(a,size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        swap(a[<span class="number">1</span>],a[i]);    <span class="comment">//将堆顶放在末尾</span></span><br><span class="line">        DownAdjust(a,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">//将未完成排序的部分进行堆排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">8</span>] = &#123;<span class="number">8</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    HeapSort(<span class="built_in">array</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span>    <span class="comment">//字典树定义</span></span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> num;    <span class="comment">//以当前字符串为前缀的单词的数量</span></span><br><span class="line">    Trie()    <span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> word[])</span>    <span class="comment">//将字符串word插入到字典树中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie *p = &amp;root;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;word[i];i++)&#123;    <span class="comment">//遍历word的每一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[word[i]-<span class="string">'a'</span>]==<span class="literal">NULL</span>)    <span class="comment">//如果该字符没有对应的节点</span></span><br><span class="line">            p-&gt;next[word[i]-<span class="string">'a'</span>] = <span class="keyword">new</span> Trie;    <span class="comment">//创建一个</span></span><br><span class="line">        p = p-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">        p-&gt;num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> word[])</span>    <span class="comment">//返回以字符串word为前缀的单词的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie *p = &amp;root;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;word[i];i++)&#123;    <span class="comment">//在字典树找到该单词的结尾位置</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[word[i]-<span class="string">'a'</span>]==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = p-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树结点结构"><a href="#树结点结构" class="headerlink" title="树结点结构"></a>树结点结构</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    BiNode *lchild,*rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h3><p>此处是按先序序列构造一颗二叉树</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BiNode *BiTree::Create()&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    c=<span class="built_in">cin</span>.get();</span><br><span class="line">    BiNode *pnode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'#'</span>)</span><br><span class="line">        pnode=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pnode=<span class="keyword">new</span> BiNode;</span><br><span class="line">        pnode-&gt;data=c;</span><br><span class="line">        pnode-&gt;lchild=Create();</span><br><span class="line">        pnode-&gt;rchild=Create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>【访问顺序】根左右</p><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::PreOrder(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)            <span class="comment">//递归调用的结束条件</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;data;       <span class="comment">//访问根节点的数据域</span></span><br><span class="line">        PreOrder(node-&gt;lchild); <span class="comment">//前序递归遍历左子树</span></span><br><span class="line">        PreOrder(node-&gt;rchild); <span class="comment">//前序递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><p>【思路】</p><p>对任一结点</p><ol><li>访问结点p，并将p入栈</li><li>判断结点p的左孩子是否为空<ul><li>若为空，则弹出栈顶结点，将栈顶结点的右孩子置为当前结点p，循环至1</li><li>若不为空，则将结点p的左孩子置为当前结点p</li></ul></li><li>直到结点p为NULl且栈为空，遍历结束。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::PreOrderNonRec(BiNode *node)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiNode *&gt; s;</span><br><span class="line">    BiNode *p=node;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>【访问顺序】左根右</p><h4 id="递归方法-1"><a href="#递归方法-1" class="headerlink" title="递归方法"></a>递归方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::InOrder(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        InOrder(node-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;data;</span><br><span class="line">        InOrder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法-1"><a href="#非递归方法-1" class="headerlink" title="非递归方法"></a>非递归方法</h4><p>对于任一结点p：</p><ol><li>判断当前结点p左孩子结点是否为空<ul><li>若其左孩子结点不为空，则将p入栈，并将p的左孩子结点置为当前p，对当前结点p做相同处理。</li><li>若其左孩子结点为空，则弹出栈顶结点，将当前结点p置为栈顶结点的右孩子结点。</li></ul></li><li>直到当前结点p为NULL且栈为空，遍历结束。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::InOrderNonRec(BiNode *node)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiNode *&gt; s;</span><br><span class="line">    BiNode *p=node;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>【访问顺序】左右根</p><h4 id="递归方法-2"><a href="#递归方法-2" class="headerlink" title="递归方法"></a>递归方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::PostOrder(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        PostOrder(node-&gt;lchild);</span><br><span class="line">        PostOrder(node-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法-2"><a href="#非递归方法-2" class="headerlink" title="非递归方法"></a>非递归方法</h4><p>【思路】要保证根结点在左孩子和右孩子访问之后才能访问。</p><p>对于任一结点p，</p><ol><li>将p入栈<ul><li>若结点p不存在左孩子结点和右孩子结点，则直接访问该结点p；</li><li>若结点p存在左孩子结点或右孩子结点，但其左孩子结点和右孩子结点都已被访问，则直接访问该结点p</li></ul></li><li>若非上述两种情况，则将结点p的右孩子结点和左孩子结点依次入栈，这就保证了每次取栈顶元素时，左孩子在右孩子前面被访问，左孩子和右孩子在根结点前被访问。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::PostOrderNonRec(BiNode *node)&#123;</span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiNode *&gt; s;</span><br><span class="line">    BiNode *p;<span class="comment">//当前结点</span></span><br><span class="line">    BiNode *pre=<span class="literal">NULL</span>;<span class="comment">//前一次访问的结点</span></span><br><span class="line"></span><br><span class="line">    s.push(node);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        p=s.top();</span><br><span class="line">        <span class="comment">//如果当前结点没有孩子结点或孩子结点都被访问过</span></span><br><span class="line">        <span class="keyword">if</span>((p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>)||(pre!=<span class="literal">NULL</span>&amp;&amp;(pre==p-&gt;lchild || pre==p-&gt;rchild)))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">            s.pop();</span><br><span class="line">            pre=p;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">                s.push(p-&gt;rchild);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">                s.push(p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历需要用到队列，使用<code>#include&lt;queue&gt;</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180326/20HgFe8FGe.png?imageslim" alt="mark"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::LevelOrder(BiNode *node)&#123;</span><br><span class="line">    <span class="comment">//使用队列实现</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;BiNode*&gt; q;</span><br><span class="line">    BiNode *s=node;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        s=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            q.push(s-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            q.push(s-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>【思路】</p><p>即前中后序三种遍历方式。</p><p>这里给出深度优先前序遍历的另一种实现方式，利用栈。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::DFS(BiNode *node)&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BiNode*&gt; s;</span><br><span class="line">    BiNode *p;</span><br><span class="line">    s.push(node);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        p=s.top();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            s.push(p-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            s.push(p-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>【思路】</p><p>即层次遍历</p><h3 id="求深度"><a href="#求深度" class="headerlink" title="求深度"></a>求深度</h3><p>【思路】</p><ul><li>每个节点都有自己的左右子树</li><li>每次返回当前节点左右子树长度大的那个</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BiTree::GetTreeDepth(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">int</span> lchildDep=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rchildDep=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果根节点为空，深度为0，返回0，递归的出口</span></span><br><span class="line">    <span class="comment">//否则深度至少为1，然后累加它们左右子树的深度</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    lchildDep+=GetTreeDepth(node-&gt;lchild);</span><br><span class="line">    rchildDep+=GetTreeDepth(node-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (lchildDep&gt;rchildDep)?(lchildDep):(rchildDep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求两个节点距离"><a href="#求两个节点距离" class="headerlink" title="求两个节点距离"></a>求两个节点距离</h3><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180327/mif6Lg5jHL.png?imageslim" alt="mark"></p><h4 id="递归方法-3"><a href="#递归方法-3" class="headerlink" title="递归方法"></a>递归方法</h4><p>【思路】先翻转左子树，再翻转右子树，然后对整个树进行翻转</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::invertTree(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    swap(node-&gt;lchild,node-&gt;rchild);</span><br><span class="line">    invertTree(node-&gt;lchild);</span><br><span class="line">    invertTree(node-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归方法-3"><a href="#非递归方法-3" class="headerlink" title="非递归方法"></a>非递归方法</h4><p>【思路】</p><p>与二叉树的层序遍历类似，需要queue实现</p><p>把根结点入队列，从队列中取出，交换左右孩子结点。若存在则分别将左右孩子结点入队，以此类推直到队列中没有结点则停止。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BiTree::invertTreeNonRec(BiNode *node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiNode *&gt; q;</span><br><span class="line">    q.push(node);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        BiNode *cur=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        BiNode *tmp=cur-&gt;lchild;</span><br><span class="line">        cur-&gt;lchild=cur-&gt;rchild;</span><br><span class="line">        cur-&gt;rchild=tmp;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            q.push(cur-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            q.push(cur-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>【概念】</p><p>中缀表达式是指运算符在运算数中间。</p><p>【思路】</p><p>需要两个栈：操作数栈和操作符栈</p><ul><li>如果是数字，压入操作数栈。</li><li>如果是操作符<ul><li>当前是加减法<ul><li>若栈顶是加减乘除，则计算栈内直到操作符栈顶不是加减乘除或为空，压栈。</li><li>否则直接压栈。</li></ul></li><li>当前是乘除法<ul><li>若栈顶是乘除，计算直到操作符栈顶不是乘除或者为空，压栈。</li><li>否则直接压栈。</li></ul></li><li>当前是左括号，压栈。</li><li>当前是右括号，计算直到遇到左括号。</li></ul></li></ul><p>当所有的分析完后，循环计算栈顶直到操作符栈为空，此时操作数栈里只有一个元素，即最后的结果。</p><p>【范例】</p><p><code>1 + 2 *（3 + 4 * 5）</code></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>计算过程</td><td>数栈</td><td>操作符栈</td></tr><tr><td>1</td><td>1</td><td></td></tr><tr><td>2</td><td>1</td><td>+</td></tr><tr><td>3</td><td>1、2</td><td>+</td></tr><tr><td>4</td><td>1、2</td><td>+、*</td></tr><tr><td>5</td><td>1、2、（</td><td>+、*</td></tr><tr><td>6</td><td>1、2、（、3</td><td>+、*</td></tr><tr><td>7</td><td>1、2、（、3</td><td>+、*、+</td></tr><tr><td>8</td><td>1、2、（、3、4</td><td>+、*、+</td></tr><tr><td>9</td><td>1、2、（、3、4</td><td>+、<em>、+、</em></td></tr><tr><td>10.1</td><td>1、2、（、3、4、5</td><td>+、<em>、+、</em></td></tr><tr><td>10.2</td><td>1、2、（、3、20</td><td>+、*、+</td></tr><tr><td>11</td><td>1、2、23</td><td>+、*</td></tr><tr><td>12</td><td>1、46</td><td>+</td></tr><tr><td>13</td><td>47</td></tr></tbody></table><p><a href="https://blog.csdn.net/wangzengdi/article/details/47023653" target="_blank" rel="external">https://blog.csdn.net/wangzengdi/article/details/47023653</a></p><p><a href="https://segmentfault.com/a/1190000005659574" target="_blank" rel="external">https://segmentfault.com/a/1190000005659574</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="乘积最大子序列"><a href="#乘积最大子序列" class="headerlink" title="乘积最大子序列"></a>乘积最大子序列</h3><p>【题目描述】</p><p>找出一个序列中乘积最大的连续子序列（至少包含一个数）</p><p>【思路】</p><ul><li><code>data[i]</code>：第i个数据</li></ul><ul><li><code>dp1[i]</code>：以第i个数据结尾的连续子序列最大乘积</li><li><code>dp2[i]</code>：以第i个数据结尾的连续子序列最小乘积</li><li>状态转移方程<ul><li><code>dp1[i]=max(data[i],max(dp1[i-1] * data[i],dp2[i-1] * data[i]));</code></li><li><code>dp2[i]=min(data[i],min(dp1[i-1] * data[i],dp2[i-1] * data[i]));</code></li></ul></li><li>边界条件<ul><li><code>dp1[0]=data[0];</code></li><li><code>dp2[0]=data[0];</code></li></ul></li><li>最后遍历<code>dp1</code>得到最大值即可</li></ul><p>【题解】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">min</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dp1(len);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dp2(len);</span><br><span class="line">    <span class="comment">//边界条件</span></span><br><span class="line">    dp1[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp2[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp1[i]=max(nums[i],max(dp1[i<span class="number">-1</span>]*nums[i],dp2[i<span class="number">-1</span>]*nums[i]));</span><br><span class="line">        dp2[i]=min(nums[i],min(dp1[i<span class="number">-1</span>]*nums[i],dp2[i<span class="number">-1</span>]*nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">if</span>(dp1[i]&gt;dp1[index])</span><br><span class="line">            index=i;</span><br><span class="line">    <span class="keyword">return</span> dp1[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h2&gt;&lt;h3 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找
      
    
    </summary>
    
      <category term="算法" scheme="https://tianwenyu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tianwenyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】小米2015暑假实习笔试题</title>
    <link href="https://tianwenyu.github.io/algorithm-xiaomi2015/"/>
    <id>https://tianwenyu.github.io/algorithm-xiaomi2015/</id>
    <published>2018-03-20T11:29:36.000Z</published>
    <updated>2018-03-24T09:01:10.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="懂二进制"><a href="#懂二进制" class="headerlink" title="懂二进制"></a>懂二进制</h2><p><strong>题目描述</strong>：世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？</p><p><strong>题解</strong>：</p><p>【思路】两个数异或，因为两个数异或不同为1，相同为0，则统计1的个数即可。</p><ol><li>异或运算，得到数c。</li><li>c&amp;(c-1)，从而统计1的个数。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBitDiff</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c=m^n;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//得到的数c-1再进行逻辑与，可以统计有多少个1</span></span><br><span class="line">          <span class="comment">//因为c末尾为1时，c-1，末尾为0；</span></span><br><span class="line">          <span class="comment">//c末尾为0时，c-1，向高位借1，若高位为1，则变为0，逻辑与后该高位变为0，低位也变为0</span></span><br><span class="line">          <span class="comment">//若高位为0，则向更高位借1，更高位为0，逻辑与后，更高位为0，高位和低位也为0</span></span><br><span class="line">          <span class="comment">//从而统计有多少个1</span></span><br><span class="line">            c=c&amp;(c<span class="number">-1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="风口的猪——中国牛市"><a href="#风口的猪——中国牛市" class="headerlink" title="风口的猪——中国牛市"></a>风口的猪——中国牛市</h2><p><strong>题目描述</strong>：风口之下，猪都能飞。当今中国股市牛市，真可谓“错过等七年”。 给你一个回顾历史的机会，已知一支股票连续n天的价格走势，以长度为n的整数数组表示，数组中第i个元素（prices[i]）代表该股票第i天的股价。 假设你一开始没有股票，但有至多两次买入1股而后卖出1股的机会，并且买入前一定要先保证手上没有股票。若两次交易机会都放弃，收益为0。 设计算法，计算你能获得的最大收益。 输入数值范围：2&lt;=n&lt;=100,0&lt;=prices[i]&lt;=100 </p><p><strong>题解</strong></p><h2 id="小米Git"><a href="#小米Git" class="headerlink" title="小米Git"></a>小米Git</h2><p><strong>题目描述</strong>：git是一种分布式代码管理工具，git通过树的形式记录文件的更改历史，比如： base’&lt;–base&lt;–A&lt;–A’ ^ | — B&lt;–B’ 小米工程师常常需要寻找两个分支最近的分割点，即base.假设git 树是多叉树，请实现一个算法，计算git树上任意两点的最近分割点。 （假设git树节点数为n,用邻接矩阵的形式表示git树：字符串数组matrix包含n个字符串，每个字符串由字符’0’或’1’组成，长度为n。matrix[i][j]==’1’当且仅当git树种第i个和第j个节点有连接。节点0为git树的根节点。） </p><p><strong>题解</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;懂二进制&quot;&gt;&lt;a href=&quot;#懂二进制&quot; class=&quot;headerlink&quot; title=&quot;懂二进制&quot;&gt;&lt;/a&gt;懂二进制&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二
      
    
    </summary>
    
      <category term="算法" scheme="https://tianwenyu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tianwenyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://tianwenyu.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【算法】面试题：链表</title>
    <link href="https://tianwenyu.github.io/algorithm-linkedlist/"/>
    <id>https://tianwenyu.github.io/algorithm-linkedlist/</id>
    <published>2018-03-20T11:29:36.000Z</published>
    <updated>2018-04-01T13:20:26.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>本文用到的链表节点的定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h2><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180323/50gC2j7fE6.png?imageslim" alt="mark"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DataType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkList</span>&lt;DataType&gt;:</span>:LinkList(DataType a[],<span class="keyword">int</span> n)&#123;</span><br><span class="line">Node *first=<span class="keyword">new</span> Node;</span><br><span class="line">fisrt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Node *s=<span class="keyword">new</span> Node;</span><br><span class="line">    s-&gt;data=a[i];</span><br><span class="line">    s-&gt;next=first-&gt;next;</span><br><span class="line">    first-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###尾插法</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180323/6k8JK3eLKk.png?imageslim" alt="mark"></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180323/bd26iJD9bI.png?imageslim" alt="mark"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DataTpye</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkList</span>&lt;DataType&gt;:</span>:LinkList(DataType a[],<span class="keyword">int</span> n)&#123;</span><br><span class="line">Node *first=<span class="keyword">new</span> Node;</span><br><span class="line">Node *r=first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Node *s=<span class="keyword">new</span> Node;</span><br><span class="line">    s-&gt;data=a[i];</span><br><span class="line">    r-&gt;next=s;</span><br><span class="line">    r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在O-1-时间内删除链表节点"><a href="#在O-1-时间内删除链表节点" class="headerlink" title="在O(1)时间内删除链表节点"></a>在O(1)时间内删除链表节点</h2><p><strong>题目描述</strong>：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。（Google面试题）</p><p><strong>分析</strong>：本题与《编程之美》上的「从无头单链表中删除节点」类似。用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node *cur)</span></span>&#123;</span><br><span class="line">  assert(cur == <span class="literal">NULL</span>);</span><br><span class="line">  assert(cur-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">  Node *pNext=cur-&gt;next;</span><br><span class="line">  pCur-&gt;data=pNext-&gt;data;</span><br><span class="line">  pCur-&gt;next=pNext-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表逆置"><a href="#单链表逆置" class="headerlink" title="单链表逆置"></a>单链表逆置</h2><p><strong>题目描述</strong>：输入一个单向链表，输出逆序反转后的链表</p><p><strong>分析</strong>：非递归方法即就地逆置法，用三个临时指针pre,head,next在链表循环即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表转置，循环方法</span></span><br><span class="line"><span class="function">Node* <span class="title">reverse</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  Node *pre=<span class="literal">NULL</span>;</span><br><span class="line">  Node *next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    next = head-&gt;next;</span><br><span class="line">    head-&gt;next=pre;</span><br><span class="line">    pre=head;</span><br><span class="line">    head=next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求单链表倒数第k个节点"><a href="#求单链表倒数第k个节点" class="headerlink" title="求单链表倒数第k个节点"></a>求单链表倒数第k个节点</h3><p><strong>题目描述</strong>：输入一个单链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。</p><p><strong>分析</strong>：设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//倒数第k个节点</span></span><br><span class="line"><span class="function">Node* <span class="title">theKthNode</span><span class="params">(Node *head,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//异常判断</span></span><br><span class="line">    Node *slow,*fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;<span class="number">0</span> &amp;&amp; fast!=<span class="literal">NULL</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//考虑k大于链表长度的case</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断单链表是否有环"><a href="#判断单链表是否有环" class="headerlink" title="判断单链表是否有环"></a>判断单链表是否有环</h3><p>【题目描述】</p><p><strong>单链表有环的定义：</strong>链表的尾节点指向了链接中间的某个节点。</p><p>如下图所示，如果有环，则遍历到结点7时，又重新回到结点3，结点3就是环的入口结点。</p><p><img src="https://images2015.cnblogs.com/blog/509374/201603/509374-20160329220459738-2046143200.png" alt="img"></p><p>【思路】</p><p>采用快慢指针的思想，设两个工作指针，一个快一个慢，比如一个每次走一步，另一个每次走两步，如果链表有环，必定会在某个结点处相遇。</p><p>具体流程：</p><ul><li>可以设置两个指针(fast,slow)，初始值均指向头，slow每次向前一步，fast每次向前两步；</li><li>如果链表中有环，则fast先进入环中，而slow后进入环中，两个指针在环中必定相遇;</li><li>如果fast遍历到尾部为NULL，则无环</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasLoop</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">  Node *p1,p2;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//链表为空，或者是单结点链表返回头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  p1=p2=head;</span><br><span class="line">  <span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; p1-&gt;next-next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    p1=p1-&gt;next-&gt;next;</span><br><span class="line">    p2=p2-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p1==p2)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;p&gt;本文用到的链表节点的定义&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;c
      
    
    </summary>
    
      <category term="算法" scheme="https://tianwenyu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://tianwenyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://tianwenyu.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>安装Docker CE for Windows后VirtualBox无法启动问题解决</title>
    <link href="https://tianwenyu.github.io/docker-virtualbox-problem/"/>
    <id>https://tianwenyu.github.io/docker-virtualbox-problem/</id>
    <published>2018-03-10T11:29:36.000Z</published>
    <updated>2018-03-12T08:08:48.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在Windows上运行Docker需要借助虚拟机来运行一个简化的Linux系统，Docker CE for Windows使用的是Windows系统自带的<code>Hyper-V</code>（从Win8开始）虚拟机组件。</p><p>因此在安装Docker CE for Windows时，会打开<code>Hyper-V</code>组件（默认是关闭的），会和Virtual Box冲突。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="关闭Hyper-V组件"><a href="#关闭Hyper-V组件" class="headerlink" title="关闭Hyper-V组件"></a>关闭<code>Hyper-V</code>组件</h3><p><code>控制面板-程序和功能-启用或关闭Windows功能</code>，去掉<code>Hpyer-V</code>功能。重启。</p><p><img src="http://img.blog.csdn.net/20171127124402922" alt="img"></p><p>打开Virtualbox依然报错</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180312/EkIhhCAAbd.png?imageslim" alt="mark"></p><p>这是因为<code>vboxdrv</code>服务没有安装或成功启动，在Virtualbox安装目录下的<code>drivers\vobxdrv</code>文件夹下，右击<code>VBoxDrv.inf</code>，选择安装，然后重启。</p><p>如果还是失败，则直接重新安装即可。</p><h2 id="安装老版Docker-Toolbox"><a href="#安装老版Docker-Toolbox" class="headerlink" title="安装老版Docker Toolbox"></a>安装老版Docker Toolbox</h2><p>老版Docker Toolbox使用的时Virtualbox虚拟机。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;在Windows上运行Docker需要借助虚拟机来运行一个简化的Linux系统，Docker CE for Windows使用的是Windo
      
    
    </summary>
    
      <category term="运维技术" scheme="https://tianwenyu.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="Docker" scheme="https://tianwenyu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下Docker简明教程</title>
    <link href="https://tianwenyu.github.io/windows-docker/"/>
    <id>https://tianwenyu.github.io/windows-docker/</id>
    <published>2018-03-01T11:29:36.000Z</published>
    <updated>2018-03-12T07:23:26.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、<a href="http://www.whatis.com.cn/word_5275.htm" target="_blank" rel="external">bare metal</a>、OpenStack 集群和其他的基础应用平台。 </p><p>Docker通常用于如下场景：</p><ul><li>web应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li><li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li></ul><a id="more"></a><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/Cg78lC6082.png?imageslim" alt="mark"></p><p>Docker使用C/S架构模式，Docker客户端会与Docker守护进程通信。Docker守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。</p><p>Docker分为三种部件：</p><ul><li>Docker镜像-Docker Images</li><li>Docker容器-Docker Containers</li><li>Docker仓库-Docker Registeries</li></ul><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>Docker运行容器前需要本地存在对应的镜像。Docker镜像可以用来创建Docker容器，一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序。</p><p>Docker镜像是只可读的，一个镜像可以创建多个容器。</p><p>通俗说，Images是已经打包好的环境文件，我们运行的时候把Images加载运行在本地容器中，你在这个容器中可以进行一些修改重新打包成新镜像上传。</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>因为镜像包含操作系统完整的root文件系统，其体积往往是巨大的，因此Docker设计时，就充分利用Union FS技术，将其设计为分层存储的架构。</p><p>分层存储的特征使得镜像并非像一个ISO类似的打包文件，而是由一组文件系统组成。</p><h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><p>Docker利用容器来开发、运行应用。容器是镜像创建的实例，可以被开始、启动、停止、删除。每个容器都是相互隔离的。</p><h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>仓库是集中存放镜像文件的场所。每个仓库中包含了多个镜像，每个镜像有不同的标签。</p><p>最大的公开仓库是<a href="[https://**hub**.**docker**.com/](http://www.baidu.com/link?url=XXjI7ksUwIGyOeeGLj18zm9wnXFolGgd4ZTPbEZ65zamM5dwMUF9m7lS930XC8z4">DockerHub</a>)，因为墙的原因，可以使用<a href="http://get.daocloud.io/" target="_blank" rel="external">DaoCloud</a>、<a href="[https://j0andt2p.mirror.aliyuncs.com](https://j0andt2p.mirror.aliyuncs.com/">阿里云</a>)加速下载。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>Win10版本Docker安装以下版本<a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="external">Docker Community Edition 17.12.0-ce</a></li><li>Win10之前版本安装<a href="https://download.docker.com/win/stable/DockerToolbox.exe" target="_blank" rel="external">Docker ToolBox</a>，<a href="https://docs.docker.com/toolbox/overview/#whats-in-the-box" target="_blank" rel="external">官方文档</a></li></ul><ol><li><p>安装之前，需要开启Windows10的<code>Hpyer-V</code>。</p><p><code>控制面板-程序-启用或关闭Windows功能</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/G8GkJmK19j.png?imageslim" alt="mark"></p></li></ol><ol><li><p>本文以<code>Docker Community Edition</code>为例，开启<code>Hpyer-V</code>后直接安装<code>Docker Community Edition</code>即可。</p><p>安装成功后，运行<code>cmd</code>,执行<code>docker version</code>，安装成功则显示下图</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/kGIA8d4j2f.png?imageslim" alt="mark"></p></li></ol><h2 id="设置Docker"><a href="#设置Docker" class="headerlink" title="设置Docker"></a>设置Docker</h2><p><code>任务栏鲸鱼图标右键-Settings</code>打开设置界面</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180306/m2dbjkDeKm.png?imageslim" alt="mark"></p><ul><li><code>Shared Drivers</code>：可以将主机（即Windows）中的驱动器共享到Docker Container中</li><li><code>Advanced</code>：用于配置运行Docker Daemon的虚拟机环境的CPU和内存和镜像路径</li><li><code>Network</code>：配置Docker的网络环境</li><li><code>Proxies</code>：代理的配置</li><li><code>Docker Daemon</code>：使用JSON格式的设置，对Docker Daemon进行设置，类似于在Linux中利用conf文件对Docker设置。</li></ul><h3 id="修改CPU数目及内存"><a href="#修改CPU数目及内存" class="headerlink" title="修改CPU数目及内存"></a>修改CPU数目及内存</h3><p>点击<code>Advanced</code>，如下图修改参数即可</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180305/7LH2Hkgika.png?imageslim" alt="mark"></p><h3 id="修改代理"><a href="#修改代理" class="headerlink" title="修改代理"></a>修改代理</h3><p><code>Docker Hub</code>速度较慢，修改为阿里云镜像。</p><p>登陆<a href="https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fcr.console.aliyun.com%2F%3Fspm%3Da2c4e.11153959.blogcont29941.9.520269d6tguzRb" target="_blank" rel="external">容器Hub服务</a>，找到以下链接</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/0kJ3JeB7fI.png?imageslim" alt="mark"></p><p>点击<code>Daemon</code>设置镜像，直接在<code>Registry mirrors</code>中填写阿里云的镜像地址，点击<code>Apply</code>重启应用即可。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/BH74glgG0L.png?imageslim" alt="mark"></p><h3 id="更改镜像默认存储路径"><a href="#更改镜像默认存储路径" class="headerlink" title="更改镜像默认存储路径"></a>更改镜像默认存储路径</h3><p>打开Docker的<code>Settings</code>，点击<code>Advanced</code>，在<code>Images and volumes VHD location</code>选择新的路径。重启后即可更新设置。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180306/32EJFIc6bB.png?imageslim" alt="mark"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看Docker版本"><a href="#查看Docker版本" class="headerlink" title="查看Docker版本"></a>查看Docker版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="查看本机已安装镜像"><a href="#查看本机已安装镜像" class="headerlink" title="查看本机已安装镜像"></a>查看本机已安装镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull Name:Tag</span><br></pre></td></tr></table></figure><p>【例】</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull sameersbn/redmine:latest</span><br></pre></td></tr></table></figure><h3 id="删除单个容器"><a href="#删除单个容器" class="headerlink" title="删除单个容器"></a>删除单个容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm Name/ID</span><br></pre></td></tr></table></figure><h3 id="删除所有的容器"><a href="#删除所有的容器" class="headerlink" title="删除所有的容器"></a>删除所有的容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm docker ps -a -q</span><br></pre></td></tr></table></figure><h3 id="停止、启动、杀死一个容器"><a href="#停止、启动、杀死一个容器" class="headerlink" title="停止、启动、杀死一个容器"></a>停止、启动、杀死一个容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop Name/ID</span><br><span class="line">docker start Name/ID</span><br><span class="line">docker <span class="built_in">kill</span> Name/ID</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.csdn.net/xiaoping0915/article/details/75094857" target="_blank" rel="external">【Docker】windows10 docker 使用</a></li><li><a href="http://blog.csdn.net/sb19931201/article/details/53838339" target="_blank" rel="external">Docker on Windows初体验</a></li><li><a href="https://www.cnblogs.com/daxnet/p/5788972.html" target="_blank" rel="external">Docker for Windows使用简介</a></li><li><a href="https://yq.aliyun.com/articles/62375" target="_blank" rel="external">Docker的Windows容器初体验</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、&lt;a href=&quot;http://www.whatis.com.cn/word_5275.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bare metal&lt;/a&gt;、OpenStack 集群和其他的基础应用平台。 &lt;/p&gt;
&lt;p&gt;Docker通常用于如下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web应用的自动化打包和发布；&lt;/li&gt;
&lt;li&gt;自动化测试和持续集成、发布；&lt;/li&gt;
&lt;li&gt;在服务型环境中部署和调整数据库或其他的后台应用；&lt;/li&gt;
&lt;li&gt;从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="运维技术" scheme="https://tianwenyu.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="Docker" scheme="https://tianwenyu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Windows10下Docker搭建深度学习框架</title>
    <link href="https://tianwenyu.github.io/docker-deeplearning/"/>
    <id>https://tianwenyu.github.io/docker-deeplearning/</id>
    <published>2018-03-01T11:29:36.000Z</published>
    <updated>2018-03-07T12:12:28.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="Deepo"><a href="#Deepo" class="headerlink" title="Deepo"></a>Deepo</h2><p><code>Deepo</code>是一个几乎包含所有流行深度学习框架的Docker映像，拥有一个完整的可复制的深度学习研究环境。它涵盖了</p><ul><li>theano</li><li>tensorflow</li><li>sonnet</li><li>pytorch</li><li>keras</li><li>lasagne</li><li>mxnet</li><li>cntk</li><li>chainer</li><li>caffe</li><li>torch</li></ul><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接从<code>Docker Hub</code>下载<code>Deepo</code>镜像。<a href="https://github.com/ufoym/deepo" target="_blank" rel="external">Github地址</a></p><ul><li>CPU版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ufoym/deepo:cpu</span><br></pre></td></tr></table></figure><ul><li>GPU版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ufoym/deepo</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>打开<code>powershell</code>执行以下命令，以bash方式运行该容器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ufoym/deepo:cpu bash</span><br></pre></td></tr></table></figure><h2 id="DL-docker"><a href="#DL-docker" class="headerlink" title="DL-docker"></a>DL-docker</h2><p>包含的框架及系统依赖</p><ul><li>Ubuntu 14.04</li><li>CUDA 7.5 (GPU version only)</li><li>cuDNN v4 (GPU version only)</li><li>Tensorflow</li><li>Caffe</li><li>Theano</li><li>Keras</li><li>Lasagne</li><li>Torch (includes nn, cutorch, cunn and cuDNN bindings)</li><li>iPython/Jupyter Notebook (including iTorch kernel)</li><li>Numpy, SciPy, Pandas, Scikit Learn, Matplotlib</li><li>A few common libraries used for deep learning</li></ul><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul><li>cpu版本</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull floydhub/dl-docker:cpu</span><br></pre></td></tr></table></figure><h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8888:8888 -p 6006:6006 -v /sharedfolder:/root/sharedfolder floydhub/dl-docker:cpu bash</span><br></pre></td></tr></table></figure><p>运行以上命令后，会连接到bash，执行<code>jupyter notebook</code>。</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/E9gbbiD8dH.png?imageslim" alt="mark"></p><p>然后在Windows的浏览器中输入<code>localhost:8888</code>，会连接到该容器的<code>Jupyter notebook</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180307/0LLJg73D1G.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h2 id=&quot;Deepo&quot;&gt;&lt;a href=&quot;#Deepo&quot; class=&quot;headerlink&quot; title=&quot;Deepo&quot;&gt;&lt;/a&gt;Deepo&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Deepo&lt;/code&gt;是一个几乎包含所有流行深度学习框架的Docker映像，拥有一个完整的可复制的深度学习研究环境。它涵盖了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;theano&lt;/li&gt;
&lt;li&gt;tensorflow&lt;/li&gt;
&lt;li&gt;sonnet&lt;/li&gt;
&lt;li&gt;pytorch&lt;/li&gt;
&lt;li&gt;keras&lt;/li&gt;
&lt;li&gt;lasagne&lt;/li&gt;
&lt;li&gt;mxnet&lt;/li&gt;
&lt;li&gt;cntk&lt;/li&gt;
&lt;li&gt;chainer&lt;/li&gt;
&lt;li&gt;caffe&lt;/li&gt;
&lt;li&gt;torch&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://tianwenyu.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Windows" scheme="https://tianwenyu.github.io/tags/Windows/"/>
    
      <category term="Docker" scheme="https://tianwenyu.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常见问题解决方法</title>
    <link href="https://tianwenyu.github.io/hexo-solve/"/>
    <id>https://tianwenyu.github.io/hexo-solve/</id>
    <published>2018-02-27T11:29:36.000Z</published>
    <updated>2018-02-27T07:52:36.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fatal-HttpRequestException-encountered"><a href="#fatal-HttpRequestException-encountered" class="headerlink" title="fatal: HttpRequestException encountered."></a>fatal: HttpRequestException encountered.</h2><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180227/B88KJ5L618.png?imageslim" alt="mark"></p><p>将<code>_config.yml</code>中的<code>repository: https://github.com:username/username.github.io.git</code></p><p>改成<code>repository: git@github.com:username/username.github.io.git</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fatal-HttpRequestException-encountered&quot;&gt;&lt;a href=&quot;#fatal-HttpRequestException-encountered&quot; class=&quot;headerlink&quot; title=&quot;fatal: HttpReque
      
    
    </summary>
    
      <category term="个人建站" scheme="https://tianwenyu.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="Hexo" scheme="https://tianwenyu.github.io/tags/Hexo/"/>
    
      <category term="GitPage" scheme="https://tianwenyu.github.io/tags/GitPage/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装Jupyter Notebook</title>
    <link href="https://tianwenyu.github.io/windows-jupyter-notebook/"/>
    <id>https://tianwenyu.github.io/windows-jupyter-notebook/</id>
    <published>2018-02-09T12:29:30.000Z</published>
    <updated>2018-02-27T07:36:03.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="文学编程"><a href="#文学编程" class="headerlink" title="文学编程"></a>文学编程</h3><p>文学编程(Literate Programming)是由Donald Knuth提出的编程方法。传统的结构化编程，人要按照计算机的逻辑顺序来编写代码，而文学编程则可以让人们按照自己的逻辑来开发程序。</p><h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><p><code>Jupyter Notebook</code>是一个交互式笔记本，支持运行40多种编程语言。它的本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和markdown。</p><p><code>Jupyter Notebook</code>优点：</p><ul><li>适合数据分析</li><li>支持多语言</li><li>分享便捷</li><li>远程运行</li><li>交互式展示<a id="more"></a></li></ul><p>##安装</p><p>安装Anaconda即自带，不需要安装</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>点击<code>Jupyter Notebook</code>即可启动，或在cmd中输入<code>jupyter notebook</code></p><p>默认地址为<code>http:localhost:8888</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/I4lBa3iCj3.png?imageslim" alt="mark"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="更改Jupyter-Notebook工作空间"><a href="#更改Jupyter-Notebook工作空间" class="headerlink" title="更改Jupyter Notebook工作空间"></a>更改Jupyter Notebook工作空间</h3><p>最新版<code>Ipython</code>和<code>Jupyter</code>配置文件是分开的，需要分别配置文件。</p><ol><li><p>打开cmd输入命令<code>jupyter notebook --generate-config</code></p><p>【注】<code>-config</code>之前没有空格</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/8DC86687KH.png?imageslim" alt="mark"></p></li><li><p>打开该目录下的文件，改文件夹路径</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/lea2G5JDa7.png?imageslim" alt="mark"></p><p>【注】若存在编码问题，可改成<code>f://file//jupyter_notebook</code></p></li><li><p>启动<code>Jupyter Notebook</code></p></li></ol><h3 id="新建Notebook"><a href="#新建Notebook" class="headerlink" title="新建Notebook"></a>新建Notebook</h3><p>点击<code>new</code>创建新的<code>Notebook</code></p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/CKGCg8a3h8.png?imageslim" alt="mark"></p><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180214/K3eK1Lc3FH.png?imageslim" alt="mark"></p><p>菜单栏各项功能概述</p><ul><li><code>File</code><ul><li><code>Save and Checkpoint</code> 保存并记录点，类似于不同版本</li><li><code>Revert to Checkpoint</code>返回到某一记录点</li></ul></li><li><code>View</code><ul><li><code>Toggle Header</code>是否显示头部信息，包括文件名和上次保存时间</li><li><code>Toggle ToolBar</code>是否显示工具栏</li></ul></li><li><code>Kernel</code><ul><li><code>Change kernel</code>更换内核环境</li></ul></li></ul><p>Notebook文档由一系列<code>单元(cell)</code>,主要有两种形式的单元：</p><ul><li>代码状态单元：编写代码的区域，使用<code>Shift+Enter</code>运行代码，结果显示在本单元下方。代码单元左边有<code>In[1]：</code>类似的序列标记，方便人们查看代码的执行次序。</li><li>Markdown状态单元：编写文本的区域，使用<code>Shift+Enter</code>显示格式化的文本。</li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>编辑模式：编辑文本和代码。选中单元按<code>Enter</code>进入编辑模式，单元左侧显示绿色竖线</li><li>命令模式：执行输入的命令。按<code>Esc</code>进入命令模式，单元左侧显示蓝色竖线</li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ul><li>查看快捷键：<code>H</code></li></ul><ul><li>执行当前单元，并自动跳到下一个单元：<code>Shift+Enter</code></li><li>执行当前单元，不自动跳到下一个单元：<code>Ctrl+Enter</code></li><li>进入编辑模式：<code>Enter</code></li><li>进入命令模式：<code>Esc</code></li><li>删除当前单元：<code>双击D</code></li><li>变为代码状态：<code>Y</code></li><li>变为Markdown状态：<code>M</code></li><li>在下方插入新单元：<code>B</code></li><li>剪切选中单元：<code>X</code></li><li>复制选中单元：<code>C</code></li><li>粘贴到下方单元：<code>V</code></li><li>选中上方单元：<code>J</code></li><li>选中下方单元：<code>K</code></li><li>恢复删除的最后一个单元：<code>Z</code></li><li>保存当前Notebook：<code>Ctrl+S</code></li></ul><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><ul><li>代码缩进或补全：<code>Tab</code></li><li>代码提示：<code>Shift+Tab</code></li><li>注释：<code>Ctrl+/</code></li></ul><h3 id="Magic命令"><a href="#Magic命令" class="headerlink" title="Magic命令"></a>Magic命令</h3><p><code>Magic命令</code>以<code>%</code>或<code>%%</code>开头</p><ul><li><code>%</code>：行命令</li><li><code>%%</code>：单元命令。必须出现在单元第一行。</li></ul><p>以下为常用<code>Magic命令</code></p><ul><li><code>%lsmagic</code>：列举所有Magic命令</li><li><code>%magic</code>：查看Magic命令说明</li><li><code>%timeit</code>：代码运行时间</li><li><code>%matplotlib inline</code>：显示matplotlib包生成的图形</li></ul><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="运行Python文件"><a href="#运行Python文件" class="headerlink" title="运行Python文件"></a>运行Python文件</h3><p>运行以下命令</p><p><code>%run xxx.py</code></p><p>【注】<code>xxx.py</code>是当前工作空间下的一个python文件</p><h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><p>运行以下命令</p><p><code>%load xxx.py</code></p><p>【注】<code>xxx.py</code>是当前工作空间下的一个python文件 </p><h3 id="重置单元格序号"><a href="#重置单元格序号" class="headerlink" title="重置单元格序号"></a>重置单元格序号</h3><p>重置单元格<code>In[x]</code>序号</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180215/Ah0H7D7G9m.png?imageslim" alt="mark"></p><p>点击<code>Kernel-Restart</code>即可。</p><h3 id="使用Seaborn绘图"><a href="#使用Seaborn绘图" class="headerlink" title="使用Seaborn绘图"></a>使用<code>Seaborn</code>绘图</h3><p>需要使用<code>%matplotlib inline</code>命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;文学编程&quot;&gt;&lt;a href=&quot;#文学编程&quot; class=&quot;headerlink&quot; title=&quot;文学编程&quot;&gt;&lt;/a&gt;文学编程&lt;/h3&gt;&lt;p&gt;文学编程(Literate Programming)是由Donald Knuth提出的编程方法。传统的结构化编程，人要按照计算机的逻辑顺序来编写代码，而文学编程则可以让人们按照自己的逻辑来开发程序。&lt;/p&gt;
&lt;h3 id=&quot;Jupyter-Notebook&quot;&gt;&lt;a href=&quot;#Jupyter-Notebook&quot; class=&quot;headerlink&quot; title=&quot;Jupyter Notebook&quot;&gt;&lt;/a&gt;Jupyter Notebook&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Jupyter Notebook&lt;/code&gt;是一个交互式笔记本，支持运行40多种编程语言。它的本质是一个Web应用程序，便于创建和共享文学化程序文档，支持实时代码、数学方程、可视化和markdown。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Jupyter Notebook&lt;/code&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合数据分析&lt;/li&gt;
&lt;li&gt;支持多语言&lt;/li&gt;
&lt;li&gt;分享便捷&lt;/li&gt;
&lt;li&gt;远程运行&lt;/li&gt;
&lt;li&gt;交互式展示
    
    </summary>
    
      <category term="机器学习" scheme="https://tianwenyu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Notebook" scheme="https://tianwenyu.github.io/tags/Notebook/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装Anaconda</title>
    <link href="https://tianwenyu.github.io/ubuntu-ancaconda/"/>
    <id>https://tianwenyu.github.io/ubuntu-ancaconda/</id>
    <published>2018-02-09T12:29:30.000Z</published>
    <updated>2018-02-27T07:29:31.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>使用<code>Python3.6</code>版本的<code>Anaconda 5.1</code>，<a href="https://repo.continuum.io/archive/Anaconda3-5.1.0-Linux-x86_64.sh" target="_blank" rel="external">点击下载</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>进入到下载后的文件目录，执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-5.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>根据提示输入回车</p><p><img src="http://img.blog.csdn.net/20170628223151678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p></li><li><p>查看注册信息，一直回车到输入<code>yes</code></p><p><img src="http://img.blog.csdn.net/20170628223509298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="http://img.blog.csdn.net/20170628223600909?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p></li><li><p>输入安装目录路径，默认回车即可</p><p><img src="http://img.blog.csdn.net/20170628223649697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p></li><li><p>是否加入环境变量，输入<code>yes</code></p><p><img src="http://img.blog.csdn.net/20170628223754787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjMxODA3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p></li><li><p>安装成功后，新打开一个终端输入以下命令查看版本号</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">anaconda -V</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用Jupyter-Notebook"><a href="#使用Jupyter-Notebook" class="headerlink" title="使用Jupyter Notebook"></a>使用Jupyter Notebook</h2><p>输入以下命令则能够使用<code>Jupyter Notebook</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipython notebook</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Anaconda安装&quot;&gt;&lt;a href=&quot;#Anaconda安装&quot; class=&quot;headerlink&quot; title=&quot;Anaconda安装&quot;&gt;&lt;/a&gt;Anaconda安装&lt;/h2&gt;&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;Python3.6&lt;/code&gt;版本的&lt;code&gt;Anaconda 5.1&lt;/code&gt;，&lt;a href=&quot;https://repo.continuum.io/archive/Anaconda3-5.1.0-Linux-x86_64.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入到下载后的文件目录，执行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash Anaconda3-5.1.0-Linux-x86_64.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://tianwenyu.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://tianwenyu.github.io/tags/Ubuntu/"/>
    
      <category term="Anaconda" scheme="https://tianwenyu.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>武大植物分布</title>
    <link href="https://tianwenyu.github.io/whu-plants/"/>
    <id>https://tianwenyu.github.io/whu-plants/</id>
    <published>2018-02-08T12:29:30.000Z</published>
    <updated>2018-02-27T07:51:22.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文理学部李达塑像"><a href="#文理学部李达塑像" class="headerlink" title="文理学部李达塑像"></a>文理学部李达塑像</h2><ul><li>樟树</li><li>蝴蝶花：4月，鸢尾科</li><li>鸢尾</li><li>吉祥草：百合科，秋花</li><li>南天竹：小檗科</li><li>锦绣杜鹃：杜鹃科</li><li>麦冬：百合科，6月开花</li><li>池衫</li><li>羊蹄：蓼科，酸模属</li><li>车前</li><li>蛇莓：蔷薇科，果不能吃</li><li>扬子毛茛</li><li>何首乌：蓼科</li><li>鸡矢藤：蓼科</li><li>海仙花</li><li>紫丁香</li><li>厚萼凌霄：位于亭子，6月开花</li><li>紫荆：苏木亚科，早春</li></ul><a id="more"></a><h2 id="工学部世纪广场"><a href="#工学部世纪广场" class="headerlink" title="工学部世纪广场"></a>工学部世纪广场</h2><ul><li>二球悬铃木</li><li>樟树</li><li>棕榈</li><li>复羽叶栾树</li><li>洋玉兰：常绿乔木，椭圆形革质叶</li><li>玉兰（白玉兰）：落叶乔木，先叶开花</li><li>结香：瑞香科，早春开花，先叶开花，花香久闻头疼</li><li>苏铁（铁树）：裸子植物，苏铁科</li><li>鹅观草：位于世纪广场草丛，下同</li><li>棒头草</li><li>雀麦</li><li>菵草</li><li>看麦娘</li><li>瓶尔小草：蕨类，此类是野生，不属于武大常规品种</li><li>绶草（盘龙参）：兰科，此类是野生，不属于武大常规品种</li></ul><h2 id="医学部广场"><a href="#医学部广场" class="headerlink" title="医学部广场"></a>医学部广场</h2><ul><li>雪松</li><li>桂花（木犀）</li><li>樟树</li><li>池衫</li><li>细叶结缕草：位于广场草地，下同</li><li>狗牙根</li><li>早熟禾：早春开花</li><li>救荒野豌豆：荚果，比下类野豌豆果长</li><li>四籽野豌豆：荚果，</li><li>匍茎通泉草：玄参科，通泉草属，二唇形花</li><li>直立婆婆纳：玄参科</li><li>垂丝海棠：，蔷薇科苹果亚科苹果属，不位于广场，下同</li><li>贴梗海棠：灌木状，木瓜属，结果</li><li>槐树：豆科</li><li>喜树：珙桐科</li></ul><h2 id="信部星湖园"><a href="#信部星湖园" class="headerlink" title="信部星湖园"></a>信部星湖园</h2><ul><li><p>孝顺竹：丛生，禾本科</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180210/2eCJgi70j3.png?imageslim" alt="mark"></p></li><li><p>君迁子（黑枣）：</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180210/hI1lbKdGmI.png?imageslim" alt="mark"></p></li><li><p>旱柳：星湖周围，下同</p></li><li><p>垂柳</p></li><li><p>榔榆：榆科，秋花秋果</p></li><li><p>朴树：榔榆旁边</p></li><li><p>木瓜：蔷薇科，树皮类似迷彩服</p></li><li><p>臭椿：苦木科</p></li><li><p>侧柏：柏科</p></li><li><p>柏木</p></li></ul><h2 id="武大牌坊入口区"><a href="#武大牌坊入口区" class="headerlink" title="武大牌坊入口区"></a>武大牌坊入口区</h2><ul><li>金叶女贞</li><li>大叶黄杨</li><li>樟树</li></ul><h2 id="人文馆"><a href="#人文馆" class="headerlink" title="人文馆"></a>人文馆</h2><ul><li>桂花</li><li>圆柏</li><li>海桐</li><li>含笑</li><li>大叶黄杨</li><li>龙爪槐</li><li>桃花：距离人文馆稍远处，下同</li><li>梅花</li><li>山茶</li><li>紫薇</li></ul><h2 id="情人坡"><a href="#情人坡" class="headerlink" title="情人坡"></a>情人坡</h2><ul><li>池衫</li><li>山茶</li><li>垂丝海棠</li><li>贴梗海棠</li><li>湖北海棠</li><li>木瓜</li></ul><h2 id="茶港教工宿舍区小游园"><a href="#茶港教工宿舍区小游园" class="headerlink" title="茶港教工宿舍区小游园"></a>茶港教工宿舍区小游园</h2><ul><li><p>枇杷</p></li><li><p>桂树</p><p><img src="http://p15qizl76.bkt.clouddn.com/blog/180210/EKgABe2Gmd.png?imageslim" alt="mark"></p></li></ul><h2 id="西区教工宿舍小游园"><a href="#西区教工宿舍小游园" class="headerlink" title="西区教工宿舍小游园"></a>西区教工宿舍小游园</h2><ul><li>广玉兰</li><li>桂树</li><li>雪松</li><li>棕榈</li><li>小叶女贞</li><li>大叶黄杨</li><li>紫藤</li></ul><h2 id="中心湖区"><a href="#中心湖区" class="headerlink" title="中心湖区"></a>中心湖区</h2><ul><li>秤锤树</li><li>杜仲</li><li>榔榆</li><li>朴树</li><li>小叶栎</li><li>皂荚</li><li>毛竹</li><li>紫叶李</li><li>绣球荚蒾</li><li>红继木</li><li>鸡爪槭</li><li>红枫</li><li>蝴蝶花</li><li>麦冬</li><li>酢浆草</li></ul><h2 id="珞珈山枫园路"><a href="#珞珈山枫园路" class="headerlink" title="珞珈山枫园路"></a>珞珈山枫园路</h2><ul><li>水杉</li><li>枫树</li><li>棕榈</li><li>桂树</li><li>石楠</li><li>柑橘</li><li>鸡爪槭</li><li>紫叶李</li></ul><h2 id="老图书馆"><a href="#老图书馆" class="headerlink" title="老图书馆"></a>老图书馆</h2><h3 id="王世杰塑像"><a href="#王世杰塑像" class="headerlink" title="王世杰塑像"></a>王世杰塑像</h3><ul><li>银杏</li><li>黑松</li><li>刺柏</li><li>黄连木</li><li>石榴</li><li>海桐</li></ul><h3 id="王星拱塑像"><a href="#王星拱塑像" class="headerlink" title="王星拱塑像"></a>王星拱塑像</h3><ul><li>女贞</li><li>棕榈</li><li>海桐</li><li>法国冬青</li></ul><h3 id="西侧入口"><a href="#西侧入口" class="headerlink" title="西侧入口"></a>西侧入口</h3><ul><li>石榴</li><li>南天竹</li><li>桂树</li></ul><ul><li>石榴</li><li>桑树</li><li>落木石楠</li><li>朴树</li></ul><h3 id="东侧入口"><a href="#东侧入口" class="headerlink" title="东侧入口"></a>东侧入口</h3><ul><li>石楠</li><li>英国梧桐</li><li>龙柏</li><li>棕榈</li><li>侧柏</li><li>广玉兰</li></ul><h3 id="大楼前与老斋舍接邻草地"><a href="#大楼前与老斋舍接邻草地" class="headerlink" title="大楼前与老斋舍接邻草地"></a>大楼前与老斋舍接邻草地</h3><ul><li>大叶黄杨</li><li>油茶</li><li>石榴</li><li>侧柏</li><li>棕榈</li><li>柑橘</li><li>黑松</li><li>红檵木</li><li>狗牙根</li></ul><h3 id="老斋舍顶从东到西的种植槽"><a href="#老斋舍顶从东到西的种植槽" class="headerlink" title="老斋舍顶从东到西的种植槽"></a>老斋舍顶从东到西的种植槽</h3><ul><li>龙柏</li><li>椤木石楠</li><li>竹</li><li>木槿</li><li>紫藤</li><li>圆柏</li><li>刺柏</li></ul><h2 id="行政楼"><a href="#行政楼" class="headerlink" title="行政楼"></a>行政楼</h2><h3 id="行政楼内左右两侧的绿化圃"><a href="#行政楼内左右两侧的绿化圃" class="headerlink" title="行政楼内左右两侧的绿化圃"></a>行政楼内左右两侧的绿化圃</h3><ul><li>龙柏</li><li>吉祥草</li></ul><h3 id="行政楼东侧"><a href="#行政楼东侧" class="headerlink" title="行政楼东侧"></a>行政楼东侧</h3><ul><li>对节白蜡</li></ul><h2 id="樱花"><a href="#樱花" class="headerlink" title="樱花"></a>樱花</h2><p>基于<code>《珞珈山原色植物图谱》</code></p><ul><li>240号红花高盆樱：2月底至三月初开花，位于梅园校医院</li><li>241号尾叶樱桃：3-4月开花，位于行政楼旁，即绿樱，橘黄色果</li><li>242号大岛樱：3-4月开花，鲲鹏广场后的花园有几株</li><li>243号东京樱花：4月开花，奥场周围，樱花大道，黑果</li><li>244号垂枝樱花：3月底至四月初开花，晚樱，位于枫园14舍，岔路口通往枫园食堂。枫园三舍南侧路边、樱园南坡绿地（即情人坡）</li><li>245号日本晚樱：4月开花，教五周围，樱花大道和梅操之间情人坡，鲲鹏广场</li></ul><p><img src="https://pic4.zhimg.com/80/292c4dcc4552b69c99aea8298c790f07_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/cc4ffe797dd7ee59230304b315ae7b1d_hd.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/fea0820c2ca082386a4f5a92e73e4a2e_hd.jpg" alt="img"></p><ul><li>信部星湖东侧：</li></ul><p><img src="https://pic4.zhimg.com/80/v2-959da0b4f7bd6c6ec9348d713e3113ac_hd.jpg" alt="img"></p><ul><li>山樱花：又称福岛樱或青肤樱，4月初开花，花期15-20天，位于校医院前、教四前、樱园入口路旁、樱园南坡绿地（下沉花园）</li></ul><h2 id="绿线"><a href="#绿线" class="headerlink" title="绿线"></a>绿线</h2><h3 id="学府路"><a href="#学府路" class="headerlink" title="学府路"></a>学府路</h3><ul><li>樟树：行道树</li><li>金叶女贞：位于花坛</li><li>大叶黄杨：位于花坛</li></ul><h3 id="科技路"><a href="#科技路" class="headerlink" title="科技路"></a>科技路</h3><ul><li>广玉兰：生科院到教四楼行道树</li><li>银杏：生科院到教四楼行道树</li><li>大叶黄杨</li><li>英国梧桐：教四到樱园路行道树</li></ul><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="用途分类"><a href="#用途分类" class="headerlink" title="用途分类"></a>用途分类</h3><h4 id="行道树"><a href="#行道树" class="headerlink" title="行道树"></a>行道树</h4><ul><li>银杏</li><li>雪松</li><li>池衫</li><li>水杉</li><li>三角枫</li><li>枫树</li><li>梅树</li><li>桂树</li><li>女贞</li><li>樟树</li><li>广玉兰</li><li>英国梧桐</li><li>垂柳</li><li>石楠</li><li>樱树</li></ul><h4 id="园景树"><a href="#园景树" class="headerlink" title="园景树"></a>园景树</h4><ul><li>樱树</li><li>圆柏</li><li>龙柏</li><li>重阳木</li><li>拐枣</li><li>榉树</li><li>榔榆</li><li>朴树</li><li>三角枫</li><li>雪松</li><li>杜英</li><li>水杉</li><li>乌桕</li><li>复羽叶栾树</li><li>梧桐</li><li>国槐</li><li>石楠</li><li>白玉兰</li><li>棕榈</li><li>黄连木</li></ul><h4 id="花灌类"><a href="#花灌类" class="headerlink" title="花灌类"></a>花灌类</h4><ul><li>红枫</li><li>紫薇</li><li>卫矛</li><li>紫叶桃</li><li>紫叶李</li><li>海桐</li><li>金丝桃</li><li>八角金盘</li><li>南天竹</li><li>竹叶椒</li><li>杜鹃</li><li>云南黄馨</li><li>月季</li><li>火棘</li><li>枸骨</li></ul><h4 id="绿篱类"><a href="#绿篱类" class="headerlink" title="绿篱类"></a>绿篱类</h4><ul><li>马甲子</li><li>栀子</li><li>十大功劳</li><li>金心黄杨</li><li>雀舌黄杨</li><li>紫叶小檗</li><li>法国冬青</li></ul><h4 id="花坛花境类"><a href="#花坛花境类" class="headerlink" title="花坛花境类"></a>花坛花境类</h4><ul><li>月季</li><li>杜鹃</li><li>葱兰</li><li>一串红</li><li>一串蓝</li><li>火棘</li><li>重瓣棣棠</li><li>石蒜</li><li>大花马齿苋</li><li>夜来香</li><li>柳叶马鞭草</li><li>矮亚菊</li><li>山茶</li><li>夹竹桃</li><li>结香</li><li>木槿</li><li>中华绣线菊</li><li>凤尾鸡冠花</li><li>金盏菊</li><li>雏菊</li><li>金鸡菊</li><li>玉簪</li><li>萱草</li><li>美人蕉</li><li>锦带花</li><li>金钟花</li></ul><h3 id="观赏特性"><a href="#观赏特性" class="headerlink" title="观赏特性"></a>观赏特性</h3><h4 id="观形树"><a href="#观形树" class="headerlink" title="观形树"></a>观形树</h4><ul><li>樟树</li><li>桂花</li><li>银杏</li><li>池衫</li><li>水杉</li><li>马尾松</li><li>雪松</li><li>侧柏</li><li>龙柏</li><li>广玉兰</li><li>英国梧桐</li><li>石楠</li><li>椤木石楠</li><li>红檵木</li><li>垂柳</li><li>朴树</li><li>大叶黄杨</li><li>三角枫</li><li>鸡爪槭</li><li>女贞</li><li>白花泡棢</li><li>榔榆</li><li>日本冷杉</li><li>黑松</li><li>金钱松</li><li>杉木</li><li>日本柳杉</li><li>落羽杉</li><li>日本花柏</li><li>罗汉松</li><li>鹅掌楸</li><li>粗榧</li><li>润楠</li><li>合欢</li><li>黄杨</li><li>雀舌黄杨</li><li>交让木</li><li>旱柳</li><li>胡桃</li><li>化香</li><li>卫矛</li><li>珊瑚朴</li><li>榆树</li><li>榉树</li><li>乌桕</li><li>重阳木</li><li>南酸枣</li><li>黄连木</li><li>盐肤木</li><li>中华槭</li><li>金钟花</li><li>白蜡树</li><li>十大功劳</li><li>紫薇</li><li>毛泡桐</li><li>七叶树</li></ul><h4 id="观花树"><a href="#观花树" class="headerlink" title="观花树"></a>观花树</h4><h5 id="春"><a href="#春" class="headerlink" title="春"></a>春</h5><ul><li>含笑</li><li>白玉兰</li><li>桃</li><li>湖北海棠</li><li>李</li><li>梅</li><li>樱</li><li>麻叶绣线菊</li><li>中华绣线菊</li><li>重瓣棣棠</li><li>紫荆</li><li>瑞香</li><li>连翘</li><li>金钟花</li><li>探春花</li><li>云南黄馨</li><li>毛泡桐</li><li>白花泡桐</li></ul><h5 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h5><ul><li>广玉兰</li><li>金樱子</li><li>小果蔷薇</li><li>山合欢</li><li>合欢</li><li>绣球</li><li>山茱萸</li><li>荚蒾</li><li>红檵木</li><li>栾树</li><li>栀子</li><li>金丝桃</li><li>六月雪</li></ul><h5 id="春夏"><a href="#春夏" class="headerlink" title="春夏"></a>春夏</h5><ul><li>紫藤</li><li>锦鸡儿</li><li>忍冬</li><li>锦带花</li><li>芜花</li><li>石楠</li></ul><h5 id="夏秋"><a href="#夏秋" class="headerlink" title="夏秋"></a>夏秋</h5><ul><li>白兰</li><li>糯米条</li><li>六道木</li><li>木槿</li><li>木芙蓉</li><li>多花勾儿茶</li><li>夹竹桃</li><li>牡荆</li><li>石榴</li><li>锦葵</li></ul><h5 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h5><ul><li>决明</li></ul><h5 id="冬春"><a href="#冬春" class="headerlink" title="冬春"></a>冬春</h5><ul><li>腊梅</li><li>油茶</li></ul><h5 id="四季"><a href="#四季" class="headerlink" title="四季"></a>四季</h5><ul><li>月季</li><li>杜鹃</li><li>桂花</li></ul><h4 id="观叶树木"><a href="#观叶树木" class="headerlink" title="观叶树木"></a>观叶树木</h4><h5 id="春-1"><a href="#春-1" class="headerlink" title="春"></a>春</h5><ul><li>山麻秆</li><li>石楠</li></ul><h5 id="秋-1"><a href="#秋-1" class="headerlink" title="秋"></a>秋</h5><ul><li>金钱松</li><li>落羽杉</li><li>水杉</li><li>池衫</li><li>银杏</li><li>鹅掌楸</li><li>榔榆</li><li>朴树</li><li>榆树</li><li>榉树</li><li>美国地锦</li><li>三角枫</li><li>鸡爪槭</li><li>中华槭</li><li>英国梧桐</li><li>重阳木</li><li>七叶树</li></ul><h5 id="四季-1"><a href="#四季-1" class="headerlink" title="四季"></a>四季</h5><ul><li>紫叶桃</li><li>紫叶李</li></ul><h5 id="特殊叶形"><a href="#特殊叶形" class="headerlink" title="特殊叶形"></a>特殊叶形</h5><ul><li>紫荆</li><li>八角枫</li><li>八角金盘</li><li>黄杨</li><li>雀舌黄杨</li><li>锦熟黄杨</li><li>旱柳</li><li>垂柳</li><li>海桐</li><li>爬山虎</li><li>美国地锦</li><li>大叶黄杨</li><li>夹竹桃</li><li>苏铁</li></ul><h2 id="杂集"><a href="#杂集" class="headerlink" title="杂集"></a>杂集</h2><ul><li>秤锤树：位于未名湖畔东南角</li><li>大叶黄杨：位于梅园花坛</li><li>鹅掌楸：花期4-5月，枫园五舍、工学部网球场、珞珈广场</li><li>含笑：花期4-6月，位于标本馆前、校医院前花坛</li><li>红花酢浆草：校园花坛广布</li><li>红花石蒜：位于樱花大道至标本馆一带</li><li>海桐：花期4-5月，人文馆周边</li><li>合欢：珞珈山庄背面山坡、鲲鹏广场</li><li>花木兰：学校行道树</li><li>金丝桃：花期7-8月，梅园花坛</li><li>金银花：又名忍冬，花期4-6月，路旁、山坡灌丛、疏林中</li><li>鸡冠花：花期8-10月，花坛栽培</li><li>郁李：位于樱园</li><li>鸢尾：梅园花坛</li><li>棕榈：茶港教工生活区行道树</li><li>水杉：茶港教工生活区行道树</li><li>马尾松：南三区教工宿舍区</li><li>石榴：南三区教工宿舍区</li><li>女贞：狮子山、行政楼</li><li>枫树：枫园、奥场、珞珈广场</li><li>枫香树：枫园</li><li>桑树：信部、樱顶</li><li>樱花大道旁8棵银杏是20世纪30年代珞珈山建校初期栽植</li><li>罗汉松：育才路</li><li>绿樱：行政楼前</li><li>美人梅：梅园，梅和紫叶李杂交</li><li>阿拉伯婆婆纳：</li><li>柞树：武大附小花坛旁</li><li>南酸枣：武大梅园，名木</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文理学部李达塑像&quot;&gt;&lt;a href=&quot;#文理学部李达塑像&quot; class=&quot;headerlink&quot; title=&quot;文理学部李达塑像&quot;&gt;&lt;/a&gt;文理学部李达塑像&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;樟树&lt;/li&gt;
&lt;li&gt;蝴蝶花：4月，鸢尾科&lt;/li&gt;
&lt;li&gt;鸢尾&lt;/li&gt;
&lt;li&gt;吉祥草：百合科，秋花&lt;/li&gt;
&lt;li&gt;南天竹：小檗科&lt;/li&gt;
&lt;li&gt;锦绣杜鹃：杜鹃科&lt;/li&gt;
&lt;li&gt;麦冬：百合科，6月开花&lt;/li&gt;
&lt;li&gt;池衫&lt;/li&gt;
&lt;li&gt;羊蹄：蓼科，酸模属&lt;/li&gt;
&lt;li&gt;车前&lt;/li&gt;
&lt;li&gt;蛇莓：蔷薇科，果不能吃&lt;/li&gt;
&lt;li&gt;扬子毛茛&lt;/li&gt;
&lt;li&gt;何首乌：蓼科&lt;/li&gt;
&lt;li&gt;鸡矢藤：蓼科&lt;/li&gt;
&lt;li&gt;海仙花&lt;/li&gt;
&lt;li&gt;紫丁香&lt;/li&gt;
&lt;li&gt;厚萼凌霄：位于亭子，6月开花&lt;/li&gt;
&lt;li&gt;紫荆：苏木亚科，早春&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="https://tianwenyu.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="杂七杂八" scheme="https://tianwenyu.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>【Python Trick】Python中字典常用方法</title>
    <link href="https://tianwenyu.github.io/python-dict/"/>
    <id>https://tianwenyu.github.io/python-dict/</id>
    <published>2018-02-08T12:29:30.000Z</published>
    <updated>2018-02-27T07:28:34.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典常用操作"><a href="#字典常用操作" class="headerlink" title="字典常用操作"></a>字典常用操作</h2><h3 id="定义空字典"><a href="#定义空字典" class="headerlink" title="定义空字典"></a>定义空字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="键值对的添加"><a href="#键值对的添加" class="headerlink" title="键值对的添加"></a>键值对的添加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic[<span class="string">'name'</span>]=<span class="string">'zhangsan'</span></span><br></pre></td></tr></table></figure><h2 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h2><p>通过<code>items()</code>方法返回的元组列表进行序列解包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(key,value))</span><br><span class="line">    <span class="comment">#print('%s:%s' %(key,value))</span></span><br></pre></td></tr></table></figure><h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><h3 id="字典按键排序"><a href="#字典按键排序" class="headerlink" title="字典按键排序"></a>字典按键排序</h3><h4 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">print(key,dic[key] <span class="keyword">for</span> key <span class="keyword">in</span> sorted(dic.keys))</span><br></pre></td></tr></table></figure><h4 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#升序排序</span></span><br><span class="line">dic=dict(sorted(dic.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#降序排序</span></span><br><span class="line">dic=dict(sorted(dic.itmes(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>))</span><br></pre></td></tr></table></figure><p><code>sorted(iterable,key,reverse)</code></p><ul><li><code>iterable</code>参数代表可以迭代的对象，例如可以是<code>dict.items()</code>，<code>dict.keys()</code></li><li><code>key</code>参数是一个函数，用来选取参与比较的元素</li><li><code>reverse</code>参数用来指定是升序还是降序</li></ul><p><code>dic=dict(sorted(dic.items(),key=lambda x:x[0]))</code></p><ul><li><p><code>dic.items()</code>将<code>dic</code>转换为可迭代对象，迭代对象的元素为该字典元素，将其转换为元组</p></li><li><p>key参数对应的lambda表达式即选取元组中的第一个元素作为比较参数，即键。</p><p><code>lambda x:y</code>x表示输出参数，y表示lambda函数的返回值.</p></li><li><p><code>sorted()</code>函数返回值是list类型。</p></li></ul><h3 id="字典按值排序并输出Top-K个元素"><a href="#字典按值排序并输出Top-K个元素" class="headerlink" title="字典按值排序并输出Top K个元素"></a>字典按值排序并输出Top K个元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#升序排序</span></span><br><span class="line">dic=dict(sorted(dic.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]))</span><br><span class="line"><span class="comment">#降序排序</span></span><br><span class="line">dic=dict(sorted(dic.itmes(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出Top K个</span></span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line">k=<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt&gt;k:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(key,value))</span><br></pre></td></tr></table></figure><h2 id="字典对象写入Json文件"><a href="#字典对象写入Json文件" class="headerlink" title="字典对象写入Json文件"></a>字典对象写入Json文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dic=&#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"key2"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">"key3"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"key4"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#中文字符需要设置ensure_ascii属性为False，否则输出为ASII码</span></span><br><span class="line">data=json.dumps(dic,ensure_ascii=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'xxx.json'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字典常用操作&quot;&gt;&lt;a href=&quot;#字典常用操作&quot; class=&quot;headerlink&quot; title=&quot;字典常用操作&quot;&gt;&lt;/a&gt;字典常用操作&lt;/h2&gt;&lt;h3 id=&quot;定义空字典&quot;&gt;&lt;a href=&quot;#定义空字典&quot; class=&quot;headerlink&quot; title=&quot;定义空字典&quot;&gt;&lt;/a&gt;定义空字典&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dic=&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tianwenyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://tianwenyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【Python Trick】Python的switch-case实现</title>
    <link href="https://tianwenyu.github.io/python-switch/"/>
    <id>https://tianwenyu.github.io/python-switch/</id>
    <published>2018-02-07T12:29:30.000Z</published>
    <updated>2018-02-07T02:58:20.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Python中，并没有实现<code>switch-case</code>语句，通过<code>if-elif</code>实现会显得麻烦，因此通过以下方式实现该语句功能。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="通过字典实现"><a href="#通过字典实现" class="headerlink" title="通过字典实现"></a>通过字典实现</h3><p>以如下情景为例，将百分制分数转换为五分制分数。如<code>100%</code>转换为<code>5</code>，<code>80%</code>转换为<code>4</code>等。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(score)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">'100%'</span>:<span class="number">5</span>,</span><br><span class="line">            <span class="string">'80%'</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="string">'60%'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'40%'</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="string">'20%'</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">'0%'</span>:<span class="number">0</span></span><br><span class="line">        &#125;.get(score)</span><br><span class="line"></span><br><span class="line">print(foo(<span class="string">'100%'</span>)) <span class="comment">#输出5</span></span><br><span class="line">print(foo(<span class="string">'80%'</span>)) <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure><h3 id="通过匿名函数实现"><a href="#通过匿名函数实现" class="headerlink" title="通过匿名函数实现"></a>通过匿名函数实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(score,x)</span>:</span></span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line"><span class="string">'100%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">5</span>,</span><br><span class="line"><span class="string">'80%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">4</span>,</span><br><span class="line"><span class="string">'60%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">3</span>,</span><br><span class="line"><span class="string">'40%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">2</span>,</span><br><span class="line"><span class="string">'20%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">1</span>,</span><br><span class="line"><span class="string">'0%'</span>:<span class="keyword">lambda</span> x:x+<span class="number">0</span>,</span><br><span class="line">&#125;[score](x)</span><br><span class="line"></span><br><span class="line">print(foo(<span class="string">'100%'</span>,<span class="number">0</span>)) <span class="comment">#输出5</span></span><br><span class="line">print(foo(<span class="string">'80%'</span>,<span class="number">0</span>)) <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Python中，并没有实现&lt;code&gt;switch-case&lt;/code&gt;语句，通过&lt;code&gt;if-elif&lt;/code&gt;实现会显得麻烦，因此通过以下方式实现该语句功能。&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h2&gt;&lt;h3 id=&quot;通过字典实现&quot;&gt;&lt;a href=&quot;#通过字典实现&quot; class=&quot;headerlink&quot; title=&quot;通过字典实现&quot;&gt;&lt;/a&gt;通过字典实现&lt;/h3&gt;&lt;p&gt;以如下情景为例，将百分制分数转换为五分制分数。如&lt;code&gt;100%&lt;/code&gt;转换为&lt;code&gt;5&lt;/code&gt;，&lt;code&gt;80%&lt;/code&gt;转换为&lt;code&gt;4&lt;/code&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tianwenyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://tianwenyu.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
